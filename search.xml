<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android系统之SystemUI</title>
    <url>/2020/03/01/Android%E7%B3%BB%E7%BB%9F-SystemUI/</url>
    <content><![CDATA[<h2 id="一、什么是SystemUI"><a href="#一、什么是SystemUI" class="headerlink" title="一、什么是SystemUI?"></a>一、什么是SystemUI?</h2><p>　　SystemUI是为用户提供系统级别的信息显示与交互的一套UI组件。<br>　　屏幕顶端的状态栏、底部的导航栏、图片壁纸以及Recent-Panel（近期使用的APP列表）都属于SystemUI的范畴。SystemUI中还有一个名为TakeScreenshotService的服务，用于在用户按下音量下键与电源键时进行截屏操作。</p>
<a id="more"></a>

<p>　　SystemUI还提供了PowerUI和RingtonePlayer两个服务。前者负责监控系统的剩余电量并在必要时为用户显示低电警告，后者则依托AudioService向其他应用程序提供播放铃声的功能。</p>
<h2 id="二、SystemUIService的启动"><a href="#二、SystemUIService的启动" class="headerlink" title="二、SystemUIService的启动"></a>二、SystemUIService的启动</h2><p>　　尽管SystemUI的表现形式与普通的Android应用程序大相径庭，但它却是以一个<strong>APK</strong>的形式存在于系统之中，即它与普通的Android应用程序并没有本质上的区别。无非是通过Android 4大组件中的Activity、Service、BroadcastReceiver接受外界的请求并执行相关的操作，只不过它们所接受的请求主要来自各个系统服务而已。<br>　　SystemUI包罗万象，并且大部分功能之间相互独立，比如RecentPanel、TakeScreen-shotService等均是按需启动，并在完成其既定任务后退出，这与普通的Activity以及Service别无二致。比较特殊的是状态栏、导航栏等组件的启动方式。它们运行于一个称为<strong>SystemUIService</strong>的Service中。因此讨论<strong>状态栏与导航栏的启动过程其实就是SystemUIService的启动过程</strong>。</p>
<p>　　SystemUIService是一个容器。在其启动时，将会逐个实例化定义在SERVICIES列表中的继承自SystemUI抽象类的子服务。在调用子服务的start（）方法之后，SystemUIService便不再做任何其他的事情，任由各个子服务自行运行。</p>
<h4 id="状态栏与导航栏的启动过程："><a href="#状态栏与导航栏的启动过程：" class="headerlink" title="状态栏与导航栏的启动过程："></a>状态栏与导航栏的启动过程：</h4><ul>
<li>获取IStatusBarService。IStatusBarService是运行于system_server的一个系统服务，它接受操作状态栏/导航栏的请求并将其转发给BaseStatusBar。为了保证SystemUI意外退出后不会发生信息丢失，IStatusBarService保存了所有需要状态栏与导航栏进行显示或处理的信息副本。</li>
<li>将一个继承自IStatusBar.Stub的CommandQueue的实例注册到IStatusBarService以建立通信，并将信息副本取回。</li>
<li>通过调用子类的createAndAddWindows（）方法完成状态栏与导航栏的控件树及窗口的创建与显示。</li>
<li>使用从IStatusBarService取回的信息副本。</li>
</ul>
<h2 id="三、SystemUI-体系结构"><a href="#三、SystemUI-体系结构" class="headerlink" title="三、SystemUI 体系结构"></a>三、SystemUI 体系结构</h2><p><img src="/images/img_system_ui.png" alt="img_system_ui"></p>
<ul>
<li><strong>SystemUIService</strong>：一个普通的Android服务，它以一个容器的角色运行于SystemUI进程中。在它内部运行着多个子服务，其中之一便是状态栏与导航栏的实现者——BaseStatusBar的子类之一。</li>
<li><strong>StatusBarManagerService</strong>：是状态栏/导航栏向外界提供服务的前端接口，运行于system_server进程中。</li>
<li><strong>BaseStatusBar</strong>：BaseStatusBar及其子类是状态栏与导航栏的实际实现者，运行于SystemUIService中。</li>
<li><strong>CommandQueue</strong>：SystemUI中的CommandQueue是联系StatusBarManagerService与BaseStatusBar的桥梁。</li>
</ul>
<p>　　SystemUI中还包含了ImageWallpaper、RecentPanel以及TakeScreenshotService等功能的实现。它们是Service、Activity等标准的Android应用程序组件，并且互相独立。</p>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统之Framework</title>
    <url>/2020/03/01/Android%E7%B3%BB%E7%BB%9F-Framework/</url>
    <content><![CDATA[<h2 id="一、Android-系统架构"><a href="#一、Android-系统架构" class="headerlink" title="一、Android 系统架构"></a>一、Android 系统架构</h2><p>　　Android系统架构是安卓系统的体系结构，和其操作系统一样，采用了分层的架构，共分为四层：</p>
<ul>
<li>应用层（Applications）</li>
<li>应用框架层（Framework）</li>
<li>系统运行层（Librarys + Android Runtime）</li>
<li>Linux内核层（Linux Kernel）</li>
</ul>
<a id="more"></a>

<p><img src="/images/img_android_framework.jpg" alt="img_android_framework"></p>
<h2 id="二、什么是-Framework？"><a href="#二、什么是-Framework？" class="headerlink" title="二、什么是 Framework？"></a>二、什么是 Framework？</h2><p>　　Android Framework 位于Android系统架构的第二层，是把一些基本的的或者和设备打交道的服务抽象起来作API，给Application应用调用。这里是用Android中最底层的java代码。里面通过JNI调用c、c++（Library）来和设备打交道，最终调用到Linux内核。</p>
<p><strong>作用：</strong><br>　　提供Android开发人员一系列的服务与API接口。</p>
<h2 id="三、Framework-组成"><a href="#三、Framework-组成" class="headerlink" title="三、Framework 组成"></a>三、Framework 组成</h2><h3 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1. 服务端"></a>1. 服务端</h3><p>（1）<strong>ActivityManagerService(AMS)</strong>：负责调度整个app中的Activity，管理所有Activity的生命周期。是Android上层系统最核心的模块之一，主要对Android的四大组件进行管理也包括一些诸如：电源，窗口，权限的内容。<br>（2）<strong>WindowsManagerService(WMS)</strong>：为所有的应用程序分配窗口，并管理这些窗口。<br>（3）<strong>PackageManagerService(PMS)</strong>：管理所有Package的信息，包括安装、卸载、更新等。<br><strong>注意：</strong> Android系统的三个核心：AMS、WMS、View。</p>
<h3 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h3><p>（1）ActivityThread：应用程序的主线程类，所有的应用程序有且只有一个ActivityThread，程序的入口为main函数。<br>（2）Activity：apk运行的最小单位。<br>（3）ViewRoot：负责客户端和WMS的交互。内部类有 W 类，W类继承自Binder， 负责ViewRoot和WMS之间的IPC通信。内部还有 ViewRootHandler 继承自Handler，当W类收到消息以后通过ViewRootHandler可以发送给UI线程。<br>（4）PhoneWindow：继承自Window，对外提供了统一窗口操作API，里面放置了一个DecorView类。<br>（5）DecorView：PhoneWindow的内部类，继承自FrameLayout，可以看到的View的所有，我们写的布局View就是放在这个里面。<br>（6）WindowsManager：客户端和WMS交流的中介，客户端想要创建窗口，得先提前告知WindowsManager，客户端不能直接和WMS通信。</p>
<h3 id="3-Linux驱动"><a href="#3-Linux驱动" class="headerlink" title="3. Linux驱动"></a>3. Linux驱动</h3><p>（1）SurfaceFlingger(SF)：负责将各个画面(Surface)显示到屏幕上。<br>（2）Binder：负责跨进程的IPC通信。</p>
<h2 id="四、有关-Framework-的知识点"><a href="#四、有关-Framework-的知识点" class="headerlink" title="四、有关 Framework 的知识点"></a>四、有关 Framework 的知识点</h2><h3 id="1-APK的打包流程"><a href="#1-APK的打包流程" class="headerlink" title="1. APK的打包流程"></a>1. APK的打包流程</h3><p>（1）打包资源文件，生成R.java文件。（aapt工具：Android资源打包工具）<br>（2）处理AIDL文件，生成对应的Java文件。如果没有AIDL文件，此步骤无。（aidl工具）<br>（3）编译Java文件，生成对应的Class文件。（javac工具）<br>（4）把Class文件转化成DVM支持的Dex文件。（dex工具）<br>（5）打包生成未签名的APK文件。(apkbuilder工具)<br>（6）对未签名的APK文件进行签名。（jarsigner工具：jar文件的签名工具）<br>（7）对签名后的APK文件进行对齐处理。如果不进行对齐处理，就不能发布到谷歌应用商店。（zipalign工具：字节码对齐工具）</p>
<h3 id="2-APP的启动流程"><a href="#2-APP的启动流程" class="headerlink" title="2. APP的启动流程"></a>2. APP的启动流程</h3><p><img src="/images/img_app_start.png" alt="img_app_start"></p>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM之垃圾收集算法和垃圾回收机制</title>
    <url>/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="一、何时GC？"><a href="#一、何时GC？" class="headerlink" title="一、何时GC？"></a>一、何时GC？</h2><h3 id="（一）引用计数算法"><a href="#（一）引用计数算法" class="headerlink" title="（一）引用计数算法"></a>（一）引用计数算法</h3><p>　　给对象添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加1； 当引用失效时， 计数器值就减1； 任何时刻计数器为0的对象就是不可能被再使用的。<br>　　主流的JVM里面没有选用引用计数算法来管理内存， 其中最主要的原因是它<strong>很难解决对象间的互循环引用的问题</strong>。</p>
<a id="more"></a>

<h3 id="（二）可达性分析算法"><a href="#（二）可达性分析算法" class="headerlink" title="（二）可达性分析算法"></a>（二）可达性分析算法</h3><p>通过一些列的称为“<strong>GC Roots</strong>”的对象作为起始点， 从这些节点开始向下搜索， 搜索所走过的路径称为<strong>引用链</strong>， <em>当一个对象到GC Roots没有任何引用链相连时</em>（就是从GC Roots 到这个对象是不可达）， 则证明此对象是不可用的。 所以它们会被判定为可回收对象。</p>
<p>在Java语言中， <strong>可以作为GC Roots的对象</strong>包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象；</li>
</ul>
<p>　　总结就是， 方法运行时， 方法中引用的对象； 类的静态变量引用的对象； 类中常量引用的对象； Native方法中引用的对象</p>
<h4 id="判断对象“死亡”："><a href="#判断对象“死亡”：" class="headerlink" title="判断对象“死亡”："></a>判断对象“死亡”：</h4><p>　　在可达性分析算法中， 要真正宣告一个对象死亡， 至少要经历<strong>两次标记</strong>过程：</p>
<ol>
<li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链， 那它将会被第一次标记并且进行一次筛选， 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有 覆盖finalize()方法， 或者finalize()方法已经被虚拟机调用过， 虚拟机将这两种情况都视为“没有必要执行”。</li>
<li>如果这个对象被判定为有必要执行finalize()方法， 那么这个对象将会放置在一个叫做F-Queue队列之中， 并在稍后由一个由虚拟机自动建立的、 低优先级的Finalizer线程去执行它。 finalize()方法是对象逃脱死亡命运的最后一次机会， 稍候GC将对F-Queue中的对象进行第二次小规模的标记， 如果对象要在finalie()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可， 譬如把自己（this关键字） 赋值给某个类变量或者对象的成员变量， 那在第二次标记时它将会被移除出“即将回收”的集合； 如果对象这时候还没有逃脱， 那基本上它就真的被回收了。</li>
</ol>
<h4 id="什么是强引用、-软引用、-弱引用、-虚引用？"><a href="#什么是强引用、-软引用、-弱引用、-虚引用？" class="headerlink" title="什么是强引用、 软引用、 弱引用、 虚引用？"></a>什么是强引用、 软引用、 弱引用、 虚引用？</h4><p>在JDK1.2之后， Java对引用的概念进行了扩充， 将引用分为强引用（Strong Reference）、 软引用（Soft Reference）、 弱引用（ Weak Reference）、 虚引用（Phantom Reference）四种， 这四种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用： 就是指在程序代码之中普遍存在的， 类似“Object obj = new Object()”这类的引用， 只要强引用还存在， 垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用： 用来描述一些还有用但并非必须的对象。 在系统将要发生内存溢出异常之前， 将会把这些对象列进回收范围之中进行第二次回收。使用SoftReference来实现软引用。</li>
<li>弱引用： 用户描述非必须对象的。 被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 当垃圾收集器工作时， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。使用WeakReference来实现弱引用。</li>
<li>虚引用： 也称幽灵引用或幻影引用。 一个对象是否有虚引用存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例。 为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时刻得到一个系统通知。使用PhantomReference来实现虚引用。</li>
</ul>
<h2 id="二、垃圾收集算法"><a href="#二、垃圾收集算法" class="headerlink" title="二、垃圾收集算法"></a>二、垃圾收集算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h3><p>　　最基础的收集算法是“标记-清除”（Mark-Sweep）算法， 算法分为“标记”和“清除”两个阶段：<br>① 首先标记出所有需要回收的对象。<br>② 在标记完成后统一回收所有被标记的对象。<br>缺点：<br>效率问题： 标记和清除两个过程的效率都不高<br>空间问题： 标记清除之后产生大量不连续的内存碎片， 空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时， 无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h3><p>　　复制算法是为了解决效率问题。将可用内存按容量大小划分为大小相等的两块， 每次只使用其中的一块。 当一块内存使用完了， 就将还存活着的对象复制到另一块上面， 然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对整个半区进行内存回收， 内存分配时也就不用考虑内存碎片等复杂情况。<br>缺点： 将内存缩小为了原来的一半。</p>
<p>　　<strong>新生代</strong>中对象98%对象是“朝生夕死”的， 所以不需要按照1： 1的比例来划分内存空间， 而是将内存分为较大的Eden空间和两块较小的Survivor空间， 每次使用Eden和其中一块Survivor。 当回收时， 将Eden和Survivor中还存活着的对象一次性地复制到另外一块Eden空间上， 最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>　　HotSpot虚拟机中默认Eden和Survivor的大小比例是8 : 1。这样只有10%的空间会被浪费。当然，如果另外空间一块Survivor空间没有足够空间（需要的空间大于10%）存放上一次新生代收集下来的存活对象时，这些对象将直接通过<strong>分配担保机制</strong>进入老年代。</p>
<h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3. 标记-整理算法"></a>3. 标记-整理算法</h3><p>　　复制算法在对象存活率较高时， 就要进行较多的复制操作， 效率就会变低。 根据<strong>老年代</strong>的特点， 提出了“标记-整理”算法。<br>标记过程仍然与”标记-清除“算法一样， 但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向一端移动， 然后直接清理掉边界以外的内存。</p>
<h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><p>一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>， 这样就可以根据各个年代的特点采用最适当的收集算法。<br>（1）在新生代中， 每次垃圾收集时都发现有大批对象死去， 只有少量存活， 那就选用复制算法。<br>（2）在老年代中， 因为对象存活率高、 没有额外空间对它进行分配担保， 就必须采用“标记-清除”或“标记-整理”算法来进行回收。</p>
<h2 id="三、垃圾回收机制（GC）"><a href="#三、垃圾回收机制（GC）" class="headerlink" title="三、垃圾回收机制（GC）"></a>三、垃圾回收机制（GC）</h2><p>　　垃圾回收机制（Garbage Collection），简称GC。是Java语言的核心技术之一， 在Java中，当一个对象不能再被后续程序所引用到时，这个对象所占用的内存空间就没有存在的意义了，Java虚拟机会不定时的去检测内存中这样的对象，然后自动回收这块内存空间。这个机制就叫做垃圾回收机制。<br>　　下面介绍一些有关GC的概念问题。</p>
<h3 id="1-Minor-GC-和-Full-GC"><a href="#1-Minor-GC-和-Full-GC" class="headerlink" title="1. Minor GC 和 Full GC"></a>1. Minor GC 和 Full GC</h3><ul>
<li>Minor GC：指发生在新生代的垃圾收集动作， 该动作非常频繁。</li>
<li>Full GC/Major GC：指发生在老年代的垃圾收集动作， 出现了Major GC， 经常会伴随至少一次的Minor GC。 Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
<h3 id="2-JVM中的年代"><a href="#2-JVM中的年代" class="headerlink" title="2. JVM中的年代"></a>2. JVM中的年代</h3><p>　　JVM中分为年轻代（Young generation）和老年代(Tenured generation)。HotSpot JVM把年轻代分为了三部分： 1个Eden区和2个Survivor区（ 分别叫from和to） 。 默认比例为8： 1。<br>　　一般情况下， 新创建的对象都会被分配到Eden区(一些大对象特殊处理)， 这些对象经过第一次Minor GC后， 如果仍然存活， 将会被移到Survivor区。 对象在Survivor区中每熬过一次Minor GC， 年龄就会增加1岁， 当它的年龄增加到一定程度时， 就会被移动到年老代中。 因为年轻代中的对象基本都是朝生夕死的(80%以上)， 所以在年轻代的垃圾回收算法使用的是复制算法。复制算法不会产生内存碎片。在GC开始的时候， 对象只会存在于Eden区和名为“From”的Survivor区， Survivor区“To”是空的。 紧接着进行GC， Eden区中所有存活的对象都会被复制到“To”， 而在“From”区中， 仍存活的对象会根据他们的年龄值来决定去向。 年龄达到一定值(年龄阈值， 可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中， 没有达到阈值的对象会被复制到“To”区域。 经过这次GC后， Eden区和From区已经被清空。 这个时候， “From”和“To”会交换他们的角色， 也就是新的“To”就是上次GC前的“From”， 新的“From”就是上次GC前的“To”。 不管怎样， 都会保证名为To的Survivor区域是空的。 Minor GC会一直重复这样的过程， 直到“To”区被填满， “To”区被填满之后， 会将所有对象移动到年老代中。</p>
<h3 id="3-空间分配担保"><a href="#3-空间分配担保" class="headerlink" title="3. 空间分配担保"></a>3. 空间分配担保</h3><p>　　在发生Minor GC之前， 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间， 如果这个条件成立， 那么Minor GC可以 确保是安全的。 如果不成立， 则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许， 那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于， 则将尝试进行一次Minor GC， 尽管这个Minor GC是有风险的。 如果小于， 者HandlePromotionFailure设置不允许冒险， 那这时也要改为进行一次Full GC。</p>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM之类加载机制和类加载器</title>
    <url>/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一、类加载机制"><a href="#一、类加载机制" class="headerlink" title="一、类加载机制"></a>一、类加载机制</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>　　虚拟机把描述类的数据从Class文件加载到内存， 并对数据进行校验、 转换解析和初始化， 最终形成可以被虚拟机直接使用的Java类型。</p>
<a id="more"></a>

<h3 id="2-类的声明周期"><a href="#2-类的声明周期" class="headerlink" title="2. 类的声明周期"></a>2. 类的声明周期</h3><p><img src="/images/img_class_life_cycle.png" alt="img_class_life_cycle"></p>
<p>　　其中，验证、准备、解析这三个步骤统称为连接。<br>　　类加载机制中的<strong>步骤</strong>：<strong>加载， 验证， 准备， 解析及初始化</strong> （解析阶段的顺序不一定，它在某些情况下可以在初始化完成后再开始）</p>
<h3 id="3-触发类加载的条件"><a href="#3-触发类加载的条件" class="headerlink" title="3. 触发类加载的条件"></a>3. 触发类加载的条件</h3><p>① 遇到new，getstatic，putstatic或invokestatic这4条字节码指令时， 如果类没有进行过初始化， 则需要先触发初始化。<br>② 使用java.lang.reflect包的方法对类进行反射调用的时候。<br>③ 当初始化一个类的时候， 发现其父类还没有进行过初始化， 则需要先出发父类的初始化。<br>④ 当虚拟机启动时， 用户需要指定一个要执行的主类（包含main()方法的那个类） ， 虚拟机会先初始化这个主类。<br>⑤ 当使用JDK1.7的动态语言支持时， 如果一个java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic,REF_putStatic,REF_invokeStatic 的方法句柄， 并且这个方法句柄所对应的类没有进行初始化， 则需要先出发初始化。</p>
<h3 id="4-类加载的具体过程"><a href="#4-类加载的具体过程" class="headerlink" title="4. 类加载的具体过程"></a>4. 类加载的具体过程</h3><h4 id="（1）加载"><a href="#（1）加载" class="headerlink" title="（1）加载"></a>（1）加载</h4><p>① 通过一个类的全限定名来获取定义此类的二进制字节流。<br>② 将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构。<br>③ 在内存中生成一个代表这个类的java.lang.Class对象， 作为方法区这个类的各种数据的访问入口。</p>
<h4 id="（2）验证"><a href="#（2）验证" class="headerlink" title="（2）验证"></a>（2）验证</h4><p>　　是连接阶段的第一步， 目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求， 并且不会危害虚拟机自身的安全。</p>
<p><strong>包含四个阶段的校验动作：</strong><br><strong>a.文件格式验证</strong><br>　　验证字节流是否符合Class文件格式的规范， 并且能被当前版本的虚拟机处理。<br><strong>b.元数据验证</strong><br>　　对类的元数据信息进行语义校验， 是否存在不符合Java语言规范的元数据信息。<br><strong>c.字节码验证</strong><br>　　最复杂的一个阶段， 主要目的是通过数据流和控制流分析， 确定程序语义是合法的， 符合逻辑的。 对类的方法体进行校验分析， 保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。<br><strong>d.符号引用验证</strong><br>　　确保解析动作能正常进行。</p>
<h4 id="（3）准备"><a href="#（3）准备" class="headerlink" title="（3）准备"></a>（3）准备</h4><p>　　准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。 这些变量所使用的内存都将在方法区中分配。 只包括类变量。 初始值“通常情况”下是数据类型的零值。<br>　　“特殊情况”下， 如果类字段的字段属性表中存在ConstantValue属性， 那么在准备阶段变量的值就会被初始化为ConstantValue属性所指定的值。</p>
<h4 id="（4）解析："><a href="#（4）解析：" class="headerlink" title="（4）解析："></a>（4）解析：</h4><p>　　虚拟机将常量池内的符号引用替换为直接引用的过程。<br>　　“动态解析”的含义就是必须等到程序实际运行到这条指令的时候， 解析动作才能进行。 相对的， 其余可触发解析的指令都是“静态”的， 可以在刚刚完成加载阶段， 还没有开始执行代码时就进行解析。</p>
<h4 id="（5）初始化："><a href="#（5）初始化：" class="headerlink" title="（5）初始化："></a>（5）初始化：</h4><p>　　类加载过程中的最后一步。简单地说， 初始化就是对类变量进行赋值及执行静态代码块。<br>　　初始化阶段是执行类构造器 &lt;clinit&gt;() 方法的过程。<br>　　&lt;clinit&gt;() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。<br>　　&lt;clinit&gt;() 与类的构造函数不同， 它不需要显示地调用父类构造器， 虚拟机会保证在子类的 &lt;clinit&gt;() 方法执行之前， 父类的 &lt;clinit&gt;() 方法已经执行完毕。</p>
<h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><p>　　类加载机制的加载部分的功能是将类的class文件读入内存， 并为之创建一个java.lang.Class对象。 这部分功能就是由类加载器来实现的。</p>
<h3 id="1-类加载器分类"><a href="#1-类加载器分类" class="headerlink" title="1. 类加载器分类"></a>1. 类加载器分类</h3><p>　　不同的类加载器负责加载不同的类。 主要分为两类。<br>（1）启动类加载器（Bootstrap ClassLoader）<br>　　由C++语言实现（针对HotSpot） ，负责将存放在\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中， 即负责加载Java的核心类。<br>（2）其他类加载器<br>　　由Java语言实现， 继承自抽象类ClassLoader。 如：</p>
<ul>
<li>扩展类加载器（Extension ClassLoader）： 负责载\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库， 即负责加载Java扩展的核心类之外的类。</li>
<li>应用程序类加载器（Application ClassLoader）： 负责加载用户类路径（classpath） 上的指定类库， 我们可以直接使用这个类加载器， 通过ClassLoader.getSystemClassLoader()方法直接获取。 一般情况， 如果我们没有自定义类加载器<strong>默认</strong>就是用这个加载器。</li>
</ul>
<h3 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2. 双亲委派模型"></a>2. 双亲委派模型</h3><h4 id="（1）工作流程"><a href="#（1）工作流程" class="headerlink" title="（1）工作流程"></a>（1）工作流程</h4><p>　　如果一个类加载器收到了类加载的请求， 它首先不会自己去尝试加载这个类， 而是把请求委托给父加载器去完成， 依次向上， 因此， 所有的类加载请求最终都应该被传递到顶层的启动类加载器中， 只有当父加载器在它的搜索范围中没有找到所需的类时， 即无法完成该加载， 子加载器才会尝试自己去加载该类。</p>
<h4 id="（2）好处"><a href="#（2）好处" class="headerlink" title="（2）好处"></a>（2）好处</h4><ul>
<li>无论哪个类加载器加载该类， 最终都是由启动类加载<br>器进行加载， 保证安全。</li>
<li>即使用户自己编写一个系统类（如：java.lang.Object类）并放入程序中，虽能正常编译， 但不会被加载运行， 保证不会出现混乱。</li>
</ul>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>开源框架（三） 图片加载框架</title>
    <url>/2020/03/01/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-3-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="一、Picasso"><a href="#一、Picasso" class="headerlink" title="一、Picasso"></a>一、Picasso</h2><ol>
<li>缓存图片的原图到本地（即时改变了图片的大小，也是下载一次完全大小的图片）</li>
<li>默认Bitmap格式为ARGB_8888，内存占用较大</li>
</ol>
<a id="more"></a>

<h2 id="二、Glide"><a href="#二、Glide" class="headerlink" title="二、Glide"></a>二、Glide</h2><ol>
<li>改变图片的大小再加载到内存（减小OOM的可能性）</li>
<li>默认Bitmap格式为RGB_565</li>
<li>与Activity/Fragment生命周期一致</li>
</ol>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p><img src="/images/img_glide.jpg" alt="img_glide"></p>
<h2 id="三、Fresco"><a href="#三、Fresco" class="headerlink" title="三、Fresco"></a>三、Fresco</h2><ol>
<li>使用了Ashmem匿名内存机制，有效地对内存块的图片进行管理（减少OOM的可能性）</li>
<li>多图请求，先加载低分辨率的图片，然后再显示高分辨率的图片</li>
<li>支持GIF、WebP格式</li>
</ol>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>开源框架（二） 依赖注入框架</title>
    <url>/2020/03/01/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-2-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="一、ButterKnife"><a href="#一、ButterKnife" class="headerlink" title="一、ButterKnife"></a>一、ButterKnife</h2><p>　　从严格意义讲不算是依赖注入框架， 它只是专注于Android系统的View注入框架， 并不支持其他方面的注入。 它可以减少大量的findViewById（@BindView）以及setOnClickListener（@OnClick）代码， 简化代码并提升开发效率。</p>
<a id="more"></a>

<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><ul>
<li>ButterKnife.bind(this)：根据Activity对应的Class得到一个继承了Unbinder的Constructor，最后通过<strong>反射</strong>constructor.newInstance(target, source)得到Unbinder子类的一个新的实例（MainActivity_ViewBinding的实例）。其中获取Constructor是通过LinkedHashMap缓存了对应的Class和Constructor以提高效率。</li>
<li>注解处理器：通过注解处理器，将source值、ID等参数传入MainActivity_ViewBinding的findRequiredViewAsType方法，在该方法内部调用了findRequiredView方法，findRequiredView方法又调用了DecorView的findViewById方法并将R.id.tv_text对应的View返回。接着findRequiredViewAsType方法调用castView方法，将View强制转换成传入的Class值的类型（即对应的View.class），最终强制转换为对应的组件并返回，MainActivity_ViewBinding辅助类会把这个返回的组件会赋值给target，也就是MainActivity，这样在MainActivity就可以使用这个组件了。</li>
</ul>
<h2 id="二、Dagger"><a href="#二、Dagger" class="headerlink" title="二、Dagger"></a>二、Dagger</h2><p>　　Dagger是一个基于Java依赖注入标准的依赖注入框架， 在编译期间自动生成代码， 负责依赖对象的创建。</p>
<h3 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p>（1）创建Module容器（类），它的作用是提供实例化的对象，需要添加 @Module 注解。同时，创建提供实体类实例的方法并添加 @Provides 注解。<br>（2）创建Component连接件（接口），它是沟通调用者和容器的桥梁，需要添加 @Component 注解，并且用注解的modules属性指明作为容器的类。并在Component中定义抽象的inject注入方法。<br>（3）Rebuild项目，这时Dagger框架会自动创建一个以Dagger-开头的辅助类（DaggerMainComponent）。<br>（4）调用者首先使用DaggerMainComponent采用Builder模式来创建一个DaggerMainComponent的实例，需要传入一个Module容器的实例。接着调用inject方法将调用者注入。<br>（5）在调用者类中，声明一个实体类的变量，使用 @Inject 注解标记，即可获得该实体类的实例。</p>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>　　DaggerMainComponent重写了MainComponent接口的inject()方法，里边调用的injectMainActivity()方法是完成依赖注入的关键。它会调用生成的MainActivity_MembersInjector类，这个类中会将实例提供给被注入的Activity，而实例的生成则是通过另一个生成的MainModule_ProvideXxxxFactory来实现的，这个Factory中传入了我们创建的Module容器，并在里面调用我们所创建的provide实体的方法。最终就完成了实例的创建和注入，归根到底所创建的实例还是我们在Module里面定义和创建的。</p>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>开源框架（一） 网络框架</title>
    <url>/2020/03/01/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-1-%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="一、Volley"><a href="#一、Volley" class="headerlink" title="一、Volley"></a>一、Volley</h2><h3 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p>（1）通过Volley.newRequestQueue获取一个RequestQueue对象<br>（2）创建一个Request(StringRequest/JsonRequest/ImageRequest)对象<br>（3）将Request对象通过add方法添加到RequestQueue中</p>
<a id="more"></a>

<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p><img src="/images/img_volley.png" alt="img_volley"></p>
<h2 id="二-OkHttp"><a href="#二-OkHttp" class="headerlink" title="二. OkHttp"></a>二. OkHttp</h2><h3 id="1-使用方法-1"><a href="#1-使用方法-1" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p>（1）通过Request.Builder创建一个Request对象<br>（2）创建一个OkHttpClient对象<br>（3）将Request传入OkHttpClient对象中(mOkHttpClient.newCall(request))，来创建一个Call对象<br>（4）调用Call对象的execute(同步)/enqueue(异步)方法来执行</p>
<h3 id="2-原理-1"><a href="#2-原理-1" class="headerlink" title="2. 原理"></a>2. 原理</h3><p><img src="/images/img_okhttp.png" alt="img_okhttp"></p>
<h2 id="三、Retrofit"><a href="#三、Retrofit" class="headerlink" title="三、Retrofit"></a>三、Retrofit</h2><h3 id="1-使用方法-2"><a href="#1-使用方法-2" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p><strong>一般用法：</strong><br>（1）定义请求接口类，使用@GET/@POST注解注解编写网络请求接口<br>（2）使用Buider模式创建Retrofit实例<br>（3）通过Retrofit对象的create方法传入之前的请求接口类，来创建请求实体对象<br>（4）调用请求对象的请求方法生成能够发起网络请求的Call对象<br>（5）调用Call对象的enqueue方法发起异步网络请求</p>
<p><strong>高级用法：</strong><br>适配OkHttpCall的Factory：<br>（1）定义请求接口类，使用@GET/@POST注解编写网络请求接口<br>（2）使用单例模式创建一个RetrofitFactory<br>（3）在RetrofitFactory内部创建一个OkHttpClient，并通过Builder模式利用OkHttpClient来创建一个Retrofit实例<br>（4）通过Retrofit对象的create方法传入之前的请求接口类，来创建请求实体对象<br>（5）客户端通过RetroFactory来调用请求对象的请求方法生成能够发起网络请求的Call对象<br>（6）调用Call对象的enqueue方法发起异步网络请求</p>
<h3 id="2-原理-2"><a href="#2-原理-2" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>　　Retrofit的create方法通过<strong>动态代理</strong>的模式，生成了实现了具体的网络请求接口的对象，并在InvocationHandler的invoke方法中统一处理网络请求接口实体对象的方法，根据方法生成一个ServiceMethod对象，并将其放入缓存中，然后根据ServiceMethod对象和网络请求的参数去构造一个OkHttpCall对象，最后调用serviceMethod的callAdapter的adapt方法，传入将OkHttpCall对象。（callAdapter的目的主要是为了适配OkHttpCall对象，其内部会对OkHttpCall对象进行包装，生成对应返回类型的对象。）底层真正处理网络请求的还是OkHttp框架。</p>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM之Java内存区域和内存模型</title>
    <url>/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8BJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="一、Java-内存区域"><a href="#一、Java-内存区域" class="headerlink" title="一、Java 内存区域"></a>一、Java 内存区域</h2><ul>
<li><strong>方法区（公有）</strong>： 用户存储已被虚拟机加载的 <em>类信息， 常量， 静态常量， 即时编译器编译后的代码</em> 等数据。<br>其中包含<strong>常量池</strong>： 用户存放编译器生成的各种字面量和符号引用。<br>异常状态： OutOfMemoryError</li>
</ul>
<a id="more"></a>

<ul>
<li><strong>堆（公有）</strong>： 是JVM所管理的内存中<strong>最大</strong>的一块。 唯一目的就是存放 <em>实例对象</em> ， 几乎所有的对象实例都在这里分配。 Java堆是<strong>垃圾收集器管理的主要区域</strong>， 因此很多时候也被称为“GC堆”。<br>异常状态：OutOfMemoryError</li>
<li><strong>虚拟机栈（线程私有）</strong>： 描述的是Java方法执行的内存模型： 每个方法在执行时都会创建一个栈帧， 用户存储 <em>局部变量表， 操作数栈， 动态链接， 方法出口</em> 等信息。每一个方法从调用直至完成的过程， 就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>异常状态：OutOfMemoryError、StackOverflowError</li>
<li><strong>本地方法栈（线程私有）</strong>: 与虚拟机栈所发挥的作用相似。 它们之间的区别不过是虚拟机栈为虚拟机执行Java方法， 而本地方法栈为虚拟机使用到的Native方法。<br>异常状态：OutOfMemoryError、StackOverflowError</li>
<li><strong>程序计数器（线程私有）</strong>： 一块较小的内存， 当前线程所执行的字节码的行号指示器。 字节码解释器工作时， 就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。<br>异常状态：无（唯一一个没有规定任何OutOfMemoryError情况的区域）<br><img src="/images/img_java_memory_area.png" alt="img_java_memory_area"></li>
</ul>
<h2 id="二、Java-内存模型"><a href="#二、Java-内存模型" class="headerlink" title="二、Java 内存模型"></a>二、Java 内存模型</h2><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h3><p>　　屏蔽掉各种硬件和操作系统的内存访问差异， 以实现让java程序在各种平台下都能达到一致的内存访问效果。</p>
<h3 id="2-内容"><a href="#2-内容" class="headerlink" title="2. 内容"></a>2. 内容</h3><ul>
<li>所有的变量都存储在<strong>主内存</strong>中。</li>
<li>每条线程中还有自己的<strong>工作内存</strong>， 工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来） 。</li>
<li>线程对变量的所有操作（读取、赋值）都必须在工作内存中进行。</li>
<li>不同线程之间无法直接访问对方工作内存中的变量。</li>
<li>线程间变量值的传递均需要通过主内存来完成。<br><img src="/images/img_java_memory_model.png" alt="img_java_memory_model"></li>
</ul>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java集合</title>
    <url>/2020/02/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="一、Java集合总览"><a href="#一、Java集合总览" class="headerlink" title="一、Java集合总览"></a>一、Java集合总览</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center">是否有序</th>
<th align="center">是否允许重复元素</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Collection</td>
<td align="center"></td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">Set</td>
<td align="center">HashSet</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">Set</td>
<td align="center">TreeSet</td>
<td align="center">是(二叉树)</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">Map</td>
<td align="center">HashMap</td>
<td align="center">否</td>
<td align="center">Key不允许重复，Value允许重复</td>
</tr>
<tr>
<td align="center">Map</td>
<td align="center">TreeMap</td>
<td align="center">是(二叉树)</td>
<td align="center">Key不允许重复，Value允许重复</td>
</tr>
<tr>
<td align="center">List</td>
<td align="center"></td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="二、HashMap"><a href="#二、HashMap" class="headerlink" title="二、HashMap"></a>二、HashMap</h2><h3 id="（一）性质"><a href="#（一）性质" class="headerlink" title="（一）性质"></a>（一）性质</h3><p>（1）Key 和 Value 都可以为空<br>（2）value 允许重复， Key 不允许重复<br>（3）映射是无序的（散列有序），无法按照添加顺序遍历（注：LinkedHashMap 有序）<br>（4）HashMap是非线程同步的实现，因此不是线程安全的</p>
<p>注意：</p>
<ul>
<li>HashTable（Java 5.0 已废弃）是线程安全的，在单线程的条件下，速度要比HashMap慢</li>
<li>ConcurrentHashMap（Java 5.0 引入）是线程安全的</li>
<li>HashMap可以通过以下语句实现同步：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.synchronizeMap(hashMap);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h4><p>理想情况下，插入和查找的时间复杂度都是 O(1)。</p>
<p>（1）插入：<br>第一步：key.hashcode()，时间复杂度O(1)。<br>第二步：找到桶以后，判断桶里是否有元素，如果没有，直接new一个entey节点插入到数组中。时间复杂度O(1)。<br>第三步：如果桶里有元素，并且元素个数小于8，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(n)=O(n)。<br>第四步：如果桶里有元素，并且元素个数大于8，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(logn)=O(logn)。红黑树查询的时间复杂度是O(logn)。　　</p>
<p>（2）查找：<br>第一步：key.hashcode()，时间复杂度O(1)。<br>第二步：调用equals方法，比较是否存在相同名字的key，时间复杂度O(logn)/O(n)。</p>
<p>　　通过上面的分析，我们可以得出结论，HashMap实际的插入和查找的时间复杂度是不固定的，可能的值有O(1)、O(logn)、O(n)。</p>
<h4 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h4><p>两个重要参数：容量（Capacity）和 负载因子（Load Factor）</p>
<p>　　当Entry的数量大于（Capacity * Load Factor），则会重新resize一个原来长度 2 倍的HashMap，并且重新调用hash方法。</p>
<h3 id="（二）实现原理"><a href="#（二）实现原理" class="headerlink" title="（二）实现原理"></a>（二）实现原理</h3><h4 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1. 底层数据结构"></a>1. 底层数据结构</h4><ul>
<li>JDK 7：位桶(bucket)（Node[] table: 哈希桶数组） + 链表</li>
<li>JDK 8：位桶 + 链表/红黑树<br><img src="/images/img_hashmap.png" alt="img_hashmap"><h4 id="2-put方法-get方法"><a href="#2-put方法-get方法" class="headerlink" title="2. put方法 / get方法"></a>2. put方法 / get方法</h4>（1）<strong>put方法</strong> 原理：<br>　　1）先对key值进行hash操作计算hashCode， 然后再通过<br>hashCode进一步计算下标index；<br>　　2）根据index查找到对应的bucket</li>
<li>如果没发生碰撞直接放到bucket里；</li>
<li>如果碰撞了， 以链表的形式存在buckets后如果碰撞导致链表过长(大于等于 TREEIFY_THRESHOLD)， 就把链表转换成红黑树；</li>
</ul>
<p>　　3）如果节点已经存在就替换old value(保证key的唯一性)；<br>　　4）如果bucket满了(超过load factor * current capacity)， 就要resize。<br><img src="/images/img_hashmap_put.png" alt="img_hashmap_put"></p>
<p>（2）<strong>get方法</strong> 原理：<br>　　1）先对key值进行hash操作计算hashCode， 然后再通过<br>hashCode进一步计算下标index。<br>　　2）根据index查找到对应的bucket</p>
<ul>
<li>如果bucket里只有一个节点， 直接命中，取出它的value返回；</li>
<li>如果bucket的发生碰撞， 则通过key.equals()在链中找。<br>a. 若为链表， 则在链表中通过key.equals()查找， O(n)。<br>b. 若为树， 则在树中通过key.equals()查找， O(logn)；</li>
</ul>
<h2 id="三、ConcurrentHashMap"><a href="#三、ConcurrentHashMap" class="headerlink" title="三、ConcurrentHashMap"></a>三、ConcurrentHashMap</h2><h3 id="（一）引入ConcurrentHashMap的原因"><a href="#（一）引入ConcurrentHashMap的原因" class="headerlink" title="（一）引入ConcurrentHashMap的原因"></a>（一）引入ConcurrentHashMap的原因</h3><p>　　HashMap是非线程安全的。并发情况下，HashMap的put操作可能会导致Entry链表形成环，从而导致死循环。</p>
<h3 id="（二）实现原理-1"><a href="#（二）实现原理-1" class="headerlink" title="（二）实现原理"></a>（二）实现原理</h3><h4 id="JDK-1-6"><a href="#JDK-1-6" class="headerlink" title="JDK 1.6"></a>JDK 1.6</h4><p>　　ConcurrentHashMap采用 <strong>分段锁</strong> 的机制， 实现并发的更新操作， 底层采用　数组+链表+红黑树　的存储结构。 其包含两个核心静态内部类 Segment 和 HashEntry。</p>
<ol>
<li>Segment 继承 ReentrantLock 用来充当锁的角色， 每个 Segment 对象守护每个散列映射表的若干个桶；</li>
<li>HashEntry 用来封装映射表的键 / 值对；</li>
<li>每个桶是由若干个 HashEntry 对象链接起来的链表。</li>
</ol>
<p>　　一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。 结构如下：<br><img src="/images/img_concurrent_hashmap.png" alt="img_concurrent_hashmap"></p>
<p>（1）<strong>put方法</strong> 原理：<br>1）先对key值进行hash操作计算hashCode， 再通过<br>hashCode进一步计算 Segment 的索引，找到该 Segment 并调用相应的 put 方法；<br>2）调用 tryLock() 进行加锁；<br>4）判断是否碰撞…<br>5）判断Key是否存在…<br>6）判断是否需要扩容…</p>
<p>（2）<strong>get方法</strong> 原理：<br>　　同 HashMap 的原理相同。<br>注：get 方法是不加锁的。它将所有需要使用的变量使用 volatile 关键字进行修饰，保证了线程之间的可见性。</p>
<h4 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h4><p>　　JDK 1.8 的实现已经抛弃了 Segment 分段锁机制， 利用　<strong>CAS+Synchronized</strong>　来保证并发更新的安全， 底层依然采用 数组+链表+红黑树 的存储结构。<br>　　CAS：CompareAndSwap：比较和替换</p>
<p>（1）<strong>put方法</strong> 原理：<br>1）先对key值进行hash操作计算hashCode， 再通过<br>hashCode进一步计算 Segment 的索引；<br>4）判断是否碰撞。注意插入值时是采用CAS的方式。<br>5）判断Key是否存在…<br>6）判断是否需要扩容…</p>
<p><strong>补充：CAS原理：</strong><br>a. 3个操作数：</p>
<ul>
<li>内存地址 V</li>
<li>旧的预期值 A</li>
<li>即将要更新的目标值 B</li>
</ul>
<p>b. CAS执行命令时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则继续进行CAS自旋（无限循环）。</p>
<p>c. 缺点：</p>
<ul>
<li>循环时间长，开销很大</li>
<li>不能保证代码块的原子性，所保证的只是一个变量的原子性操作</li>
<li>ABA问题<br>什么是ABA问题?<br>在CAS操作中将判断“V的值是否仍然为A？”，并且如果是的话就继续执行更新操作，在某些算法中，如果V的值首先由A变为B，再由B变为A，那么CAS将会操作成功。<br>怎么避免ABA问题？<br>Java中提供了AtomicStampedReference和AtomicMarkableReference来解决ABA问题。</li>
</ul>
<p>（2）<strong>get方法</strong> 原理：<br>　　同 HashMap 的原理相同。</p>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android新特性</title>
    <url>/2020/02/29/Android%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="一、Android-5-0-新特性"><a href="#一、Android-5-0-新特性" class="headerlink" title="一、Android 5.0 新特性"></a>一、Android 5.0 新特性</h2><ol>
<li>全新的 Material Design 设计风格</li>
<li>引入 RecyclerView 代替 ListView</li>
<li>增加不重要通知隐藏功能</li>
<li>ART 虚拟机代替了 Dalvik 虚拟机</li>
<li>多任务视图</li>
</ol>
<a id="more"></a>

<h2 id="二、Android-6-0-新特性"><a href="#二、Android-6-0-新特性" class="headerlink" title="二、Android 6.0 新特性"></a>二、Android 6.0 新特性</h2><ol>
<li>运行时权限</li>
<li>集成了Android Pay</li>
<li>指纹支持</li>
<li>Doze 电量管理</li>
</ol>
<h2 id="三、Android-7-0-新特性"><a href="#三、Android-7-0-新特性" class="headerlink" title="三、Android 7.0 新特性"></a>三、Android 7.0 新特性</h2><ol>
<li>多窗口模式</li>
<li>Data Saver（流量保护机制）</li>
<li>支持Java 8</li>
<li>通知栏快速回复</li>
<li>通知栏快捷开关</li>
</ol>
<h2 id="四、Android-8-0-新特性"><a href="#四、Android-8-0-新特性" class="headerlink" title="四、Android 8.0 新特性"></a>四、Android 8.0 新特性</h2><ol>
<li>Notification Channel（通知渠道）</li>
<li>PIP（画中画模式）</li>
<li>自适应图标</li>
<li>长按图标弹出子菜单</li>
<li>权限新增安装权限</li>
<li>电量优化（大部分静态注册广播失效）</li>
</ol>
<h2 id="五、Android-9-0-新特性"><a href="#五、Android-9-0-新特性" class="headerlink" title="五、Android 9.0 新特性"></a>五、Android 9.0 新特性</h2><ol>
<li>全面屏支持</li>
<li>多摄像头支持</li>
<li>手势操作</li>
<li>增加黑夜模式</li>
<li>设置应用程序时间限制</li>
<li>基于人工智能的电量自适应和亮度自适应</li>
</ol>
<h2 id="六、Android-10-0-新特性"><a href="#六、Android-10-0-新特性" class="headerlink" title="六、Android 10.0 新特性"></a>六、Android 10.0 新特性</h2><ol>
<li>可折叠的应用程序</li>
<li>5G 网络</li>
<li>基于人工智能的回复操作</li>
<li>可适用于系统和应用的暗黑主题</li>
<li>类似于PC的桌面模式</li>
<li>面部识别</li>
</ol>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android内存泄漏</title>
    <url>/2020/02/29/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h2 id="一、ANR"><a href="#一、ANR" class="headerlink" title="一、ANR"></a>一、ANR</h2><h3 id="1-什么是ANR？"><a href="#1-什么是ANR？" class="headerlink" title="1. 什么是ANR？"></a>1. 什么是ANR？</h3><p>　　<strong>ANR</strong> 即Application Not Responding，它是一个提示“应用程序无响应”的对话框。</p>
<a id="more"></a>

<h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2. 原因"></a>2. 原因</h3><p>　　当应用程序的<strong>UI线程响应超时</strong>才会引起ANR，超时产生原因一般有两种：</p>
<ul>
<li>当前的事件没有机会得到处理（例如UI线程正在响应另外一个事件），当前事件由于某种原因被阻塞了。</li>
<li>当前的事件正在处理，但是由于耗时太长没能及时完成。</li>
</ul>
<p>　　从本质上讲，<strong>产生ANR的原因有三种</strong>，大致可以对应到Android 中四大组件中的三个（Activity/View，BroadcastReceiver和Service）。</p>
<ul>
<li>KeyDispatchTimeOut ：最常见的一种类型，原因是View的按键事件或者触摸事件在特定的时间（5秒）内无法得到响应。</li>
<li>BroadcaseTimeOut：原因是BroadcastReceiver的onReceiver()函数运行在主线程中，在特定的时间（10秒）内无法完成处理。</li>
<li>ServiceTimeOut：比较少出现的一种类型，原因是Service的各个生命周期函数在特定时间（20秒）内无法完成处理。</li>
</ul>
<p>　　<strong>根本原因</strong> 在主线程(UI线程)里面做了太多的耗时操作, 例如文件读写、数据库读写等。<br><strong>注意：</strong><br>　　Android 4.0 之后网络IO不允许在主线程中。</p>
<h4 id="补充：Android中哪些操作是在主线程中？"><a href="#补充：Android中哪些操作是在主线程中？" class="headerlink" title="补充：Android中哪些操作是在主线程中？"></a>补充：Android中哪些操作是在主线程中？</h4><ul>
<li>Activity的所有生命周期回调都是执行在主线程中</li>
<li>Service默认是执行在<strong>主线程</strong>中</li>
<li>BroadcastReceiver的onReceiver()回调执行在主线程中</li>
<li>没有使用子线程的Looper的Handler，它的handleMessage和post(Runnable)是执行在主线程中</li>
<li>AsyncTask的回调中除了doInBackground，其他的都是执行在主线程中</li>
<li>View的post(Runnable)是执行在主线程中</li>
</ul>
<h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><p>　　<strong>原则：</strong> 将耗时操作放在子线程中，主线程只做UI相关的操作。</p>
<ul>
<li>使用Handler机制，进行线程调度</li>
<li>使用Thread或者HandlerThread，开启子线程处理耗时操作</li>
<li>使用AsyncTask，处理异步任务</li>
<li>尽量避免在Activity的生命周期回调中做耗时操作</li>
</ul>
<h3 id="4-ANR的定位和分析"><a href="#4-ANR的定位和分析" class="headerlink" title="4. ANR的定位和分析"></a>4. ANR的定位和分析</h3><p>　　当发生ANR时，开发者可以通过结合<strong>Logcat日志</strong>和生成的位于手机内部存储的/data/anr/ <strong>traces.txt文件</strong>进行分析和定位。</p>
<p><strong>Logcat日志：</strong><br>从Logcat日志中，可以得到的信息主要有：<br>（1）导致ANR的类命及所在包名：MainActivity, com.asce1885.anrdemo<br>（2）发生ANR的进程名称及ID: com.asce1885.anrdemo,8672<br>（3）ANR产生的原因（类型）：Input disptching time out ，属于KeyDispatchTimeOut类型</p>
<p><strong>traces文件：</strong><br>　　从Logcat的日志信息我们可以知道引发ANR的具体的类信息以及ANR的类型，但是这不足够开发者定位到具体引发问题的代码行，为了获得进一步的信息，我们需要借助于ANR过程中生成的堆栈信息文件traces文件。<br>　　当app出现ANR会在data/anr/目录下生成traces.txt日志文件。每次发生ANR时都会删除旧的traces文件，重新创建新文件。也就是说Android只保留最后一次发生ANR时的信息。</p>
<p>　　一般trace文件顶部的线程即为ANR的元凶，进而分析ANR方法线程堆栈信息，重点关注主线程。最终定位出具体类的某个方法所导致的问题。</p>
<h2 id="二、OOM"><a href="#二、OOM" class="headerlink" title="二、OOM"></a>二、OOM</h2><h3 id="1-什么是OOM？"><a href="#1-什么是OOM？" class="headerlink" title="1. 什么是OOM？"></a>1. 什么是OOM？</h3><p>　　当前占用的内存加上我们申请的内存资源在超过了Dalvik虚拟机的最大内存限制，就会抛出 Out of Memory 的异常。<br>　　大部分的OOM异常都是大图加载所造成的。</p>
<h3 id="2-容易混淆的概念"><a href="#2-容易混淆的概念" class="headerlink" title="2. 容易混淆的概念"></a>2. 容易混淆的概念</h3><ul>
<li>内存溢出：即OOM</li>
<li>内存泄漏：内存泄漏积累到一定程度就会导致OOM。</li>
<li>内存抖动：短时间内大量的对象被创建，然后又被马上释放，瞬间产生的对象会严重占用内存区域。当达到阈值时触发GC，这样刚刚创建的对象就马上被回收。这些对象叠加在一起造成堆内存的压力，触发更多的GC。</li>
</ul>
<p>严重程度：内存溢出 &gt; 内存泄漏 &gt; 内存抖动</p>
<h3 id="3-解决方法-1"><a href="#3-解决方法-1" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><p>（1）有关Bitmap</p>
<ul>
<li>图片显示：加载合适的图片，例如加载缩略图的时候，我们不要进行网络请求加载大图。</li>
<li>及时释放内存：Bitmap的内存包含Java和Native两部分，其中Java的内存会被Java GC自动回收。可以在onDestory中手动去调用bitmap.recycle()进行内存释放。</li>
<li>图片压缩：设置inSampleSize（缩放比例）</li>
<li>使用inBitmap属性：复用内存区域</li>
<li>捕获异常：Error</li>
</ul>
<p>（2）其他</p>
<ul>
<li>ListView：<br>a: 使用convertView进行复用<br>b: 加载大图使用LRU机制进行缓存</li>
<li>自定义View：避免在onDraw方法里面执行对象的创建</li>
</ul>
<h2 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h2><h3 id="（一）Java的内存泄漏"><a href="#（一）Java的内存泄漏" class="headerlink" title="（一）Java的内存泄漏"></a>（一）Java的内存泄漏</h3><p>　　指的是无用的对象（不再使用的对象）持续占用内存而得不到 GC 回收，从而造成内存空间的浪费。</p>
<h4 id="1-Java-内存分配策略"><a href="#1-Java-内存分配策略" class="headerlink" title="1. Java 内存分配策略"></a>1. Java 内存分配策略</h4><p>　　Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配。 对应的， 三种存储策略使用的内存空间主要分别是： 静态存储区（也称方法区）、栈区和堆区。<br><strong>静态存储区（方法区）</strong> ： 主要存放静态数据、 全局 static 数据和常量。 这块内存在程序编译时就已经分配好， 并且在程序整个运行期间都存在。<br><strong>栈区</strong> ： 当方法被执行时， 方法体内的局部变量都在栈上创建， 并在方法执行结束时这些局部变量所持有的内存将会自动被释放。 因为栈内存分配运算内置于处理器的指令集中， 效率很高， 但是分配的内存容量有限。<br><strong>堆区</strong> ： 又称动态内存分配， 通常就是指在程序运行时直接 new 出来的内存。 这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</p>
<h4 id="2-什么样的对象会被GC？"><a href="#2-什么样的对象会被GC？" class="headerlink" title="2. 什么样的对象会被GC？"></a>2. 什么样的对象会被GC？</h4><p>　　可达性分析算法：如果一个对象到GCRoots没有任何引用链相连， 那么就认为这个对象不再被引用， 可以被 GC 回收。</p>
<h3 id="（二）Android的内存泄漏"><a href="#（二）Android的内存泄漏" class="headerlink" title="（二）Android的内存泄漏"></a>（二）Android的内存泄漏</h3><p>　　简单来说，就是该被释放的对象一直被某个或某些实例所持有却不再被使用导致内存得不到释放。 <strong>内存管理的目的</strong> 就是在开发中怎么有效的避免应用出现内存泄漏的问题。</p>
<h4 id="1-造成内存泄漏的情况"><a href="#1-造成内存泄漏的情况" class="headerlink" title="1. 造成内存泄漏的情况"></a>1. 造成内存泄漏的情况</h4><p>（1）单例<br>　　原因：由于单例的静态特性使得它和App的生命周期一样长，上下文如果是一个Activity的Context，那么它将一直持有Activity的引用，导致Activity无法被回收<br>　　解决方法：使用ApplicationContext<br>　　<br>（2）非静态内部类/匿名内部类<br>　　原因：默认持有外部类的引用，从而导致外部类（如：Activity）无法被回收<br>　　解决方法：改为静态内部类</p>
<p>（3）Handler<br>　　原因：由于Handler属于TLS(Thread Local Storage)变量，生命周期和Activity是不一致的； 万一Handler发送的Message尚未被处理， 则该Message及发送它的Handler对象将被线程MessageQueue一直持有。<br>　　解决方法：将Handler改写为静态内部类，同时在内部持有外部类的弱引用</p>
<p>（4）AsyncTask<br>　　原因：同非静态内部类<br>　　解决方法：可以在onDestory中调用asyncTask.cancle(boolean)</p>
<p>（5）static变量<br>　　原因：将变量声明为static时，将导致它的声明周期和整个App一样长，这部分的内存将不会被回收。<br>　　解决方法：考虑懒加载，尽量避免使用static变量；如果一定要使用，记得管理生命周期（onDestory中设为null）</p>
<p>（6）资源未关闭<br>　　如：Broadcast Receiver、Stream、Observer、Socket、Bitmap等<br>　　当Activity销毁前，记得注销这些资源，否则这些资源有可能无法回收，进而导致内存泄漏</p>
<h4 id="2-内存泄漏的定位和分析"><a href="#2-内存泄漏的定位和分析" class="headerlink" title="2. 内存泄漏的定位和分析"></a>2. 内存泄漏的定位和分析</h4><h5 id="（1）adb命令验证是否存在内存泄漏"><a href="#（1）adb命令验证是否存在内存泄漏" class="headerlink" title="（1）adb命令验证是否存在内存泄漏"></a>（1）adb命令验证是否存在内存泄漏</h5><p>1）打开要测试的apk，然后返回退出到主界面<br>2）AS的Terminal中输入命令：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="bash"> dumpsys meminfo 包名 -d</span></span><br></pre></td></tr></table></figure>
<p>　　然后便可以看到内存的一些情况<br>拉到下面可以看到：<br><img src="/images/img_memory_1.jpg" alt="img_memory_1"><br>　　退出APK之后，对象本应该都被回收，然而这里可以看到，还有View以及Activity占用着内存，由此可以知道内存泄漏了。</p>
<h5 id="（2）Android-Profiler（性能分析器）定位内存泄漏"><a href="#（2）Android-Profiler（性能分析器）定位内存泄漏" class="headerlink" title="（2）Android Profiler（性能分析器）定位内存泄漏"></a>（2）Android Profiler（性能分析器）定位内存泄漏</h5><p>1）进入内存分析界面<br>2）打开apk，然后返回键退出，然后点击上图中垃圾桶形状的图标进行垃圾回收，多点几次，直到内存没有什么变化<br>3）获取内存快照<br>4）查看Head Dump<br><img src="/images/img_memory_2.jpg" alt="img_memory_2"></p>
<ul>
<li>Shallow Heap（浅堆） 表示该对象自身占用的堆内存，不包括它引用的对象。</li>
<li>Retained Heap（深堆） 表示当前对象大小 + 当前对象可直接或间接引用到的对象的大小总和。<br>换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。</li>
</ul>
<p>　　从而分析出了内存泄漏的具体类</p>
<h5 id="（3）MAT-定位内存泄漏"><a href="#（3）MAT-定位内存泄漏" class="headerlink" title="（3）MAT 定位内存泄漏"></a>（3）MAT 定位内存泄漏</h5><p>1）进行格式转化</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">hprof-conv -z <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>hprof <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>hprof</span><br></pre></td></tr></table></figure>
<p>2）Open Heap Dump 打开刚刚保存的内存快照，并点击点击 Histogram<br>3）可以看到引起内存泄漏的类，Objects那一列不为0，则是说明发生了内存泄漏<br>4）过滤掉虚引用，软引用，弱引用，之后可以看到引用路径即为发生内存泄漏的具体位置<br><img src="/images/img_memory_3.jpg" alt="img_memory_3"></p>
<p><img src="/images/img_memory_4.jpg" alt="img_memory_4"></p>
<h5 id="（4）LeakCanary-检测内存泄漏"><a href="#（4）LeakCanary-检测内存泄漏" class="headerlink" title="（4）LeakCanary 检测内存泄漏"></a>（4）LeakCanary 检测内存泄漏</h5><p>LeakCanary 是一个用于检测内存泄露的开源类库。<br>1）在代码中引入LeakCanary<br>2）启动app，当检测到内存泄漏的时候，会出现一个弹窗，然后手机桌面会出现一个Leaks的图标<br>3）点击即可看到内存泄漏的原因<br><img src="/images/img_memory_5.jpg" alt="img_memory_5"></p>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化</title>
    <url>/2020/02/29/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="一、布局优化"><a href="#一、布局优化" class="headerlink" title="一、布局优化"></a>一、布局优化</h2><p>① 删除布局中无用的控件和层次， 其次有选择地使用性能比较低的ViewGroup</p>
<a id="more"></a>

<p>　　例如： 如果布局中既可以使用LinearLayout也可以使用RelativeLayout， 那么就采用LinearLayout， 这是因为RelativeLayout的功能比较复杂， 它的布局过程需要花费更<br>多的CPU时间。<br>② 采用&lt;include&gt; 标签、&lt;merge&gt; 标签和ViewStub</p>
<ul>
<li>&lt;include&gt; 标签：布局重用</li>
<li>&lt;merge&gt; 标签：减少布局层级</li>
<li>ViewStub：按需加载</li>
</ul>
<p>③ 避免多度绘制</p>
<h2 id="二、绘制优化"><a href="#二、绘制优化" class="headerlink" title="二、绘制优化"></a>二、绘制优化</h2><p>① onDraw中不要创建新的局部对象<br>② onDraw方法中不要做耗时的任务</p>
<h2 id="三、内存泄漏优化"><a href="#三、内存泄漏优化" class="headerlink" title="三、内存泄漏优化"></a>三、内存泄漏优化</h2><p>① 在开发过程中避免写出有内存泄漏的代码<br>② 通过一些分析工具比如MAT来找出潜在的内存泄露</p>
<h2 id="四、响应速度优化"><a href="#四、响应速度优化" class="headerlink" title="四、响应速度优化"></a>四、响应速度优化</h2><p>核心思想：避免在主线程中做耗时操作</p>
<h2 id="五、ListView-RecycleView及Bitmap优化"><a href="#五、ListView-RecycleView及Bitmap优化" class="headerlink" title="五、ListView/RecycleView及Bitmap优化"></a>五、ListView/RecycleView及Bitmap优化</h2><h4 id="ListView-RecycleView："><a href="#ListView-RecycleView：" class="headerlink" title="ListView/RecycleView："></a>ListView/RecycleView：</h4><p>① 使用ViewHolder模式来提高效率<br>② 异步加载： 耗时的操作放在异步线程中<br>③ ListView/RecycleView的滑动时停止加载和分页加载</p>
<h4 id="Bitmap："><a href="#Bitmap：" class="headerlink" title="Bitmap："></a>Bitmap：</h4><p>　　主要是对加载图片进行压缩，避免加载图片多大导致OOM出现。</p>
<h2 id="六、线程优化"><a href="#六、线程优化" class="headerlink" title="六、线程优化"></a>六、线程优化</h2><p>　　尽量采用线程池，而不是每次都要创建一个Thread对象</p>
<h2 id="七、其他性能优化的建议"><a href="#七、其他性能优化的建议" class="headerlink" title="七、其他性能优化的建议"></a>七、其他性能优化的建议</h2><p>①　避免过度的创建对象<br>②　不要过度使用枚举， 枚举占用的内存空间要比整型大<br>③　常量请使用static final来修饰<br>④　使用一些Android特有的数据结构， 比如SparseArray和Pair等<br>⑤　适当采用软引用和弱引用<br>⑥　采用内存缓存和磁盘缓存<br>⑦　尽量采用静态内部类</p>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>专业基础知识之操作系统</title>
    <url>/2020/02/28/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="1-进程与线程的区别"><a href="#1-进程与线程的区别" class="headerlink" title="1. 进程与线程的区别"></a>1. 进程与线程的区别</h3><p><strong>进程</strong>： 是系统进行资源分配和调度的一个独立单位。 引入进程是为了使多个程序可以并发的执行， 以提高系统的资源利用率和吞吐量。<br><strong>线程</strong>： 是比进程更小的可独立运行的基本单位， 可以看做是轻量级的进程。 引入目的是为了减少程序在并发执行过程中的开销。</p>
<a id="more"></a>

<p>两者区别：</p>
<ul>
<li>开销：进程之间的切换会产生更大的开销</li>
<li>内存分配：系统在运行时会为每个进程分配不同的内存空间；而系统不会为线程分配内存，线程所使用的的资源来自其所属进程的资源，线程之间只能共享资源</li>
<li>包含关系：一个进程可以有多个线程</li>
</ul>
<h3 id="2-进程的状态转换"><a href="#2-进程的状态转换" class="headerlink" title="2. 进程的状态转换"></a>2. 进程的状态转换</h3><p><img src="/images/img_process_state_change.png" alt="img_process_state_change"><br>就绪状态 -&gt; 运行状态： 处于就绪状态的进程被调度后， 获得处理机资源（分派处理机时间片） ， 于是进程由就绪状态转换为运行状态。<br>运行状态 -&gt; 就绪状态： 处于运行状态的进程在时间片用完后， 不得不让出处理机， 从而进程由运行状态转换为就绪状态。 此外， 在可剥夺的操作系统中， 当有更高优先级的进程就绪时， 调度程度将正执行的进程转换为就绪状态， 让更高优先级的进程执行。<br>运行状态 -&gt; 阻塞状态： 当进程请求某一资源（如外设） 的使用和分配或等待某一事件的发生（如I/O操作的完成） 时， 它就从运行状态转换为阻塞状态。<br>阻塞状态 -&gt; 就绪状态： 当进程等待的事件到来时， 如I/O操作结束或中断结束时， 中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。</p>
<h3 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h3><p>　　死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p>
<h4 id="（1）死锁产生的必要条件"><a href="#（1）死锁产生的必要条件" class="headerlink" title="（1）死锁产生的必要条件"></a>（1）死锁产生的必要条件</h4><ul>
<li><strong>互斥条件</strong>：进程对所分配的资源进行排他性的使用</li>
<li><strong>请求和保持条件</strong>：进程被阻塞的时候并不释放锁申请到的资源</li>
<li><strong>不可剥夺条件</strong>：进程对于已经申请到的资源在使用完成之前不可以被剥夺</li>
<li><strong>环路等待条件</strong>：发生死锁的时候存在的一个 进程-资源 环形等待链</li>
</ul>
<h4 id="（2）死锁产生的原因"><a href="#（2）死锁产生的原因" class="headerlink" title="（2）死锁产生的原因"></a>（2）死锁产生的原因</h4><p>1） 竞争资源： 请求同一有限资源的进程数多于可用资源数<br>2） 进程推进顺序非法： 进程执行中， 请求和释放资源顺序不合理， 如资源等待链</p>
]]></content>
      <categories>
        <category>专业基础知识</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>专业基础知识之计算机网络</title>
    <url>/2020/02/28/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h3 id="1-网络分层体系结构"><a href="#1-网络分层体系结构" class="headerlink" title="1. 网络分层体系结构"></a>1. 网络分层体系结构</h3><p><img src="/images/img_web.jpg" alt="img_web"></p>
<a id="more"></a>

<ul>
<li>应用层：提供用户与网络交互的接口，定义了应用程序间通信和交互的规则。—— HTTP、FTP、POP、SMTP</li>
<li>运输层：负责不同主机进程之间的数据传输。—— TCP、UDP</li>
<li>网络层：负责不同主机之间的数据传输。—— IP</li>
<li>数据链路层：负责相邻结点之间的数据传输。—— PPP</li>
<li>物理层：在物理介质上的传输。</li>
</ul>
<p><strong>PDU（协议数据单元）：</strong></p>
<ul>
<li>应用层：各应用报文</li>
<li>运输层：TCP/UDP数据段</li>
<li>网络层：IP数据包</li>
<li>数据链路层：帧</li>
<li>物理层：比特</li>
</ul>
<h3 id="2-GET-和-POST-两种请求方式的区别"><a href="#2-GET-和-POST-两种请求方式的区别" class="headerlink" title="2. GET 和 POST 两种请求方式的区别"></a>2. GET 和 POST 两种请求方式的区别</h3><p>（1）URL可见性</p>
<ul>
<li>get：URL参数可见</li>
<li>post：URL参数不可见</li>
</ul>
<p>（2）数据传输</p>
<ul>
<li>get：通过拼接URL进行传递参数</li>
<li>post：通过Body体传递参数</li>
</ul>
<p>（3）缓存性</p>
<ul>
<li>get：可缓存</li>
<li>post：不可缓存</li>
</ul>
<p>（4）后退页面的反应</p>
<ul>
<li>get：页面后退后，不产生影响</li>
<li>post：页面后退后，会重新提交请求</li>
</ul>
<p>（5）传输数据的大小</p>
<ul>
<li>get：有限制（一般不超过2k-4k）</li>
<li>post：没有限制</li>
</ul>
<p>（6）安全性</p>
<ul>
<li>get：不安全（URL参数可见）</li>
<li>post：安全</li>
</ul>
<h3 id="3-TCP-和-UDP-的区别"><a href="#3-TCP-和-UDP-的区别" class="headerlink" title="3. TCP 和 UDP 的区别"></a>3. TCP 和 UDP 的区别</h3><p>主要区别：<br><strong>TCP：</strong><br>1）<strong>面向连接的</strong>，连接的建立需要三次握手，；连接的释放需要四次挥手<br>2）<strong>面向字节流</strong>，会把上层传输下来的数据当作是无结构的字节流<br>3）<strong>一对一通信</strong><br>4）<strong>能够保证可靠传输</strong>，具有超时重传机制，并有数据校验<br><strong>UDP：</strong><br>1）<strong>无连接的</strong>，一方向另一方发送数据不需要建立连接<br>2）<strong>面向报文</strong>，从上层接受的数据如果报文不大于传输限制，则直接加上首部；如果过大，则进行IP分片后，再加上首部进行传输<br>3）<strong>可以一对一通信，也可以一对多通信</strong><br>4）<strong>不保证可靠传输</strong>，仅仅是尽最大努力交付</p>
<p>详细区别：<br><img src="/images/img_tcp_udp.jpg" alt="img_tcp_udp"></p>
<p><strong>什么时候应该使用TCP？</strong><br>当对网络通讯质量有要求的时候， 比如： 整个数据要准确无误的传递给对方， 这往往用于一些要求可靠的应用， 比如HTTP、 HTTPS、 FTP等传输文件的协议， POP、 SMTP等邮件传输的协议。</p>
<p><strong>什么时候应该使用UDP？</strong><br>当对网络通讯质量要求不高的时候， 要求网络通讯速度能尽量的快， 这时就可以使用UDP。比如DNS域名系统。</p>
<h3 id="4-TCP连接的建立与终止"><a href="#4-TCP连接的建立与终止" class="headerlink" title="4. TCP连接的建立与终止"></a>4. TCP连接的建立与终止</h3><p><img src="/images/img_tcp.png" alt="img_tcp"></p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>• 第一次握手： 建立连接。 客户端发送连接请求报文段， 将 SYN 设置为 1、 Sequence Number（seq）为 x； 接下来客户端进入 SYN_SENT 状态， 等待服务端的确认。<br>• 第二次握手： 服务器收到客户端的 SYN 报文段， 对 SYN 报文段进行确认， 设置 Acknowledgment Number（ACK） 为 x+1（seq+1） ； 同时自己还要发送 SYN 请求信息， 将 SYN 设置为1、 seq 为 y。 服务端将上述所有信息放到 SYN+ACK 报文段中， 一并发送给客户端， 此时服务端进入 SYN_RCVD 状态。<br>• 第三次握手： 客户端收到服务端的 SYN+ACK 报文段； 然后将 ACK 设置为 y+1， 向服务端发送 ACK 报文段， 这个报文段发送完毕后， 客户端和服务端都进入 ESTABLISHED （TCP连接成功） 状态。</p>
<p><strong>为什么要三次握手？</strong><br>　　为了防止已失效的连接请求报文段突然又传送到了服务端， 因而产生错误。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>• 第一次挥手： 客户端设置 seq 和 ACK， 向服务端发送一个 FIN 报文段。 此时， 客户端进入 FIN_WAIT_1 状态， 表示客户端没有数据要发送给服务端了。<br>• 第二次挥手： 服务端收到了客户端发送的 FIN 报文段， 向客户端回了一个 ACK 报文段。<br>• 第三次挥手： 服务端向客户端发送 FIN 报文段， 请求关闭连接， 同时服务端进入 LAST_ACK 状态。<br>• 第四次挥手： 客户端收到服务端发送的 FIN 报文段， 向服务端发送 ACK 报文段， 然后客户端进入 TIME_WAIT 状态。 服务端收到客户端的 ACK 报文段以后， 就关闭连接。 此时， 客户端等待 2MSL（最大报文段生存时间） 后依然没有收到回复， 则说明服务端已正常关闭， 这样客户端也可以关闭连接了。</p>
<p><strong>为什么要四次挥手？</strong><br>　　为了保证在最后断开的时候，客户端能够发送最后一个ACK报文段能够被服务器接收到，从而避免在下一个连接中出现上一个连接的滞留的报文。</p>
<h3 id="5-状态码"><a href="#5-状态码" class="headerlink" title="5. 状态码"></a>5. 状态码</h3><p>　　状态码由3位数字组成， 第一个数字定义了响应的类别， 且有以下5种可能取值。<br>• 1xx： 指示信息， 收到请求， 需要请求者继续执行操作。<br>• 2xx： 请求成功， 请求已被成功接收并处理。<br>• 3xx： 重定向， 要完成请求必须进行更进一步的操作。<br>• 4xx： 客户端错误， 请求有语法错误或请求无法实现。<br>• 5xx： 服务器错误， 服务器不能实现合法的请求。<br>常见的状态码如下：<br>• 200 OK： 客户端请求成功。<br>• 400 Bad Request： 客户端请求有语法错误， 服务器无法理解。<br>• 401 Unauthorized： 客户端请求未经授权， 这个状态码必须和WWW-Authenticate报头域一起使用。<br>• 403 Forbidden： 客户端请求被服务端拒绝。<br>• 404 Not Found： 客户端请求地址错误， 资源未找到<br>• 500 Internal Server Error： 服务器内部错误， 无法完成请求。<br>• 503 Server Unavailable： 服务器当前不能处理客户端的请求， 一段时间后可能恢复正常。</p>
]]></content>
      <categories>
        <category>专业基础知识</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识汇总</title>
    <url>/2020/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="1-Java基本数据类型的字节数"><a href="#1-Java基本数据类型的字节数" class="headerlink" title="1. Java基本数据类型的字节数"></a>1. Java基本数据类型的字节数</h3><table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">字节数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
</tr>
</tbody></table>
<p>注：long double：8</p>
<a id="more"></a>

<h3 id="2-基本数据类型和引用类型的区别"><a href="#2-基本数据类型和引用类型的区别" class="headerlink" title="2. 基本数据类型和引用类型的区别"></a>2. 基本数据类型和引用类型的区别</h3><p><strong>基本类型变量：</strong></p>
<ul>
<li>在内存中存储的是一个基本类型 值</li>
<li>可以在栈中直接分配内存</li>
<li>将一个变量的实际值赋给另一个变量：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = <span class="number">2</span>;</span><br><span class="line">j = i;  <span class="comment">//就是将基本类型变量 j 的内容复制给基本类型变量 i</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>引用类型变量：</strong></p>
<ul>
<li>在内存中存储的是一个引用，它指向对象的存储地址</li>
<li>对象的引用在栈中，对象实际存放在堆中</li>
<li>将一个变量的引用赋给另一个变量：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">c1 = <span class="keyword">new</span> Circle(<span class="number">9</span>);</span><br><span class="line">c2 = <span class="keyword">new</span> Circle(<span class="number">6</span>);</span><br><span class="line">c2 = c1;  <span class="comment">//就是将c2的引用赋给c1，赋值之后，变量c2和c1指向同一个对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个时候c1以前的引用对象不再有用，因此，现在它就称为垃圾。垃圾会占用内存空间。</span></span><br><span class="line"><span class="comment">Java运行系统会检测垃圾并自动回收它所占据的空间，这个过程称为垃圾回收。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：</strong> 如果你不再需要某个对象，可以显式地给该对象的引用变量赋值为null。 如果该对象没有被任何引用变量所引用，Java虚拟机会自动回收它所占据的空间。</p>
<h3 id="3-equals-和-的区别"><a href="#3-equals-和-的区别" class="headerlink" title="3. equals 和 == 的区别"></a>3. equals 和 == 的区别</h3><p><strong>==</strong><br>　　既可以比较基本数据类型类型的变量，又可以比较引用类型的变量。</p>
<ul>
<li>如果作用于基本的数据类型变量，则直接比较 <strong>值</strong> 是否相等；</li>
<li>如果作用于引用类型的变量，则比较所指向的 <strong>对象的地址</strong> 是否相等。</li>
</ul>
<p><strong>equals</strong><br>　　只能比较引用类型的变量，而不能比较基本数据类型的变量。</p>
<ul>
<li>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的 <strong>对象的地址</strong> 是否相等；</li>
<li>如果对equals方法进行重写（如String、Date等），则比较所指向 <strong>对象的内容</strong> 是否相等。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>详解事件分发机制</title>
    <url>/2020/02/27/%E8%AF%A6%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>　　安卓上面的View是树形结构的，View可能会重叠在一起，当点击的地方有多个View可以响应的时候，这个点击事件应该给谁呢？为了解决这个问题，就有了<strong>事件分发机制</strong>。</p>
<a id="more"></a>

<h2 id="一、对象"><a href="#一、对象" class="headerlink" title="一、对象"></a>一、对象</h2><p>　　事件分发的<strong>三个主要对象</strong>：<strong>Activiy、ViewGroup、View</strong><br>　　事件分发的主要顺序： <strong>Activity(Window) -&gt; ViewGroup -&gt; View</strong><br>　　Android的UI界面是由Activity、 ViewGroup、 View及其派生类所构成的。<br><img src="/images/img_view_2.jpg" alt="img_view_2"></p>
<p>　　Activity的构成如下：<br><img src="/images/img_view_1.png" alt="img_view_1"></p>
<ul>
<li>PhoneWindow：是抽象类Window的唯一实现类，抽象类Window是所有视图最顶层的容器，包括View视图的外观和行为都归Window管。</li>
<li>DecorView：PhoneWindow的内部类，DecorView将屏幕氛围2个部分：TitleView 和 ContentView，我们平常加载的布局就是ContentView。通过DecorView传递信息给下面的View，下面的View也通过DecorView返回消息给PhoneWindow。</li>
</ul>
<p>事件分发的具体顺序： <strong>PhoneWindow -&gt; DecorView -&gt; ViewGroup -&gt; View</strong></p>
<h2 id="二、重要方法"><a href="#二、重要方法" class="headerlink" title="二、重要方法"></a>二、重要方法</h2><ul>
<li><strong>dispatchTouchEvent：</strong> 进行事件的分发</li>
<li><strong>onInterceptTouchEvent：</strong> 进行事件的拦截， 在 dispatchTouchEvent 内部调用。</li>
<li><strong>onTouchEvent：</strong> 处理事件，在 dispatchTouchEvent 内部调用。</li>
</ul>
<h2 id="三、分发流程"><a href="#三、分发流程" class="headerlink" title="三、分发流程"></a>三、分发流程</h2><p><img src="/images/img_view_3.jpg" alt="img_view_3"></p>
<p><img src="/images/img_view_4.jpg" alt="img_view_4"></p>
<p>（1）当点击事件产生后首先会由Activity来处理，在内部先传递到PhoneWindow，再传递给DecorView。之后传递到顶层的ViewGroup。<br>（2）ViewGroup的dispatchTouchEvent方法会进行判断：</p>
<ul>
<li>如果onInterceptTouchEvent方法返回true，则该ViewGroup就拦截这个事件，并交给它的onTouchEvent方法处理；</li>
<li>如果onInterceptTouchEvent方法返回false，则该ViewGroup就不会拦截这个事件，因此，交给它的子元素(ViewGroup/View)的dispatchTouchEvent方法处理。如果子元素的onInterceptTouchEvent方法仍返回false，则继续向下传递……</li>
</ul>
<p>（3）如此反复，直到传递到底层的View。<br>（4）底层View的onTouchEvent方法：</p>
<ul>
<li>如果返回true，则事件由底层View消耗并处理。</li>
<li>如果返回false，则事件不做处理，传递到父元素(ViewGroup/View)的onTouchEvent处理。如果父元素的onTouchEvent方法仍返回false，则继续向上传递……</li>
</ul>
<p>（5）如此反复，直到传递到Activity。如果Activity的onTouchEvent方法仍返回false，则该事件将会被抛弃。</p>
<p>　　整个过程采用了<strong>责任链模式</strong>。</p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>详解消息机制</title>
    <url>/2020/02/27/%E8%AF%A6%E8%A7%A3%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>　　Android的<strong>消息机制</strong>也就是Handler机制。主要的作用是用来在不同线程之间的通信，通常使用在子线程执行完成一些耗时操作，需要回到主线程更新界面UI时，通过Handler将有关UI的操作切换到主线程。</p>
<a id="more"></a>

<h2 id="一、消息机制存在的意义"><a href="#一、消息机制存在的意义" class="headerlink" title="一、消息机制存在的意义"></a>一、消息机制存在的意义</h2><p><strong>为什么不能在非UI线程中操作UI控件？</strong><br>　　因为Android的UI控件（View）不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态。<br><strong>为什么不对UI控件加上锁机制？</strong><br>　　首先加上锁会让UI访问的逻辑变得复杂；其次锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。</p>
<h2 id="二、消息机制的工作原理"><a href="#二、消息机制的工作原理" class="headerlink" title="二、消息机制的工作原理"></a>二、消息机制的工作原理</h2><p>消息机制主要包含： <strong>MessageQueue</strong>、<strong>Handler</strong> 和<strong>Looper</strong>这三大部分，以及<strong>Message</strong>。</p>
<ul>
<li>Message： 需要传递的消息， 可以传递数据；</li>
<li>MessageQueue： 消息队列， 但是它的内部实现并不是用的队列， 实际上是通过一个<strong>单链表</strong>的数据结构来维护消息列表， 因为单链表在插入和删除上比较有优势。 主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next)；</li>
<li>Handler： 消息辅助类， 主要功能向消息池发送各种消息事件(Handler.sendMessage)和处理相应消息事件(Handler.handleMessage)；</li>
<li>Looper： 不断循环执行(Looper.loop)， 从MessageQueue中读取消息， 按分发机制将消息分发给目标处理者。<br><img src="/images/img_handler.jpg" alt="img_handler"><h4 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h4>（1）应用程序启动的时候，在主线程中会默认调用了 Looper.preper()方法，初始化Looper对象并绑定到当前线程中，并在Looper内部维护一个MessageQueue。<br>（2）接着调用handler.sendMessage()发送消息（handler.postRunnable()实际上底层也是调用了handler.sendMessage()，只不过进行了封装），会通过MessageQueue.enqueueMessage()向MessageQueue中添加一条消息。<br>（3）主线程调用Looper.looper()开启循环，不断轮询消息队列，通过MessageQueue.next()取出消息。<br>（4）取出的message不为空则调用msg.target.dispatchMessage()传递分发消息，目标handler收到消息后会执行handler.handlerMessage()方法处理消息。</li>
</ul>
<p><strong>MessageQueue、Handler 和 Looper 三者之间的关系：</strong></p>
<ul>
<li><strong>一个线程中只能存在一个Looper</strong>， Looper是保存在ThreadLocal中的。 主线程（UI线程）已经创建了一个Looper， 所以在主线程中不需要再创建Looper， 但是在其他线程中需要创建Looper。</li>
<li>每个线程中可以有多个Handler， 即<strong>一个Looper可以处理来自多个Handler的消息</strong>。</li>
<li><strong>一个Looper中维护一个MessageQueue</strong>， 来维护消息队列， 消息队列中的Message可以来自不同的Handler。</li>
</ul>
<h2 id="三、深入理解消息机制"><a href="#三、深入理解消息机制" class="headerlink" title="三、深入理解消息机制"></a>三、深入理解消息机制</h2><h4 id="1-为什么一个线程只有一个Looper？"><a href="#1-为什么一个线程只有一个Looper？" class="headerlink" title="1. 为什么一个线程只有一个Looper？"></a>1. 为什么一个线程只有一个Looper？</h4><p>　　因为线程对应的Looper是在<strong>ThreadLocal</strong>里面存储，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其它线程来说无法获取到数据。另外，在Looper的创建方法Looper.prepare()中，会进行判断，如果当前线程已经存在Looper对象，就会报RunTimeException异常。<br><strong>补充：为什么ThreadLocal可以在多个线程中互不干扰的存储和修改数据？</strong> ThreadLocal所做的读写操作仅限于各自线程的内部</p>
<h4 id="2-为什么主线程中可以直接使用Handler，而不用创建Looper？"><a href="#2-为什么主线程中可以直接使用Handler，而不用创建Looper？" class="headerlink" title="2. 为什么主线程中可以直接使用Handler，而不用创建Looper？"></a>2. 为什么主线程中可以直接使用Handler，而不用创建Looper？</h4><p>　　<strong>UI线程(ActivityThread)被创建时默认初始化了Looper</strong>。因此在主线程中可以直接使用Handler。</p>
<h4 id="3-可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？"><a href="#3-可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？" class="headerlink" title="3. 可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？"></a>3. 可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？</h4><p>　　子线程中不可以直接使用Handler，子线程中默认是没有Looper的，同时MessageQueue又是Looper来维护的。因此如果在子线程中直接发送消息，是没有关联MessageQueue可以存储消息。因此会抛出异常。<br>　　如果想在子线程中使用Handler，必须通过Looper.prepare()去初始化一个Looper，并且再通过Looper.loop()开启循环。</p>
<h4 id="4-Looper-loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？"><a href="#4-Looper-loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？" class="headerlink" title="4. Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？"></a>4. Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？</h4><p>　　在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。（因此，looper.looper()阻塞不会消耗大量的CPU资源。）<br>　　epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。<br>　　所谓ANR便是Looper.loop没有得到及时处理，一旦没有消息，Linux的epoll机制则会通过管道写文件描述符的方式来对主线程进行唤醒与睡眠，Android里调用了linux层的代码实现在适当时会睡眠主线程。</p>
<p><strong>消息循环（死循环）的必要性：</strong><br>　　线程既然是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出。例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。<br>　　ActivityThread的main方法主要就是做消息循环，一旦退出消息循环，那么你的应用也就退出了。如果main方法中没有Looper进行循环，那么主线程一运行完毕就会退出。</p>
<h2 id="四、Handler引起的内存泄漏"><a href="#四、Handler引起的内存泄漏" class="headerlink" title="四、Handler引起的内存泄漏"></a>四、Handler引起的内存泄漏</h2><h3 id="1-原因："><a href="#1-原因：" class="headerlink" title="1. 原因："></a>1. 原因：</h3><p>　　<strong>非静态、匿名内部类会隐式持有外部类的引用，导致外部Activity无法回收。</strong></p>
<h3 id="2-解决方法："><a href="#2-解决方法：" class="headerlink" title="2. 解决方法："></a>2. 解决方法：</h3><p>（1）将Handler修改为静态内部类<br>（2）Handler内部持有外部Activity的弱引用<br>（3）在onDestory()中调用handler.removeCallbackAndMessages(null)</p>
<h2 id="五、AsyncTask"><a href="#五、AsyncTask" class="headerlink" title="五、AsyncTask"></a>五、AsyncTask</h2><h4 id="1-核心方法"><a href="#1-核心方法" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h4><ul>
<li>onPreExecute()</li>
<li>doInBackground(Params…params)</li>
<li>onProgressUpdate(Params…params)</li>
<li>onPostExecute(Result result)</li>
</ul>
<p><strong>注意：</strong><br>（1）只有onProgressUpdate在线程池中执行，可以执行耗时任务；其他方法都是在主线程中。<br>（2）AsyncTask的类必须在主线程中加载；对象必须在主线程中创建；execute方法必须在UI线程中调用。<br>（3）不要在程序中直接调用4个核心方法<br>（4）一个AsyncTask对象只能执行一次，只能调用一次execute方法。<br>（5）Android 1.6之前，AsyncTask是串行执行的。之后的版本加入了并行执行。可以通过executeOnExecutor并行执行任务，但不建议。</p>
<h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h4><p>　　AsyncTask内部封装了一个静态线程池，通过内部的InternalHandler在UI线程和子线程之间传递消息。</p>
<h4 id="3-使用不当的后果"><a href="#3-使用不当的后果" class="headerlink" title="3. 使用不当的后果"></a>3. 使用不当的后果</h4><p>1）生命周期<br>　　AsyncTask不与任何组件绑定生命周期， 所以在Activity/或者Fragment中创建执行AsyncTask时， 最好在Activity/Fragment的onDestory()调用cancel(boolean)。<br>2）内存泄漏<br>　　如果AsyncTask被声明为Activity的非静态的内部类， 那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用。 如果Activity已经被销毁， AsyncTask的后台线程还在执行， 它将继续在内存里保留这个引用， 导致Activity无法被回收， 引起内存泄露。<br>3）结果丢失<br>　　屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建， 之前运行的AsyncTask（非静态的内部类）会持有一个之前Activity的引用， 这个引用已经无效， 这时再去更新界面将不再生效。</p>
<h2 id="六、HandlerThread"><a href="#六、HandlerThread" class="headerlink" title="六、HandlerThread"></a>六、HandlerThread</h2><p>　　HandlerThread继承了Thread，同时它的内部创建了MessageQueue，可以进行Looper循环，是一个具有消息循环的线程。我们通过它可以直接使用Handler。</p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Binder机制</title>
    <url>/2020/02/27/%E8%AF%A6%E8%A7%A3Binder%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>　　<strong>Binder机制</strong> 是Android中的一种跨进程的通信机制。</p>
<a id="more"></a>

<h2 id="一、IPC原理"><a href="#一、IPC原理" class="headerlink" title="一、IPC原理"></a>一、IPC原理</h2><p>　　从进程角度来看IPC（Interprocess Communication）机制：<br>    <img src="/images/img_ipc.jpg" alt="img_ipc"><br>　　每个Android的进程， 只能运行在自己进程所拥有的虚拟地址空间（<strong>进程隔离</strong>）。 <strong>对于用户空间， 不同进程之间是不能共享的， 而内核空间却是可共享的。</strong> Client进程向Server进程通信， 恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的。 Client端与Server端进程往往采用ioctl（设备控制接口）等方法完成用户空间与内核空间的驱动进行交互。</p>
<h2 id="二、为什么要使用Binder？"><a href="#二、为什么要使用Binder？" class="headerlink" title="二、为什么要使用Binder？"></a>二、为什么要使用Binder？</h2><h3 id="1-性能方面"><a href="#1-性能方面" class="headerlink" title="1. 性能方面"></a>1. 性能方面</h3><p>　　在Android设备上（性能受限制，比如要省电）， 广泛地使用跨进程通信对通信机制的性能有严格的要求， Binder相对于传统的Socket方式， 更加高效。 Binder数据拷贝只需要一次， 而管道、 消息队列、 Socket都需要两次， 而共享内存方式虽然一次内存拷贝都不需要， 但实现方式又比较复杂。</p>
<h3 id="2-安全方面"><a href="#2-安全方面" class="headerlink" title="2. 安全方面"></a>2. 安全方面</h3><p>　　传统的进程通信方式对于通信双方的身份并没有做出严格的验证， 比如Socket通信的IP地址是客户端手动填入， 很容易进行伪造。 然而， Binder机制从协议本身就支持对通信双方做身份校检， 从而大大提升了安全性。</p>
<h2 id="三、Binder原理"><a href="#三、Binder原理" class="headerlink" title="三、Binder原理"></a>三、Binder原理</h2><p>　　Binder通信采用<strong>C/S架构</strong>， 从组件视角来说， 包含<strong>Client、 Server、 ServiceManager以及Binder驱动</strong>， 其中ServiceManager用于管理系统中的各种服务。<br>架构图如下所示：<br><img src="/images/img_binder.jpg" alt="img_binder"></p>
<h4 id="Binder通信的四个角色："><a href="#Binder通信的四个角色：" class="headerlink" title="Binder通信的四个角色："></a>Binder通信的四个角色：</h4><ul>
<li>Client进程： 使用服务的进程。</li>
<li>Server进程： 提供服务的进程。</li>
<li>ServiceManager进程： ServiceManager的作用是将字符形式的<strong>Binder名字转化成Client中对该Binder的引用</strong>， 使得Client能够通过Binder名字获得对Server中Binder实体的引用(代理对象)。</li>
<li>Binder驱动： 驱动负责进程之间Binder通信的建立。</li>
</ul>
<p><strong>注意：</strong><br>对于Service进程来说，Binder指的是Binder本地对象；<br>对于Client进程来说，Binder指的是Binder代理对象。</p>
<h4 id="Binder运行机制："><a href="#Binder运行机制：" class="headerlink" title="Binder运行机制："></a>Binder运行机制：</h4><p>（1）<strong>注册服务</strong>： Server进程要先注册Service到ServiceManager。 该过程： Server是客户端， ServiceManager是服务端。<br>（2）<strong>获取服务</strong>： Client进程使用某个Service前， 须先向ServiceManager中获取相应的Service。 该过程： Client是客户端， ServiceManager是服务端。<br>（3）<strong>使用服务</strong>： Client根据得到的Service信息建立与Service所在的Server进程通信的通路， 然后就可以直接与Service交互。 该过程： Client是客户端， Server是服务端。</p>
<h2 id="四、AIDL"><a href="#四、AIDL" class="headerlink" title="四、AIDL"></a>四、AIDL</h2><p>　　<strong>AIDL</strong> (Android Interface Definition Language) 是一种接口定义语言， 用于生成可以在Android设备上两个进程之间进行进程间通信(Interprocess Communication, IPC)的代码。 如果在一个进程中（ 例如Activity） 要调用另一个进程中（ 例如Service）对象的操作， 就可以使用AIDL生成可序列化的参数， 来完成进程间通信。<br>　　AIDL之所以能够实现进程间通信， 其内部是通过<strong>Binder机制</strong>来实现的。</p>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h4><p>服务端：</p>
<ul>
<li>创建JavaBean，并实现进行序列化</li>
<li>新建同名的AIDL文件，并在文件中声明JavaBean对象</li>
<li>新建AIDL接口文件，并且在其中定义方法</li>
<li>创建继承Service的自定义服务并重写onBind方法</li>
<li>声明Stub类型变量（Binder类型），并实现接口方法</li>
</ul>
<p>客户端：</p>
<ul>
<li>将服务端中AIDL文件夹移植到客户端</li>
<li>声明接口类型变量</li>
<li>声明ServiceConnection类型变量，并完成bindService</li>
<li>在serviceConnected方法中通过IBookManager.Stub.asInterface(service)获取接口对象</li>
</ul>
<p>　　这样就可以通过接口对象调用服务端接口中的定义的方法了。</p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android四大组件之ContentProvider</title>
    <url>/2020/02/27/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BContentProvider/</url>
    <content><![CDATA[<p>　　<strong>内容提供者（ContentProvider）</strong> 是用于在不同的应用程序之间实现数据共享的一种组件。它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。</p>
<a id="more"></a>

<h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>　　进程间进行数据的交互和共享，即跨进程通信（IPC）。<br><img src="/images/img_content_provider.jpg" alt="img_content_provider"></p>
<h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p>　　ContentProvider的底层通信是采用Android中的<strong>Binder机制</strong>。<br><img src="/images/img_content_provider_new.jpg" alt="img_content_provider_new"></p>
<h4 id="ContentProvider类"><a href="#ContentProvider类" class="headerlink" title="ContentProvider类"></a>ContentProvider类</h4><p>　　ContentProvider主要以表格的形式组织数据，同时也支持文件数据，只是表格形式用得比较多。每个表格中包含多张表， 每张表包含行 &amp; 列，分别对应记录 &amp; 字段。</p>
<h4 id="ContentResolver类"><a href="#ContentResolver类" class="headerlink" title="ContentResolver类"></a>ContentResolver类</h4><p>　　统一管理不同ContentProvider间的操作。外部进程通过ContentResolver类，从而与ContentProvider类进行交互。<br>　　一般来说，一款应用要使用多个ContentProvider，若需要了解每个ContentProvider的不同实现从而再完成数据交互，操作成本高 &amp; 难度大。所以在ContentProvider类上加多了一个ContentResolver类对所有的ContentProvider进行统一管理。</p>
<p>　　Android 提供了3个用于辅助 ContentProvide 的工具类：</p>
<ul>
<li><strong>ContentUris</strong>：操作 URI</li>
<li><strong>UriMatcher</strong>：<br>1）在 ContentProvider 中注册 URI<br>2）根据 URI 匹配 ContentProvider 中对应的数据表</li>
<li><strong>ContentObserver</strong>：观察 URI 引起 ContentProvider 中的数据变化并通知数据访问者</li>
</ul>
<h2 id="三、用法"><a href="#三、用法" class="headerlink" title="三、用法"></a>三、用法</h2><h3 id="1-主要用法："><a href="#1-主要用法：" class="headerlink" title="1. 主要用法："></a>1. 主要用法：</h3><p>（1）使用现有的内容提供者来读取和操作现有的程序中的数据。<br>（2）创建自己的内容提供者给我们的程序提供外部访问接口。</p>
<h3 id="2-创建ContentProvider基本流程"><a href="#2-创建ContentProvider基本流程" class="headerlink" title="2. 创建ContentProvider基本流程"></a>2. 创建ContentProvider基本流程</h3><p>1）创建数据库类DBHelper继承自SQLiteOpenHelper<br>2）定义一个类DataProvider继承自ContentProvider<br>3）实现其onCreate、getType、insert、delete、update、query方法<br>4）在清单文件中注册ContentProvider<br>5）将访问途径Uri提供出去</p>
<h3 id="3-使用ContentProvider基本流程"><a href="#3-使用ContentProvider基本流程" class="headerlink" title="3. 使用ContentProvider基本流程"></a>3. 使用ContentProvider基本流程</h3><p>1）通过getContentResolver获取ContentResolver对象resolver<br>2）通过Uri对ContentProvider中的数据进行增删改查操作</p>
<h3 id="4-统一资源标识符（URI）"><a href="#4-统一资源标识符（URI）" class="headerlink" title="4. 统一资源标识符（URI）"></a>4. 统一资源标识符（URI）</h3><p>定义： Uniform Resource Identifier ， 即统一资源标识符<br>作用： 唯一标识 ContentProvider &amp; 其中的数据<br>　　外界进程通过 URI 找到对应的ContentProvider &amp; 其中的数据， 再进行数据操作。<br>具体使用：<br>　　URI分为 系统预置（如通讯录、 日程表等） &amp; 自定义<br><img src="/images/img_uri.jpg" alt="img_uri"></p>
<h2 id="四、优点"><a href="#四、优点" class="headerlink" title="四、优点"></a>四、优点</h2><h3 id="1-安全"><a href="#1-安全" class="headerlink" title="1. 安全"></a>1. 安全</h3><p>　　ContentProvider为应用间的数据交互提供了一个安全的环境：允许把自己的应用数据<strong>根据需求</strong>开放给其他应用进行增、删、改、 查，而不用担心因为直接开放数据库权限而带来的安全问题。</p>
<h3 id="2-访问简单-amp-高效"><a href="#2-访问简单-amp-高效" class="headerlink" title="2. 访问简单 &amp; 高效"></a>2. 访问简单 &amp; 高效</h3><p>　　对比于其他对外共享数据的方式，数据访问方式会因数据存储的方式而不同：</p>
<ul>
<li>采用 文件方式 对外共享数据， 需要进行文件操作读写数据；</li>
<li>采用 Sharedpreferences 共享数据， 需要使用sharedpreferences API读写数据<br>这使得访问数据变得复杂 &amp; 难度大。<br>　　而采用ContentProvider方式，其解耦了底层数据的存储方式， 使得无论底层数据存储采用何种方式，外界对数据的访问方式都是统一的， 这使得访问简单 &amp;　高效。</li>
</ul>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><img src="/images/img_content_provider_all.jpg" alt="img_content_provider_all"></p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android四大组件之BroadcastReceiver</title>
    <url>/2020/02/27/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BBroadcastReceiver/</url>
    <content><![CDATA[<p>　　<strong>广播接收者（BroadcastReceiver）</strong> 是Android中用于接收广播的一种组件。广播是一种广泛运用的在应用程序之间传递信息的机制。广播类似于Java中的观察者模式，广播的内容是一个携带信息的Intent。</p>
<a id="more"></a>

<h2 id="一、广播的分类"><a href="#一、广播的分类" class="headerlink" title="一、广播的分类"></a>一、广播的分类</h2><h3 id="1-按形式分："><a href="#1-按形式分：" class="headerlink" title="1. 按形式分："></a>1. 按形式分：</h3><ul>
<li>标准广播：异步执行、没有先后顺序、效率高、无法被截断</li>
<li>有序广播：同步执行、有先后顺序、效率低、可以被截断（前面的广播可以截断后面正在传递的广播）<h3 id="2-按级别分："><a href="#2-按级别分：" class="headerlink" title="2. 按级别分："></a>2. 按级别分：</h3></li>
<li>普通广播：正常定义的广播（注意：广播是可以跨App直接通信的）</li>
<li>系统广播：系统定义的广播</li>
<li>本地广播：可理解为一种局部广播， 广播的发送者和接收者都同属于一个App。<br>相比于全局广播（普通广播），本地广播优势体现在：安全性高、效率高</li>
<li>粘性广播：Intent会一直保留到广播事件结束，并且没有10秒限制。（10秒限制是指普通的广播如果onReceive方法执行时间太长，超过10秒的时候系统会将这个广播置为可以干掉的candidate，一旦系统资源不够的时候，就会干掉这个广播而让它不执行。）</li>
</ul>
<p><strong>注意：</strong><br>粘性广播在Android 5.0(API 21)中已弃用。</p>
<h2 id="二、注册方式"><a href="#二、注册方式" class="headerlink" title="二、注册方式"></a>二、注册方式</h2><h3 id="1-动态注册"><a href="#1-动态注册" class="headerlink" title="1. 动态注册"></a>1. 动态注册</h3><p>（1）创建一个自定义的广播接收者，继承于BroadcastReceiver，并重写onReceive方法。<br>（2）在Activity中，通过registerReceiver方法注册广播接收者。</p>
<ul>
<li>非常驻型广播：跟随组件的生命周期，如果应用程序关闭，动态注册的广播就无法接收</li>
<li>优先级较高</li>
</ul>
<p><strong>注意：</strong><br>1）在Activity生命周期结束前，记得注销广播接收者，否则会导致内存泄漏。<br>2）动态注册广播最好应该在onResume中注册、在onPause()中注销。</p>
<h3 id="2-静态注册"><a href="#2-静态注册" class="headerlink" title="2. 静态注册"></a>2. 静态注册</h3><p>（1）创建一个自定义的广播接收者，继承于BroadcastReceiver，并重写onReceive方法。<br>（2）在AndroidManifest文件中，通过&lt;receiver&gt;标签注册广播接收者。</p>
<ul>
<li>常驻型广播：不受组件生命周期的影响，即使应用程序关闭，静态注册的广播仍能够接收</li>
<li>优先级较低<br>缺点：耗电、占内存</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li><strong>Android 8.0以上版本，绝大部分的广播不能进行静态注册。</strong> 由于静态注册的方式非常的耗电，Google专门进行了优化。</li>
<li><strong>不要在onReceive()方法中进行任何耗时操作。</strong> 由于，onReceive()方法运行在主线程中，耗时操作会导致ANR（通常是10秒）。</li>
<li><strong>广播接收者不允许开启子线程</strong>，原因：</li>
</ol>
<ul>
<li>对于静态注册的广播接收者来说，广播接收者对象的生命周期较短，执行完onReceive()方法就会变为垃圾对象而被回收。在子线程执行完之前，若对应的Activity退出，他们所在进程就变成了空进程(没有任何活动组件的进程)，系统需要内存时可能会优先终止该进程，进程被终止，其内的子线程也会被终止，导致子线程无法执行完。</li>
<li>对于动态注册的广播接收者来说，Activity退出时会调用unregisteReceiver()方法执行解注册，此时广播接收者对象也会变成垃圾对象而被回收。在子线程执行完之前，对应的Activity退出，同样它们所在进程就变成了空进程，其内的子线程也无法执行完。</li>
</ul>
<ol start="4">
<li><strong>如果必须执行耗时任务可以考虑，在onReceive中开启服务来执行。</strong> 系统就会认为这个进程里还有其他活动组件在运行，就不会任意时刻回收此进程。</li>
</ol>
<h2 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h2><p><img src="/images/img_broadcast_receiver.jpg" alt="img_broadcast_receiver"></p>
<ol>
<li>广播接收者通过<strong>Binder机制</strong>向AMS(Activity Manager Service)进行注册；</li>
<li>广播发送者通过<strong>Binder机制</strong>向AMS发送广播；</li>
<li>AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，AMS将广播发送到上述符合条件的BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；</li>
<li>BroadcastReceiver通过消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。</li>
</ol>
<p><strong>注意：</strong><br>　　广播发送者和广播接收者的执行是<strong>异步</strong>的，发出去的广播不会关心有无接收者接收，也不确定接收者到底是何时才能接收到。</p>
<h2 id="四、LocalBroadcastManager"><a href="#四、LocalBroadcastManager" class="headerlink" title="四、LocalBroadcastManager"></a>四、LocalBroadcastManager</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h3><p>（1）使用它发送的广播只能在自身App内传播，因此不必担心泄漏隐私数据；<br>（2）其它App无法对你的App发送广播，具有更高的安全性；<br>（3）比系统的全局广播更加高效。</p>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>　　内部是通过<strong>Handler</strong>实现的。它的sendBroadcast方法其实是通过Handler发送了一个Message。</p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer(六) 数学问题</title>
    <url>/2020/02/26/%E5%89%91%E6%8C%87Offer-6-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h3><p><strong><em>题目描述：</em></strong><br>输入一个整数，输出概述二进制表示中1的个数，其中负数用补码表示<br>时间限制：1秒 空间限制：32768K</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：每一位和 1 相与：1 -&gt; 1  0 -&gt; 0</span></span><br><span class="line"><span class="comment">     *       然后将1每次左移一位，1 -&gt; 10 -&gt; 100 ...</span></span><br><span class="line"><span class="comment">     *       统计需要做多少次运算变成0</span></span><br><span class="line"><span class="comment">     *       （该方法无法通过全部的测试用例）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = ~n + <span class="number">1</span>;  <span class="comment">//求补码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getNumberOf1(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：一个整数减去1和原整数想与，</span></span><br><span class="line"><span class="comment">     *       会将该整数最右边的一个1变成0，</span></span><br><span class="line"><span class="comment">     *       统计需要做多少次运算将变成0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf11</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h3><p><strong><em>题目描述</em></strong><br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：传统公式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//        int exp = Math.abs(exponent);</span></span><br><span class="line">        <span class="keyword">int</span> exp = exponent;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exp = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exp; i++) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：数学函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power1</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result;</span><br><span class="line">        <span class="keyword">if</span> (exponent &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            result = Math.pow(base, exponent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = Math.pow(base, -exponent);</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法3：按位运算</span></span><br><span class="line"><span class="comment">     * 举例: 10^1101 = 10^0001*10^0100*10^1000。</span></span><br><span class="line"><span class="comment">     *      通过&amp;1和&gt;&gt;1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power2</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> exp = exponent;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exp = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (exp != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((exp &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                result *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            base *= base;</span><br><span class="line">            exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &lt; <span class="number">0</span> ? <span class="number">1</span> / result : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-从1到n整数中1出现的次数"><a href="#31-从1到n整数中1出现的次数" class="headerlink" title="31. 从1到n整数中1出现的次数"></a>31. 从1到n整数中1出现的次数</h3><p><strong><em>题目描述</em></strong><br>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？<br>为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。<br>ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp % <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="46-圆圈中最后剩下的数"><a href="#46-圆圈中最后剩下的数" class="headerlink" title="46. 圆圈中最后剩下的数"></a>46. 圆圈中最后剩下的数</h3><p><strong><em>题目描述</em></strong><br>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。<br>HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。<br>然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,<br>然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….<br>直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。<br>请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 模拟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//约瑟夫环问题</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            s = (s + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48. 不用加减乘除做加法"></a>48. 不用加减乘除做加法</h3><p><strong><em>题目描述</em></strong><br>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num1 ^ num2;</span><br><span class="line">            num2 =  (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer(五) 动态规划</title>
    <url>/2020/02/26/%E5%89%91%E6%8C%87Offer-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h3 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h3><p><strong><em>题目描述</em></strong><br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39<br>斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……</p>
<a id="more"></a>

<p>在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           result = num1 + num2;</span><br><span class="line">           num1 = num2;</span><br><span class="line">           num2 = result;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划（递归）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> f[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      f[n] = Fibonacci2(n - <span class="number">1</span>) + Fibonacci2(n - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划（非递归）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> f[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(k &lt;= n) &#123;</span><br><span class="line">        f[k] = f[k-<span class="number">1</span>] + f[k-<span class="number">2</span>];</span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递推公式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">       <span class="keyword">double</span> root1 = (<span class="number">1</span> + sqrt5) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">double</span> root2 = (<span class="number">1</span> - sqrt5) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">new</span> Double((Math.pow(root1, n) - Math.pow(root2, n)) / sqrt5)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h3><p><strong><em>题目描述</em></strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于本题,前提只有 一次 1阶或者2阶的跳法。</span></span><br><span class="line"><span class="comment">a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);</span></span><br><span class="line"><span class="comment">b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)</span></span><br><span class="line"><span class="comment">c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"><span class="comment">d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</span></span><br><span class="line"><span class="comment">e.可以发现最终得出的是一个斐波那契数列：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           | 1, (n=1)</span></span><br><span class="line"><span class="comment">f(n) =     | 2, (n=2)</span></span><br><span class="line"><span class="comment">           | f(n-1)+f(n-2) ,(n&gt;2,n为整数)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>) + JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h3><p><strong><em>题目描述</em></strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1:1 2:2 3:4 4:8</span></span><br><span class="line"><span class="comment">可得规律</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-矩阵覆盖"><a href="#10-矩阵覆盖" class="headerlink" title="10. 矩阵覆盖"></a>10. 矩阵覆盖</h3><p><strong><em>题目描述</em></strong><br>我们可以用2<em>1的小矩阵横着或者竖着区覆盖更大的矩阵。<br>请问用n个2\</em>1的小矩阵无重叠地覆盖一个2*n的大矩阵，总共多少种方法？<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">斐波那契数列变形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target-<span class="number">1</span>) + RectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer(四) 树</title>
    <url>/2020/02/26/%E5%89%91%E6%8C%87Offer-4-%E6%A0%91/</url>
    <content><![CDATA[<h3 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h3><p><strong><em>题目描述</em></strong><br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。<br>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。<br>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<a id="more"></a>

<p>时间限制：1秒 空间限制：32768K<br>本题知识点： 二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length != in.length || pre.length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归，构建原始二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre  前序遍历序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ps   前序遍历起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pe   前序遍历终止位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in   后序遍历序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is   后序遍历起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ie   后序遍历终止位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, <span class="keyword">int</span>[] in, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ps &gt; pe) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = pre[ps];</span><br><span class="line">        <span class="keyword">int</span> index = is;</span><br><span class="line">        <span class="comment">//中序遍历中找到根节点的位置</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt;= ie &amp;&amp; in[index] != root) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果在整个中序遍历的数组中没有找到，证明输入不合法，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; ie) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Invalid Input"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归构建子二叉树</span></span><br><span class="line">        TreeNode treeNode = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        <span class="comment">//左子树的元素个数：index-is+1</span></span><br><span class="line">        <span class="comment">//左子树对应的前序遍历的位置是：[ps+1, ps+index-is]</span></span><br><span class="line">        <span class="comment">//左子树对应的中序遍历的位置是：[is, index-1]</span></span><br><span class="line">        treeNode.left = constructBinaryTree(pre, ps+<span class="number">1</span>, ps+index-is, in, is, index-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右子树的元素个数：ie-index</span></span><br><span class="line">        <span class="comment">//右子树对应的前序遍历的位置是：[ps+index-is+1, pe]</span></span><br><span class="line">        <span class="comment">//右子树对应的中序遍历的位置是：[index+1, ie]</span></span><br><span class="line">        treeNode.right = constructBinaryTree(pre, ps+index-is+<span class="number">1</span>, pe, in, index+<span class="number">1</span>, ie);</span><br><span class="line">        <span class="keyword">return</span> treeNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17. 树的子结构"></a>17. 树的子结构</h3><p><strong><em>题目描述</em></strong><br>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;  <span class="comment">//此时Tree2先遍历完，证明是子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) &#123;  <span class="comment">//此时Tree1先遍历完，证明不是子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1.val == root2.val &amp;&amp; isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18. 二叉树的镜像"></a>18. 二叉树的镜像</h3><p><strong><em>题目描述</em></strong><br>操作给定的二叉树，将其变换为源二叉树的镜像。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入描述:</span></span><br><span class="line"><span class="comment">二叉树的镜像定义：</span></span><br><span class="line"><span class="comment">		源二叉树</span></span><br><span class="line"><span class="comment">    	    8</span></span><br><span class="line"><span class="comment">    	   / \</span></span><br><span class="line"><span class="comment">    	  6   10</span></span><br><span class="line"><span class="comment">    	 / \  / \</span></span><br><span class="line"><span class="comment">    	5  7 9  11</span></span><br><span class="line"><span class="comment">    	镜像二叉树</span></span><br><span class="line"><span class="comment">    	    8</span></span><br><span class="line"><span class="comment">    	   / \</span></span><br><span class="line"><span class="comment">    	  10   6</span></span><br><span class="line"><span class="comment">    	 / \  / \</span></span><br><span class="line"><span class="comment">    	11 9 7  5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22. 从上往下打印二叉树"></a>22. 从上往下打印二叉树</h3><p>题目描述<br>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：使用队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：不使用队列 (使用ArrayList模拟队列)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = list.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38. 二叉树的深度"></a>38. 二叉树的深度</h3><p><strong><em>题目描述</em></strong><br>输入一棵二叉树，求该树的深度。<br>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(TreeDepth(root.left) + <span class="number">1</span>, TreeDepth(root.right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60. 把二叉树打印成多行"></a>60. 把二叉树打印成多行</h3><p><strong><em>题目描述</em></strong><br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        depth(pRoot, <span class="number">1</span>, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">depth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; list.size()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        list.get(depth-<span class="number">1</span>).add(root.val);</span><br><span class="line">        depth(root.left, depth + <span class="number">1</span>, list);</span><br><span class="line">        depth(root.right, depth + <span class="number">1</span>, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer(三) 栈和队列</title>
    <url>/2020/02/26/%E5%89%91%E6%8C%87Offer-3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5. 用两个栈实现队列"></a>5. 用两个栈实现队列</h3><p><strong><em>题目描述</em></strong><br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 队列 栈</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20. 包含min函数的栈"></a>20. 包含min函数的栈</h3><p><strong><em>题目描述</em></strong><br>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; smin = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        st.push(node);</span><br><span class="line">        <span class="keyword">if</span> (smin.empty()) &#123;</span><br><span class="line">            smin.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node &lt; smin.peek()) &#123;</span><br><span class="line">            smin.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st.peek() == smin.peek()) &#123;</span><br><span class="line">            smin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> smin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21. 栈的压入、弹出序列"></a>21. 栈的压入、弹出序列</h3><p><strong><em>题目描述</em></strong><br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。<br>假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，<br>但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：使用栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pushA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> popA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span> &amp;&amp; stack.peek() == popA[j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不使用栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pushA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> popA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder1</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pushA[i] != popA[j]) &#123;</span><br><span class="line">                arrayList.add(pushA[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrayList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrayList.get(i) != popA[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Android四大组件之Service</title>
    <url>/2020/02/26/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BService/</url>
    <content><![CDATA[<p>　　<strong>服务（Service）</strong> 是一种可以在后台执行长时间运行操作而没有用户界面的组件。<br>　　比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。
　　</p>
<a id="more"></a>

<p><strong>注意：</strong></p>
<ol>
<li><strong>Service默认运行在UI线程（主线程）中， 因此， 不要在Service中执行耗时的操作。</strong>　除非在Service中创建子线程。</li>
<li>Android的后台就是指它的运行是完全不依赖UI（线程）。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。</li>
</ol>
<h2 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h2><p><img src="/images/img_service_life_cycle.png" alt="img_service_life_cycle"></p>
<h3 id="1-startService-stopService"><a href="#1-startService-stopService" class="headerlink" title="1.startService / stopService"></a>1.startService / stopService</h3><p><strong>生命周期顺序： onCreate-&gt;onStartCommand-&gt;onDestroy</strong><br>　　如果一个Service被某个Activity 调用 Context.startService方法启动， 那么不管是否有Activity使用bindService绑定或unbindService解除绑定到该Service， 该Service都在后台运行， 直到被调用stopService， 或自身的stopSelf方法。 当然如果系统资源不足， android系统也可能结束服务， 还有一种方法可以关闭服务， 在设置中， 通过应用-&gt;找到自己应用-&gt;停止。<br><strong>注意点：</strong><br>①第一次 startService 会触发 onCreate 和 onStartCommand， 以后在服务运行过程中， 每次 startService 都<strong>只会触发 onStartCommand</strong><br>②不论 startService 多少次， stopService 一次就会停止服务</p>
<h3 id="2-bindService-unbindService"><a href="#2-bindService-unbindService" class="headerlink" title="2.bindService / unbindService"></a>2.bindService / unbindService</h3><p><strong>生命周期顺序： onCreate-&gt;onBind-&gt;onUnBind-&gt;onDestroy</strong><br>　　如果一个Service在某个Activity中被调用bindService方法启动， 不论bindService被调用几次， Service的onCreate方法只会执行一次， 同时onStartCommand方法始终不会调用。<br>当建立连接后， Service会一直运行， 除非调用unbindService来接触绑定、 断开连接或调用该Service的Context不存在了（如Activity被Finish——即<strong>通过bindService启动的Service的生命周期依附于启动它的Context</strong>）， 系统在这时会自动停止该Service。<br><strong>注意点：</strong><br>第一次 bindService 会触发 onCreate 和 onBind， 以后在服务运行过程中， 每次 bindService 都<strong>不会触发任何回调</strong></p>
<h3 id="3-混合型（上面两种方式的交互）"><a href="#3-混合型（上面两种方式的交互）" class="headerlink" title="3.混合型（上面两种方式的交互）"></a>3.混合型（上面两种方式的交互）</h3><p>　　当一个Service在被启动(startService)的同时又被绑定(bindService)， 该Service将会一直在后台运行， 并且不管调用几次， onCreate方法始终只会调用一次， onStartCommand的调用次数与startService调用的次数一致（使用bindService方法不会调用onStartCommand）。 同时， 调用unBindService将不会停止Service， 必须调用stopService或Service自身的stopSelf来停止服务。</p>
<h2 id="二、启动方式"><a href="#二、启动方式" class="headerlink" title="二、启动方式"></a>二、启动方式</h2><h3 id="1-startService"><a href="#1-startService" class="headerlink" title="1. startService"></a>1. startService</h3><p>首先，在AndroidManifest文件中进行注册。<br>(1)服务端，创建BindService并继承自Service。<br>(2)客户端，通过startService()方法启动服务。</p>
<h3 id="2-bindService"><a href="#2-bindService" class="headerlink" title="2. bindService"></a>2. bindService</h3><p>首先，在AndroidManifest文件中进行注册。<br>(1)服务端，创建BindService并继承自Service；创建一个实现IBindler接口的实例对象，并提供公共方法给客户端调用；从onBind()回调方法返回此Binder实例。<br>(2)客户端，创建一个ServiceConnection对象，并在其onServiceConnected()回调方法中接收Binder对象；然后通过bindService()方法绑定服务。</p>
<h2 id="三、类型"><a href="#三、类型" class="headerlink" title="三、类型"></a>三、类型</h2><h3 id="1-按运行位置："><a href="#1-按运行位置：" class="headerlink" title="1. 按运行位置："></a>1. 按运行位置：</h3><ul>
<li>本地服务（Local Service）：服务依附于主进程</li>
<li>远程服务（Remote Service）：服务为独立的进程<h3 id="2-按运行类型："><a href="#2-按运行类型：" class="headerlink" title="2. 按运行类型："></a>2. 按运行类型：</h3></li>
<li>前台服务：通知栏显示Notification，如天气更新、日期同步等</li>
<li>后台服务：通知栏不显示Notification，如音乐播放器<h3 id="3-按启动方式："><a href="#3-按启动方式：" class="headerlink" title="3. 按启动方式："></a>3. 按启动方式：</h3></li>
<li>startService启动的服务</li>
<li>bindService启动的服务</li>
<li>同时用两种方式启动的服务</li>
</ul>
<h2 id="四、Service和Thread的区别"><a href="#四、Service和Thread的区别" class="headerlink" title="四、Service和Thread的区别"></a>四、Service和Thread的区别</h2><p>　　本质上来说，两者没有任何关系，它们是完全不同的概念。</p>
<ol>
<li>定义上：</li>
</ol>
<ul>
<li>Thread：Thread是程序执行的最小单元，它是分配CPU的基本单位。可以用Thread来执行一些异步的操作。</li>
<li>Service：Service是android的一种机制，当它运行的时候如果是Local Service，那么对应的Service是运行在<strong>主进程的主线程上</strong>；如果是Remote Service，那么对应的Service则是运行在<strong>独立进程的主线程上</strong>。</li>
</ul>
<ol start="2">
<li>使用上：</li>
</ol>
<ul>
<li>Thread的运行是独立的，也就是说当一个Activity被finish之后，如果没有主动停止Thread或者Thread里的run方法没有执行完毕的话，Thread也会一直执行。 这样会导致的问题：1) 当Activity被finish之后，不再持有该Thread的引用，也就是不能再控制该Thread。2）没有办法在不同的Activity中对同一Thread进行控制。</li>
<li>所有的Activity都可以与Service进行关联，也就是说多个Activity可以同时控制同一个Service，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。</li>
</ul>
<p><strong>什么时候使用Service，什么时候使用Thread呢?</strong><br>（1）在应用中，如果是<strong>长时间的在后台运行，而且不需要交互</strong>的情况下，使用<strong>Service</strong>。<br>（2）在后台运行，不需要交互的情况下，如果只是完成某个任务，之后就不需要运行，而且可能是多个任务，需要长时间运行的情况下，使用<strong>Thread</strong>。<br>（3）如果任务占用CPU时间多，资源大的情况下，使用<strong>Thread</strong>。</p>
<h2 id="五、IntentService"><a href="#五、IntentService" class="headerlink" title="五、IntentService"></a>五、IntentService</h2><p> 　　继承于Service，内部有一个HandlerThread对象，可以看做是Service和HandlerThread的结合体。</p>
<h3 id="1-特点："><a href="#1-特点：" class="headerlink" title="1. 特点："></a>1. 特点：</h3><ul>
<li>在IntentService<strong>内有一个工作线程</strong>来处理耗时操作。</li>
<li>当任务执行完后，IntentService 会自动停止，不需要我们去手动结束。</li>
<li>如果启动 IntentService 多次，那么每一个耗时操作会以工作队列的方式在 IntentService 的 onHandleIntent 回调方法中执行，依次去执行，使用串行的方式，执行完自动结束。</li>
</ul>
<h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h3><p><img src="/images/img_service_intent_service.jpg" alt="img_service_intent_service"></p>
<p> <strong>注意：</strong> 若启动IntentService多次， 那么每个耗时操作则以队列的方式在IntentService的onHandleIntent回调方法中依次执行， 执行完自动结束。</p>
<p> <strong>启动IntentService为什么不需要新建线程？</strong><br>　　IntentService内部的HandlerThread继承自Thread，内部封装了Looper，在这里新建线程并启动，所以启动IntentService不需要新建线程。</p>
<p><strong>为什么多次启动 IntentService 会顺序执行事件，停止服务后，后续的事件得不到执行？</strong><br>　　IntentService 中使用的 Handler、Looper、MessageQueue 机制把消息发送到线程中去执行的，所以<strong>多次启动IntentService不会重新创建新的服务和新的线程</strong>，只是把消息加入消息队列中等待执行，而如果服务停止，会清除消息队列中的消息，后续的事件得不到执行。</p>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><ul>
<li>线程任务需要按顺序、 在后台执行的使用场景</li>
</ul>
<p><em>最常见的场景：离线下载</em></p>
<ul>
<li>由于所有的任务都在同一个Thread looper里面来做， 所以不符合多个数据同时请求的场景。</li>
</ul>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android四大组件之Activity</title>
    <url>/2020/02/26/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity/</url>
    <content><![CDATA[<p>　　<strong>活动（Activity）</strong> 是一种可以包含用户界面的组件，主要用于和用户进行交互。</p>
<a id="more"></a>

<h2 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h2><p><img src="/images/img_activity_life_cycle.jpg" alt="img_activity_life_cycle"></p>
<p>同时，生命周期也对应了Activity的<strong>四种状态</strong>：</p>
<p>1) 运行状态(Running)<br>2) 暂停状态(Paused)<br>3) 停止状态(Stopped)<br>4) 销毁状态(Killed)</p>
<p><strong>注意</strong><br>onStart()和onResume()区别：</p>
<ul>
<li>onStart()：前台不可见，不能进行交互</li>
<li>onResume()：前台可见，可以进行交互</li>
</ul>
<h3 id="特定场景下的生命周期回调："><a href="#特定场景下的生命周期回调：" class="headerlink" title="特定场景下的生命周期回调："></a>特定场景下的生命周期回调：</h3><p>（1）用户打开新的Activiy的时候，之前的Activity： onPause()-&gt;onStop()<br>（2）按Back键回退时： onPause()-&gt;onStop()-&gt;onDestory()<br>（3）按Home键切换到桌面后又回到该Actitivy： onPause()-&gt;onStop()-&gt;onRestart()-&gt;onStart()-&gt;onResume()<br>（4）调用finish()方法： onDestory()<br>（5）横竖屏切换：onPause()-&gt;onSaveInstanceState()-&gt; onStop()-&gt;onDestroy()-&gt;onCreate()-&gt;onStart()-&gt;onRestoreInstanceState()-&gt;onResume()</p>
<h4 id="onSaveInstanceState和onRestoreInstanceState"><a href="#onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="onSaveInstanceState和onRestoreInstanceState"></a>onSaveInstanceState和onRestoreInstanceState</h4><p>　　在Activity由于异常情况下终止时， 系统会调用<strong>onSaveInstanceState</strong>来保存当前Activity的状态。 当异常终止的Activity被重建以后， 系统会调用<strong>onRestoreInstanceState</strong>， 并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象参数同时传递给onRestoreInstanceState和onCreate方法。<br>onCreate和onRestoreInstanceState方法来恢复Activity的状态的区别：<br>onRestoreInstanceState回调则表明其中Bundle对象非空， 不用加非空判断； onCreate需要非空判断。 建议使用onRestoreInstanceState。<br><strong>调用时机：</strong></p>
<ul>
<li>onSaveInstanceState()：onStop()之前</li>
<li>onRestoreInstanceState()：onStart()之后</li>
</ul>
<p>通过在AndroidManifest文件的Activity中指定如下属性：</p>
<blockquote>
<p>android:configChanges = “orientation|screenSize”</p>
</blockquote>
<p>来避免横竖屏切换时， Activity的销毁和重建。<br>而是回调了下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、启动模式"><a href="#二、启动模式" class="headerlink" title="二、启动模式"></a>二、启动模式</h2><h3 id="1-标准模式（Standard）"><a href="#1-标准模式（Standard）" class="headerlink" title="1. 标准模式（Standard）"></a>1. 标准模式（Standard）</h3><p>　　每启动一次Activity，就会创建一个新的Activity实例并置于栈顶。</p>
<h3 id="2-栈顶复用模式（SingleTop）"><a href="#2-栈顶复用模式（SingleTop）" class="headerlink" title="2. 栈顶复用模式（SingleTop）"></a>2. 栈顶复用模式（SingleTop）</h3><p>　　如果需要新建的Activity位于任务栈栈顶，那么此Activity的实例就不会重建，而是重用栈顶的实例。<br><strong>应用场景：</strong><br>（1）在通知栏点击收到的通知，然后需要启动一个Activity，这个Activity就可以用singleTop，否则每次点击都会新建一个Activity。<br>（2）某个场景下连续快速点击，启动了两个Activity。如果这个时候待启动的Activity使用SingleTop模式可以避免这个Bug。</p>
<h3 id="3-栈内复用模式（SingleTask）"><a href="#3-栈内复用模式（SingleTask）" class="headerlink" title="3. 栈内复用模式（SingleTask）"></a>3. 栈内复用模式（SingleTask）</h3><p>　　该模式是一种<strong>单例模式</strong>，即<strong>一个栈内只有一个该Activity实例</strong>。该模式可以通过在AndroidManifest文件中Activity的android:taskAffinity属性的需要加载到那个栈中。<br>　　如果Activity指定的栈不存在，则创建一个栈，并把创建的Activity压入栈内。如果Activity指定的栈存在，如果其中没有该Activity实例，则会创建Activity并压入栈顶，如果其中有该Activity实例，则把该Activity实例之上的Activity清除出栈，重用并让该Activity实例处在栈顶。<br><strong>应用场景：</strong><br>　　大多数App的主页。对于大部分应用，当我们在主界面点击回退按钮的时候都是退出应用，那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，主界面Activity上所有的Activity都会被移除，从而主界面Activity处于栈顶。通过这种方式能够保证退出应用时所有的Activity都能销毁。</p>
<h3 id="4-单例模式（SingleInstance）"><a href="#4-单例模式（SingleInstance）" class="headerlink" title="4. 单例模式（SingleInstance）"></a>4. 单例模式（SingleInstance）</h3><p>　　一个栈中只有一个Activity的实例。<br>　　一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例。<br><strong>应用场景：</strong><br>　　呼叫来电界面</p>
<h4 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="* 特殊情况："></a>* 特殊情况：</h4><ol>
<li><p>前台栈和后台栈的交互<br>假如目前有两个任务栈。 前台任务栈为AB， 后台任务栈为CD， 这里假设CD的启动模式均为SingleTask,现在请求启动D， 那么这个后台的任务栈都会被切换到前台，这个时候整个后退列表就变成了ABCD。 当用户按Back返回时， 列表中的Activity会一一出栈， 如下图：<br><img src="/images/img_activity_1.jpg" alt="img_activity_1"><br>如果不是请求启动D而是启动C， 那么情况又不一样， 如下图：<br><img src="/images/img_activity_2.jpg" alt="img_activity_2"><br>　　<strong>调用SingleTask模式的后台任务栈中的Activity， 会把整个栈的Actvity压入当前栈的栈顶。</strong> SingleTask会具有ClearTop特性， 把之上的栈内Activity清除。</p>
</li>
<li><p>SingleInstance深入理解<br>（1）A：Standard  B：SingleInstance<br> 启动顺序：A -&gt; B -&gt; A<br> 回退顺序：A -&gt; A -&gt; B<br>（2）A：Standard  B：SingleInstance C：Standard<br> 启动顺序：A -&gt; B -&gt; C<br> 回退顺序：C -&gt; A -&gt; B</p>
</li>
</ol>
<p><strong>注意：</strong> 回退是按照该栈的压入顺序进行的，而不是按照启动顺序进行。</p>
<h2 id="三、启动流程"><a href="#三、启动流程" class="headerlink" title="三、启动流程"></a>三、启动流程</h2><p><img src="/images/img_activity_start.jpg" alt="img_activity_start"></p>
<ol>
<li>Activity1调用startActivity，实际会调用Instrumentation类的execStartActivity方法</li>
</ol>
<p>Instrumentation是系统用来监控Activity运行的一个类，提供各种Activity生命周期的控制方法。</p>
<ol start="2">
<li><p>通过跨进程的binder调用，进入到ActivityManagerService中，其内部会处理Activity栈，通知Activity1 Pause，Activity1 执行Pause 后告知AMS</p>
</li>
<li><p>在ActivityManagerService中的startProcessLocked中调用了Process.start方法。并通过连接调用Zygote的native方法forkAndSpecialize，执行fork任务。之后再通过跨进程调用进入到Activity2所在的进程中。</p>
</li>
<li><p>主线程发起bind Application，AMS会做一些配置工作，然后让主线程bind ApplicationThread，ApplicationThread将启动Activity2的信息通过H对象发送给主线程。（发送的消息是EXECUTE_TRANSACTION，消息体是一个 ClientTransaction，即 LaunchActivityItem。）主线程拿到Activity2的信息后，调用Instrumentation类的newActivity方法，其内通过ClassLoader创建Activity2实例。</p>
</li>
</ol>
<p>ApplicationThread是一个binder对象，其运行在binder线程池中，内部包含一个H类，该类继承于类Handler。</p>
<ol start="5">
<li>通知Activity2去performCreate(执行onCreate方法)。</li>
</ol>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱(三) Android进阶知识</title>
    <url>/2020/02/26/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-3-Android%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><img src="/images/img_mind_map_android_2.png" alt="img_mind_map_android_2"></p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>脑图</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱(二) Android基础知识</title>
    <url>/2020/02/26/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-2-Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><img src="/images/img_mind_map_android_1.png" alt="img_mind_map_android_1"></p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>脑图</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱(一) Android工程师知识图谱</title>
    <url>/2020/02/26/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-1-Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<p><img src="/images/img_mind_map_all.png" alt="img_mind_map_all"></p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>脑图</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer(二) 链表</title>
    <url>/2020/02/25/%E5%89%91%E6%8C%87Offer-2-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="3-从头到尾打印链表"><a href="#3-从头到尾打印链表" class="headerlink" title="3. 从头到尾打印链表"></a>3. 从头到尾打印链表</h3><p><strong><em>题目描述</em></strong><br>输入一个链表，从尾到头打印链表每个节点的值。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1： 递归实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//递归求解结果必须声明为全局</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            result.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2： 利用数据结构 栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead1</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            arrayList.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15. 反转链表"></a>15. 反转链表</h3><p><strong><em>题目描述</em></strong><br>输入一个链表，反转链表后，输出链表的所有元素。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1： 使用数据结构 栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            <span class="comment">//方法1：</span></span><br><span class="line"><span class="comment">//            p.next = stack.peek();  //取栈的栈顶元素， 但并不出栈</span></span><br><span class="line"><span class="comment">//            p = p.next;</span></span><br><span class="line"><span class="comment">//            stack.pop();</span></span><br><span class="line">            <span class="comment">//方法2：</span></span><br><span class="line">            p.next = stack.pop();</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = ReverseList1(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;  <span class="comment">// 断开现在的结点连接</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法3：传统方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode temp = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16. 合并两个排序的链表"></a>16. 合并两个排序的链表</h3><p><strong><em>题目描述</em></strong><br>输入两个<strong>单调递增</strong>的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足<strong>单调不减</strong>规则。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode list = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">            list = list1;</span><br><span class="line">            list.next = Merge(list1.next, list2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list = list2;</span><br><span class="line">            list.next = Merge(list1, list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge1</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode list = <span class="keyword">null</span>;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    temp = list1;</span><br><span class="line">                    list = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.next = list1;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    temp = list2;</span><br><span class="line">                    list = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.next = list2;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36. 两个链表的第一个公共结点"></a>36. 两个链表的第一个公共结点</h3><p><strong><em>题目描述</em></strong><br>输入两个链表，找出它们的第一个公共结点。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = (p1 == <span class="keyword">null</span> ? pHead2 : p1.next);</span><br><span class="line">            p2 = (p2 == <span class="keyword">null</span> ? pHead1 : p2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55. 链表中环的入口结点"></a>55. 链表中环的入口结点</h3><p><strong><em>题目描述</em></strong><br>一个链表中包含环，请找出该链表的环的入口结点。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表<br><strong>分析：</strong><br><strong>设置快慢指针方法</strong><br>设置一个<strong>慢指针每次走1步</strong>，一个<strong>快指针每次走2步</strong>，如果有环，一定会在<strong>环内相遇</strong>。<br>然后让一个指针回到起点，<strong>起点开始走</strong>，让一个指针从<strong>相遇点开始继续往后走</strong>，两个指针速度一样。<br>那么，两者恰好在<strong>环的入口点相遇</strong>。如图：</p>
<p><img src="/images/img_offer_list.png" alt="img_offer_list"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用HashSet存储结点</span></span><br><span class="line"><span class="comment">   * 如果已经存在，这个结点就是入环结点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pHead</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(pHead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(pHead)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pHead;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(pHead);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置快慢指针</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(pHead == <span class="keyword">null</span>|| pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         ListNode node1 = pHead.next;</span><br><span class="line">         ListNode node2 = pHead.next.next;</span><br><span class="line">         <span class="keyword">while</span>(node1 != node2) &#123;</span><br><span class="line">             <span class="keyword">if</span>(node1.next != <span class="keyword">null</span> &amp;&amp; node2.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 node1 = node1.next;</span><br><span class="line">                 node2 = node2.next.next;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         node1 = pHead;</span><br><span class="line">         <span class="keyword">while</span>(node1 != node2) &#123;</span><br><span class="line">             node1 = node1.next;</span><br><span class="line">             node2 = node2.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> node1;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56. 删除链表中重复的结点"></a>56. 删除链表中重复的结点</h3><p><strong><em>题目描述</em></strong><br>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，<br>重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode first = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);  <span class="comment">//添加一个头结点，这样可以保证逻辑的连贯性</span></span><br><span class="line">        first.next = pHead;</span><br><span class="line">        ListNode p = pHead;</span><br><span class="line">        ListNode last = first;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val == p.next.val) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = p.val;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; val == p.val) &#123;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">                last.next = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer(一) 数组和字符串</title>
    <url>/2020/02/25/%E5%89%91%E6%8C%87Offer-1-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="1-二维数组的查找"><a href="#1-二维数组的查找" class="headerlink" title="1. 二维数组的查找"></a>1. 二维数组的查找</h3><p><strong><em>题目描述</em></strong><br>在一个二维数组中，每一行都按照<strong>从左到右递增</strong>的顺序排序，<br>每一列都按照<strong>从上到下递增</strong>的顺序排序。<br>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<a id="more"></a>

<p>时间限制：1秒 空间限制：32768K<br>本题知识点： 查找</p>
<p><strong>解题关键：</strong> 行列同时从不同方向进行查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">0</span> || array[<span class="number">0</span>].length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = array.length;</span><br><span class="line">        <span class="keyword">int</span> cols = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = cols - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= rows - <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;  <span class="comment">//注意：使用while循环</span></span><br><span class="line">            <span class="keyword">if</span> (target == array[i][j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; array[i][j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h3><p><strong><em>题目描述</em></strong><br>请实现一个函数，将一个字符串中的空格替换成“%20”。<br>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 字符串<br><strong>注意：</strong><br>实际上这个题考察的是单个字符在数组中的位置，<br>需要进行数组的遍历和复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：利用String的replaceAll函数直接字符串替换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  str.toString().replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：利用StringBuffer重新进行字符串的拼接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace1</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = str.toString();</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                result.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法3：新创建一个数组，进行数组元素的复制（技巧：从后向前进行数组的复制）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace2</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toString().toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        <span class="comment">//减少空间开销，求出替换后的数组长度</span></span><br><span class="line">        <span class="keyword">int</span> newLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                newLen += <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newLen++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] copys = <span class="keyword">new</span> <span class="keyword">char</span>[newLen];</span><br><span class="line">        <span class="keyword">int</span> j = newLen - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                copys[j--] = <span class="string">'0'</span>;</span><br><span class="line">                copys[j--] = <span class="string">'2'</span>;</span><br><span class="line">                copys[j--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                copys[j--] = chars[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(copys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h3><p><strong><em>题目描述</em></strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个<strong>非递减</strong>排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br>时间限制：3秒 空间限制：32768K<br>本题知识点： 查找<br><strong>注意：</strong><br>题目中隐含的条件，首先数组的旋转只是变换一次，<br>因此旋转数组的最小元素一定位于数组的中间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：排序，输出最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：采用二分法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray1</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//待旋转的数组一定满足： array[start] &gt;= array[end]</span></span><br><span class="line">        <span class="keyword">while</span> (array[start] &gt;= array[end]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> array[end];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt;= array[start]) &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt;= array[end]) &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13. 调整数组顺序使奇数位于偶数前面"></a>13. 调整数组顺序使奇数位于偶数前面</h3><p><strong><em>题目描述</em></strong><br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，<br>使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，<br>并保证奇数和奇数，偶数和偶数之间的<strong>相对位置不变</strong>。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test13</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：数组实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = res[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：队列实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray1</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变形： 不考虑顺序的情况，只需要一次遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray2</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; array[start] % <span class="number">2</span> == <span class="number">1</span>) &#123;  <span class="comment">//找偶数</span></span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; array[end] % <span class="number">2</span> == <span class="number">0</span>)&#123;  <span class="comment">//找奇数</span></span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = array[start];</span><br><span class="line">            array[start] = array[end];</span><br><span class="line">            array[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19. 顺时针打印矩阵"></a>19. 顺时针打印矩阵</h3><p><strong><em>题目描述</em></strong><br>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，<br>例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16<br>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1   2   3   4</span></span><br><span class="line"><span class="comment"> 5   6   7   8</span></span><br><span class="line"><span class="comment"> 9   10  11  12</span></span><br><span class="line"><span class="comment"> 13  14  15  16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：根据圈数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt; <span class="number">0</span> || matrix[<span class="number">0</span>].length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> circle = ((row &lt; col ? row : col) - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">//根据规律可知</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;circle; i++) &#123;</span><br><span class="line">            <span class="comment">//左-&gt;右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;col-i; j++)</span><br><span class="line">                result.add(matrix[i][j]);</span><br><span class="line">            <span class="comment">//上-&gt;下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>; k&lt;row-i; k++)</span><br><span class="line">                result.add(matrix[k][col-<span class="number">1</span>-i]);</span><br><span class="line">            <span class="comment">//右-&gt;左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m = col-i-<span class="number">2</span>; (m&gt;=i)&amp;&amp;(row-i-<span class="number">1</span>!=i); m--)</span><br><span class="line">                result.add(matrix[row-i-<span class="number">1</span>][m]);</span><br><span class="line">            <span class="comment">//下-&gt;上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n = row-i-<span class="number">2</span>; (n&gt;i)&amp;&amp;(col-i-<span class="number">1</span>!=i); n--)</span><br><span class="line">                result.add(matrix[n][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：限定边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix2</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt; <span class="number">0</span> || matrix[<span class="number">0</span>].length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, top = <span class="number">0</span>, right = col - <span class="number">1</span>, bottom = row - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="comment">// 左 -&gt; 右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                result.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上 -&gt; 下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class="line">                result.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右 -&gt; 左</span></span><br><span class="line">            <span class="keyword">if</span> (top != bottom) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">                    result.add(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下 -&gt; 上</span></span><br><span class="line">            <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; i--) &#123;</span><br><span class="line">                    result.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            top++;</span><br><span class="line">            right--;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29-最小的k个数"><a href="#29-最小的k个数" class="headerlink" title="29. 最小的k个数"></a>29. 最小的k个数</h3><p><strong><em>题目描述</em></strong><br>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(input);  <span class="comment">//数组快排</span></span><br><span class="line"><span class="comment">//        Collections.sort(list);  //链表快排</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34. 第一个只出现一次的字符"></a>34. 第一个只出现一次的字符</h3><p><strong><em>题目描述</em></strong><br>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(str.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">int</span> value = hashMap.get(str.charAt(i));</span><br><span class="line">                hashMap.put(str.charAt(i), value + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(str.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.get(str.charAt(i)) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="42-和为S的两个数字"><a href="#42-和为S的两个数字" class="headerlink" title="42. 和为S的两个数字"></a>42. 和为S的两个数字</h3><p><strong><em>题目描述</em></strong><br>输入一个<strong>递增</strong>排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br>输出描述:<br>对应每个测试案例，输出两个数，小的先输出。<br>时间限制：1秒 空间限制：32768K</p>
<p><strong>解题关键：</strong> 对于已排序数组来说，越靠近中间，乘积越大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[left] + array[right] &lt; sum) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[left] + array[right] &gt; sum) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.add(array[left]);</span><br><span class="line">                result.add(array[right]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44. 翻转单词顺序列"></a>44. 翻转单词顺序列</h3><p><strong><em>题目描述</em></strong><br>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。<br>同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student a am I”。<br>后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。<br>Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span> || str.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        String[] subStrs = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = subStrs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">//            StringBuilder builder = new StringBuilder(subStrs[i]);</span></span><br><span class="line"><span class="comment">//            result += builder.reverse().toString() + " ";  //tneduts a ma I</span></span><br><span class="line">            result += subStrs[i] + <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java 总结</title>
    <url>/2020/02/24/Effective-Java-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>本专栏文章为《Effective Java》一书内容的总结提炼。该书总结了优秀Java程序员必备的78条经验总结，这些经验总结针对Java程序员每天都会遇到的编程问题提出了最有效、最实用的解决方案。每条经验总结都详细阐明了应该怎么做，不应该怎么做，以及这样做的原因。</p>
</blockquote>
<a id="more"></a>

<p>　　同《Java编程思想》一样，本书也是Java编程的必读书目之一，熟练掌握书中的各条经验总结，必将大幅提高编码水平。书中有些经验总结，并不仅仅只对Java有效，对其他面向对象语言也是适用的。</p>
<p>　　本书的作者Joshua Bloch 带队设计过Java平台的许多特性，尤其是主导并实现了JDK5.0中的Java集合框架，因此，学习他的经验总结，对更好地阅读并理解JDK源码也是大有裨益的。</p>
<p><strong>思维导图：</strong></p>
<p><img src="/images/img_effective_java.png" alt="img_effective_java"></p>
<p>　　<em>本文主要是为了测试博客效果，要想查看完整内容，请前往我的CSDN专栏！</em></p>
<p><strong>CSDN专栏：<a href="https://blog.csdn.net/qq_34519487/category_9710430.html" target="_blank" rel="noopener">Effective Java</a></strong></p>
<p><a href="https://blog.csdn.net/qq_34519487/article/details/104252662" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
