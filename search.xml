<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>剑指Offer(六) 数学问题</title>
    <url>/2020/02/26/%E5%89%91%E6%8C%87Offer-6-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h3><p><strong><em>题目描述：</em></strong><br>输入一个整数，输出概述二进制表示中1的个数，其中负数用补码表示<br>时间限制：1秒 空间限制：32768K</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：每一位和 1 相与：1 -&gt; 1  0 -&gt; 0</span></span><br><span class="line"><span class="comment">     *       然后将1每次左移一位，1 -&gt; 10 -&gt; 100 ...</span></span><br><span class="line"><span class="comment">     *       统计需要做多少次运算变成0</span></span><br><span class="line"><span class="comment">     *       （该方法无法通过全部的测试用例）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = ~n + <span class="number">1</span>;  <span class="comment">//求补码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getNumberOf1(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：一个整数减去1和原整数想与，</span></span><br><span class="line"><span class="comment">     *       会将该整数最右边的一个1变成0，</span></span><br><span class="line"><span class="comment">     *       统计需要做多少次运算将变成0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf11</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h3><p><strong><em>题目描述</em></strong><br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：传统公式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//        int exp = Math.abs(exponent);</span></span><br><span class="line">        <span class="keyword">int</span> exp = exponent;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exp = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exp; i++) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：数学函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power1</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result;</span><br><span class="line">        <span class="keyword">if</span> (exponent &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            result = Math.pow(base, exponent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = Math.pow(base, -exponent);</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法3：按位运算</span></span><br><span class="line"><span class="comment">     * 举例: 10^1101 = 10^0001*10^0100*10^1000。</span></span><br><span class="line"><span class="comment">     *      通过&amp;1和&gt;&gt;1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power2</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> exp = exponent;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exp = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (exp != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((exp &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                result *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            base *= base;</span><br><span class="line">            exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &lt; <span class="number">0</span> ? <span class="number">1</span> / result : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-从1到n整数中1出现的次数"><a href="#31-从1到n整数中1出现的次数" class="headerlink" title="31. 从1到n整数中1出现的次数"></a>31. 从1到n整数中1出现的次数</h3><p><strong><em>题目描述</em></strong><br>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？<br>为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。<br>ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp % <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="46-圆圈中最后剩下的数"><a href="#46-圆圈中最后剩下的数" class="headerlink" title="46. 圆圈中最后剩下的数"></a>46. 圆圈中最后剩下的数</h3><p><strong><em>题目描述</em></strong><br>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。<br>HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。<br>然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,<br>然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….<br>直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。<br>请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 模拟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//约瑟夫环问题</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            s = (s + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48. 不用加减乘除做加法"></a>48. 不用加减乘除做加法</h3><p><strong><em>题目描述</em></strong><br>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num1 ^ num2;</span><br><span class="line">            num2 =  (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer(五) 动态规划</title>
    <url>/2020/02/26/%E5%89%91%E6%8C%87Offer-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h3 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h3><p><strong><em>题目描述</em></strong><br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39<br>斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……</p>
<a id="more"></a>

<p>在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           result = num1 + num2;</span><br><span class="line">           num1 = num2;</span><br><span class="line">           num2 = result;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划（递归）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> f[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      f[n] = Fibonacci2(n - <span class="number">1</span>) + Fibonacci2(n - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划（非递归）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> f[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(k &lt;= n) &#123;</span><br><span class="line">        f[k] = f[k-<span class="number">1</span>] + f[k-<span class="number">2</span>];</span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递推公式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">       <span class="keyword">double</span> root1 = (<span class="number">1</span> + sqrt5) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">double</span> root2 = (<span class="number">1</span> - sqrt5) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">new</span> Double((Math.pow(root1, n) - Math.pow(root2, n)) / sqrt5)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h3><p><strong><em>题目描述</em></strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于本题,前提只有 一次 1阶或者2阶的跳法。</span></span><br><span class="line"><span class="comment">a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);</span></span><br><span class="line"><span class="comment">b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)</span></span><br><span class="line"><span class="comment">c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"><span class="comment">d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</span></span><br><span class="line"><span class="comment">e.可以发现最终得出的是一个斐波那契数列：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           | 1, (n=1)</span></span><br><span class="line"><span class="comment">f(n) =     | 2, (n=2)</span></span><br><span class="line"><span class="comment">           | f(n-1)+f(n-2) ,(n&gt;2,n为整数)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>) + JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h3><p><strong><em>题目描述</em></strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1:1 2:2 3:4 4:8</span></span><br><span class="line"><span class="comment">可得规律</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-矩阵覆盖"><a href="#10-矩阵覆盖" class="headerlink" title="10. 矩阵覆盖"></a>10. 矩阵覆盖</h3><p><strong><em>题目描述</em></strong><br>我们可以用2<em>1的小矩阵横着或者竖着区覆盖更大的矩阵。<br>请问用n个2\</em>1的小矩阵无重叠地覆盖一个2*n的大矩阵，总共多少种方法？<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">斐波那契数列变形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target-<span class="number">1</span>) + RectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer(四) 树</title>
    <url>/2020/02/26/%E5%89%91%E6%8C%87Offer-4-%E6%A0%91/</url>
    <content><![CDATA[<h3 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h3><p><strong><em>题目描述</em></strong><br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。<br>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。<br>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<a id="more"></a>

<p>时间限制：1秒 空间限制：32768K<br>本题知识点： 二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length != in.length || pre.length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归，构建原始二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre  前序遍历序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ps   前序遍历起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pe   前序遍历终止位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in   后序遍历序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is   后序遍历起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ie   后序遍历终止位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, <span class="keyword">int</span>[] in, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ps &gt; pe) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = pre[ps];</span><br><span class="line">        <span class="keyword">int</span> index = is;</span><br><span class="line">        <span class="comment">//中序遍历中找到根节点的位置</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt;= ie &amp;&amp; in[index] != root) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果在整个中序遍历的数组中没有找到，证明输入不合法，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; ie) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Invalid Input"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归构建子二叉树</span></span><br><span class="line">        TreeNode treeNode = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        <span class="comment">//左子树的元素个数：index-is+1</span></span><br><span class="line">        <span class="comment">//左子树对应的前序遍历的位置是：[ps+1, ps+index-is]</span></span><br><span class="line">        <span class="comment">//左子树对应的中序遍历的位置是：[is, index-1]</span></span><br><span class="line">        treeNode.left = constructBinaryTree(pre, ps+<span class="number">1</span>, ps+index-is, in, is, index-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右子树的元素个数：ie-index</span></span><br><span class="line">        <span class="comment">//右子树对应的前序遍历的位置是：[ps+index-is+1, pe]</span></span><br><span class="line">        <span class="comment">//右子树对应的中序遍历的位置是：[index+1, ie]</span></span><br><span class="line">        treeNode.right = constructBinaryTree(pre, ps+index-is+<span class="number">1</span>, pe, in, index+<span class="number">1</span>, ie);</span><br><span class="line">        <span class="keyword">return</span> treeNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17. 树的子结构"></a>17. 树的子结构</h3><p><strong><em>题目描述</em></strong><br>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;  <span class="comment">//此时Tree2先遍历完，证明是子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) &#123;  <span class="comment">//此时Tree1先遍历完，证明不是子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1.val == root2.val &amp;&amp; isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18. 二叉树的镜像"></a>18. 二叉树的镜像</h3><p><strong><em>题目描述</em></strong><br>操作给定的二叉树，将其变换为源二叉树的镜像。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入描述:</span></span><br><span class="line"><span class="comment">二叉树的镜像定义：</span></span><br><span class="line"><span class="comment">		源二叉树</span></span><br><span class="line"><span class="comment">    	    8</span></span><br><span class="line"><span class="comment">    	   / \</span></span><br><span class="line"><span class="comment">    	  6   10</span></span><br><span class="line"><span class="comment">    	 / \  / \</span></span><br><span class="line"><span class="comment">    	5  7 9  11</span></span><br><span class="line"><span class="comment">    	镜像二叉树</span></span><br><span class="line"><span class="comment">    	    8</span></span><br><span class="line"><span class="comment">    	   / \</span></span><br><span class="line"><span class="comment">    	  10   6</span></span><br><span class="line"><span class="comment">    	 / \  / \</span></span><br><span class="line"><span class="comment">    	11 9 7  5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22. 从上往下打印二叉树"></a>22. 从上往下打印二叉树</h3><p>题目描述<br>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：使用队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：不使用队列 (使用ArrayList模拟队列)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = list.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38. 二叉树的深度"></a>38. 二叉树的深度</h3><p><strong><em>题目描述</em></strong><br>输入一棵二叉树，求该树的深度。<br>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br>时间限制：1秒 空间限制：32768K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(TreeDepth(root.left) + <span class="number">1</span>, TreeDepth(root.right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60. 把二叉树打印成多行"></a>60. 把二叉树打印成多行</h3><p><strong><em>题目描述</em></strong><br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        depth(pRoot, <span class="number">1</span>, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">depth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; list.size()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        list.get(depth-<span class="number">1</span>).add(root.val);</span><br><span class="line">        depth(root.left, depth + <span class="number">1</span>, list);</span><br><span class="line">        depth(root.right, depth + <span class="number">1</span>, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer(三) 栈和队列</title>
    <url>/2020/02/26/%E5%89%91%E6%8C%87Offer-3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5. 用两个栈实现队列"></a>5. 用两个栈实现队列</h3><p><strong><em>题目描述</em></strong><br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 队列 栈</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20. 包含min函数的栈"></a>20. 包含min函数的栈</h3><p><strong><em>题目描述</em></strong><br>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; smin = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        st.push(node);</span><br><span class="line">        <span class="keyword">if</span> (smin.empty()) &#123;</span><br><span class="line">            smin.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node &lt; smin.peek()) &#123;</span><br><span class="line">            smin.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st.peek() == smin.peek()) &#123;</span><br><span class="line">            smin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> smin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21. 栈的压入、弹出序列"></a>21. 栈的压入、弹出序列</h3><p><strong><em>题目描述</em></strong><br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。<br>假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，<br>但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：使用栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pushA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> popA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span> &amp;&amp; stack.peek() == popA[j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不使用栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pushA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> popA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder1</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pushA[i] != popA[j]) &#123;</span><br><span class="line">                arrayList.add(pushA[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrayList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrayList.get(i) != popA[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Android四大组件之Service</title>
    <url>/2020/02/26/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BService/</url>
    <content><![CDATA[<p>　　<strong>服务（Service）</strong> 是一种可以在后台执行长时间运行操作而没有用户界面的应用组件。<br>　　比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。
　　</p>
<a id="more"></a>
<p><strong>注意：</strong></p>
<ol>
<li><strong>Service默认运行在UI线程（主线程）中， 因此， 不要在Service中执行耗时的操作。</strong>　除非在Service中创建子线程。</li>
<li>Android的后台就是指它的运行是完全不依赖UI（线程）。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。</li>
</ol>
<h2 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h2><p><img src="/images/img_service_life_cycle.png" alt="img_service_life_cycle"></p>
<h3 id="1-startService-stopService"><a href="#1-startService-stopService" class="headerlink" title="1.startService / stopService"></a>1.startService / stopService</h3><p><strong>生命周期顺序： onCreate-&gt;onStartCommand-&gt;onDestroy</strong><br>　　如果一个Service被某个Activity 调用 Context.startService方法启动， 那么不管是否有Activity使用bindService绑定或unbindService解除绑定到该Service， 该Service都在后台运行， 直到被调用stopService， 或自身的stopSelf方法。 当然如果系统资源不足， android系统也可能结束服务， 还有一种方法可以关闭服务， 在设置中， 通过应用-&gt;找到自己应用-&gt;停止。<br><strong>注意点：</strong><br>①第一次 startService 会触发 onCreate 和 onStartCommand， 以后在服务运行过程中， 每次 startService 都<strong>只会触发 onStartCommand</strong><br>②不论 startService 多少次， stopService 一次就会停止服务</p>
<h3 id="2-bindService-unbindService"><a href="#2-bindService-unbindService" class="headerlink" title="2.bindService / unbindService"></a>2.bindService / unbindService</h3><p><strong>生命周期顺序： onCreate-&gt;onBind-&gt;onUnBind-&gt;onDestroy</strong><br>　　如果一个Service在某个Activity中被调用bindService方法启动， 不论bindService被调用几次， Service的onCreate方法只会执行一次， 同时onStartCommand方法始终不会调用。<br>当建立连接后， Service会一直运行， 除非调用unbindService来接触绑定、 断开连接或调用该Service的Context不存在了（如Activity被Finish——即<strong>通过bindService启动的Service的生命周期依附于启动它的Context</strong>）， 系统在这时会自动停止该Service。<br><strong>注意点：</strong><br>第一次 bindService 会触发 onCreate 和 onBind， 以后在服务运行过程中， 每次 bindService 都<strong>不会触发任何回调</strong></p>
<h3 id="3-混合型（上面两种方式的交互）"><a href="#3-混合型（上面两种方式的交互）" class="headerlink" title="3.混合型（上面两种方式的交互）"></a>3.混合型（上面两种方式的交互）</h3><p>　　当一个Service在被启动(startService)的同时又被绑定(bindService)， 该Service将会一直在后台运行， 并且不管调用几次， onCreate方法始终只会调用一次， onStartCommand的调用次数与startService调用的次数一致（使用bindService方法不会调用onStartCommand）。 同时， 调用unBindService将不会停止Service， 必须调用stopService或Service自身的stopSelf来停止服务。</p>
<h2 id="二、类型"><a href="#二、类型" class="headerlink" title="二、类型"></a>二、类型</h2><h3 id="1-按运行位置："><a href="#1-按运行位置：" class="headerlink" title="1. 按运行位置："></a>1. 按运行位置：</h3><ul>
<li>本地服务（Local Service）：服务依附于主进程</li>
<li>远程服务（Remote Service）：服务为独立的进程<h3 id="2-按运行类型："><a href="#2-按运行类型：" class="headerlink" title="2. 按运行类型："></a>2. 按运行类型：</h3></li>
<li>前台服务：通知栏显示Notification，如天气更新、日期同步等</li>
<li>后台服务：通知栏不显示Notification，如音乐播放器<h3 id="3-按启动方式："><a href="#3-按启动方式：" class="headerlink" title="3. 按启动方式："></a>3. 按启动方式：</h3></li>
<li>startService启动的服务</li>
<li>bindService启动的服务</li>
<li>同时用两种方式启动的服务</li>
</ul>
<h2 id="三、Service和Thread的区别"><a href="#三、Service和Thread的区别" class="headerlink" title="三、Service和Thread的区别"></a>三、Service和Thread的区别</h2><p>　　本质上来说，两者没有任何关系，它们是完全不同的概念。</p>
<ol>
<li>定义上：</li>
</ol>
<ul>
<li>Thread：Thread是程序执行的最小单元，它是分配CPU的基本单位。可以用Thread来执行一些异步的操作。</li>
<li>Service：Service是android的一种机制，当它运行的时候如果是Local Service，那么对应的Service是运行在<strong>主进程的主线程上</strong>；如果是Remote Service，那么对应的Service则是运行在<strong>独立进程的主线程上</strong>。</li>
</ul>
<ol start="2">
<li>使用上：</li>
</ol>
<ul>
<li>Thread的运行是独立的，也就是说当一个Activity被finish之后，如果没有主动停止Thread或者Thread里的run方法没有执行完毕的话，Thread也会一直执行。 这样会导致的问题：1) 当Activity被finish之后，不再持有该Thread的引用，也就是不能再控制该Thread。2）没有办法在不同的Activity中对同一Thread进行控制。</li>
<li>所有的Activity都可以与Service进行关联，也就是说多个Activity可以同时控制同一个Service，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。</li>
</ul>
<p><strong>什么时候使用Service，什么时候使用Thread呢?</strong><br>（1）在应用中，如果是<strong>长时间的在后台运行，而且不需要交互</strong>的情况下，使用<strong>Service</strong>。<br>（2）在后台运行，不需要交互的情况下，如果只是完成某个任务，之后就不需要运行，而且可能是多个任务，需要长时间运行的情况下，使用<strong>Thread</strong>。<br>（3）如果任务占用CPU时间多，资源大的情况下，使用<strong>Thread</strong>。</p>
<h2 id="四、IntentService"><a href="#四、IntentService" class="headerlink" title="四、IntentService"></a>四、IntentService</h2><p> 　　继承于Service，内部有一个HandlerThread对象，可以看做是Service和HandlerThread的结合体。</p>
<h3 id="1-特点："><a href="#1-特点：" class="headerlink" title="1. 特点："></a>1. 特点：</h3><ul>
<li>在IntentService<strong>内有一个工作线程</strong>来处理耗时操作。</li>
<li>当任务执行完后，IntentService 会自动停止，不需要我们去手动结束。</li>
<li>如果启动 IntentService 多次，那么每一个耗时操作会以工作队列的方式在 IntentService 的 onHandleIntent 回调方法中执行，依次去执行，使用串行的方式，执行完自动结束。</li>
</ul>
<h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h3><p><img src="/images/img_service_intent_service.jpg" alt="img_service_intent_service"></p>
<p> <strong>注意：</strong> 若启动IntentService多次， 那么每个耗时操作则以队列的方式在IntentService的onHandleIntent回调方法中依次执行， 执行完自动结束。</p>
<p> <strong>启动IntentService为什么不需要新建线程？</strong><br>　　IntentService内部的HandlerThread继承自Thread，内部封装了Looper，在这里新建线程并启动，所以启动IntentService不需要新建线程。</p>
<p><strong>为什么多次启动 IntentService 会顺序执行事件，停止服务后，后续的事件得不到执行？</strong><br>　　IntentService 中使用的 Handler、Looper、MessageQueue 机制把消息发送到线程中去执行的，所以<strong>多次启动IntentService不会重新创建新的服务和新的线程</strong>，只是把消息加入消息队列中等待执行，而如果服务停止，会清除消息队列中的消息，后续的事件得不到执行。</p>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><ul>
<li>线程任务需要按顺序、 在后台执行的使用场景</li>
</ul>
<p><em>最常见的场景：离线下载</em></p>
<ul>
<li>由于所有的任务都在同一个Thread looper里面来做， 所以不符合多个数据同时请求的场景。</li>
</ul>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android四大组件之Activity</title>
    <url>/2020/02/26/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity/</url>
    <content><![CDATA[<p>　　<strong>活动（Activity）</strong> 是一种可以包含用户界面的组件，主要用于和用户进行交互。</p>
<a id="more"></a>

<h2 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h2><p><img src="/images/img_activity_life_cycle.jpg" alt="img_activity_life_cycle"></p>
<p>同时，生命周期也对应了Activity的<strong>四种状态</strong>：</p>
<p>1) 运行状态(Running)<br>2) 暂停状态(Paused)<br>3) 停止状态(Stopped)<br>4) 销毁状态(Killed)</p>
<p><strong>注意</strong><br>onStart()和onResume()区别：</p>
<ul>
<li>onStart()：前台不可见，不能进行交互</li>
<li>onResume()：前台可见，可以进行交互</li>
</ul>
<h3 id="特定场景下的生命周期回调："><a href="#特定场景下的生命周期回调：" class="headerlink" title="特定场景下的生命周期回调："></a>特定场景下的生命周期回调：</h3><p>（1）用户打开新的Activiy的时候，之前的Activity： onPause()-&gt;onStop()<br>（2）按Back键回退时： onPause()-&gt;onStop()-&gt;onDestory()<br>（3）按Home键切换到桌面后又回到该Actitivy： onPause()-&gt;onStop()-&gt;onRestart()-&gt;onStart()-&gt;onResume()<br>（4）调用finish()方法： onDestory()<br>（5）横竖屏切换：onPause()-&gt;onSaveInstanceState()-&gt; onStop()-&gt;onDestroy()-&gt;onCreate()-&gt;onStart()-&gt;onRestoreInstanceState()-&gt;onResume()</p>
<h4 id="onSaveInstanceState和onRestoreInstanceState"><a href="#onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="onSaveInstanceState和onRestoreInstanceState"></a>onSaveInstanceState和onRestoreInstanceState</h4><p>　　在Activity由于异常情况下终止时， 系统会调用<strong>onSaveInstanceState</strong>来保存当前Activity的状态。 当异常终止的Activity被重建以后， 系统会调用<strong>onRestoreInstanceState</strong>， 并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象参数同时传递给onRestoreInstanceState和onCreate方法。<br>onCreate和onRestoreInstanceState方法来恢复Activity的状态的区别：<br>onRestoreInstanceState回调则表明其中Bundle对象非空， 不用加非空判断； onCreate需要非空判断。 建议使用onRestoreInstanceState。<br><strong>调用时机：</strong></p>
<ul>
<li>onSaveInstanceState()：onStop()之前</li>
<li>onRestoreInstanceState()：onStart()之后</li>
</ul>
<p>通过在AndroidManifest文件的Activity中指定如下属性：</p>
<blockquote>
<p>android:configChanges = “orientation|screenSize”</p>
</blockquote>
<p>来避免横竖屏切换时， Activity的销毁和重建。<br>而是回调了下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、启动模式"><a href="#二、启动模式" class="headerlink" title="二、启动模式"></a>二、启动模式</h2><h3 id="1-标准模式（Standard）"><a href="#1-标准模式（Standard）" class="headerlink" title="1. 标准模式（Standard）"></a>1. 标准模式（Standard）</h3><p>　　每启动一次Activity，就会创建一个新的Activity实例并置于栈顶。</p>
<h3 id="2-栈顶复用模式（SingleTop）"><a href="#2-栈顶复用模式（SingleTop）" class="headerlink" title="2. 栈顶复用模式（SingleTop）"></a>2. 栈顶复用模式（SingleTop）</h3><p>　　如果需要新建的Activity位于任务栈栈顶，那么此Activity的实例就不会重建，而是重用栈顶的实例。<br><strong>应用场景：</strong><br>（1）在通知栏点击收到的通知，然后需要启动一个Activity，这个Activity就可以用singleTop，否则每次点击都会新建一个Activity。<br>（2）某个场景下连续快速点击，启动了两个Activity。如果这个时候待启动的Activity使用SingleTop模式可以避免这个Bug。</p>
<h3 id="3-栈内复用模式（SingleTask）"><a href="#3-栈内复用模式（SingleTask）" class="headerlink" title="3. 栈内复用模式（SingleTask）"></a>3. 栈内复用模式（SingleTask）</h3><p>　　该模式是一种<strong>单例模式</strong>，即<strong>一个栈内只有一个该Activity实例</strong>。该模式可以通过在AndroidManifest文件中Activity的android:taskAffinity属性的需要加载到那个栈中。<br>　　如果Activity指定的栈不存在，则创建一个栈，并把创建的Activity压入栈内。如果Activity指定的栈存在，如果其中没有该Activity实例，则会创建Activity并压入栈顶，如果其中有该Activity实例，则把该Activity实例之上的Activity清除出栈，重用并让该Activity实例处在栈顶。<br><strong>应用场景：</strong><br>　　大多数App的主页。对于大部分应用，当我们在主界面点击回退按钮的时候都是退出应用，那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，主界面Activity上所有的Activity都会被移除，从而主界面Activity处于栈顶。通过这种方式能够保证退出应用时所有的Activity都能销毁。</p>
<h3 id="4-单例模式（SingleInstance）"><a href="#4-单例模式（SingleInstance）" class="headerlink" title="4. 单例模式（SingleInstance）"></a>4. 单例模式（SingleInstance）</h3><p>　　一个栈中只有一个Activity的实例。<br>　　一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例。<br><strong>应用场景：</strong><br>　　呼叫来电界面</p>
<h4 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="* 特殊情况："></a>* 特殊情况：</h4><ol>
<li><p>前台栈和后台栈的交互<br>假如目前有两个任务栈。 前台任务栈为AB， 后台任务栈为CD， 这里假设CD的启动模式均为SingleTask,现在请求启动D， 那么这个后台的任务栈都会被切换到前台，这个时候整个后退列表就变成了ABCD。 当用户按Back返回时， 列表中的Activity会一一出栈， 如下图：<br><img src="/images/img_activity_1.jpg" alt="img_activity_1"><br>如果不是请求启动D而是启动C， 那么情况又不一样， 如下图：<br><img src="/images/img_activity_2.jpg" alt="img_activity_2"><br>　　<strong>调用SingleTask模式的后台任务栈中的Activity， 会把整个栈的Actvity压入当前栈的栈顶。</strong> SingleTask会具有ClearTop特性， 把之上的栈内Activity清除。</p>
</li>
<li><p>SingleInstance深入理解<br>（1）A：Standard  B：SingleInstance<br> 启动顺序：A -&gt; B -&gt; A<br> 回退顺序：A -&gt; A -&gt; B<br>（2）A：Standard  B：SingleInstance C：Standard<br> 启动顺序：A -&gt; B -&gt; C<br> 回退顺序：C -&gt; A -&gt; B</p>
</li>
</ol>
<p><strong>注意：</strong> 回退是按照该栈的压入顺序进行的，而不是按照启动顺序进行。</p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱(三) Android进阶知识</title>
    <url>/2020/02/26/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-3-Android%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><img src="/images/img_mind_map_android_2.png" alt="img_mind_map_android_2"></p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>脑图</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱(二) Android基础知识</title>
    <url>/2020/02/26/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-2-Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><img src="/images/img_mind_map_android_1.png" alt="img_mind_map_android_1"></p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>脑图</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱(一) Android工程师知识图谱</title>
    <url>/2020/02/26/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-1-Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<p><img src="/images/img_mind_map_all.png" alt="img_mind_map_all"></p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>脑图</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer(二) 链表</title>
    <url>/2020/02/25/%E5%89%91%E6%8C%87Offer-2-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="3-从头到尾打印链表"><a href="#3-从头到尾打印链表" class="headerlink" title="3. 从头到尾打印链表"></a>3. 从头到尾打印链表</h3><p><strong><em>题目描述</em></strong><br>输入一个链表，从尾到头打印链表每个节点的值。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1： 递归实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//递归求解结果必须声明为全局</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            result.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2： 利用数据结构 栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead1</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            arrayList.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15. 反转链表"></a>15. 反转链表</h3><p><strong><em>题目描述</em></strong><br>输入一个链表，反转链表后，输出链表的所有元素。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1： 使用数据结构 栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            <span class="comment">//方法1：</span></span><br><span class="line"><span class="comment">//            p.next = stack.peek();  //取栈的栈顶元素， 但并不出栈</span></span><br><span class="line"><span class="comment">//            p = p.next;</span></span><br><span class="line"><span class="comment">//            stack.pop();</span></span><br><span class="line">            <span class="comment">//方法2：</span></span><br><span class="line">            p.next = stack.pop();</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = ReverseList1(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;  <span class="comment">// 断开现在的结点连接</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法3：传统方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode temp = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16. 合并两个排序的链表"></a>16. 合并两个排序的链表</h3><p><strong><em>题目描述</em></strong><br>输入两个<strong>单调递增</strong>的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足<strong>单调不减</strong>规则。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode list = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">            list = list1;</span><br><span class="line">            list.next = Merge(list1.next, list2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list = list2;</span><br><span class="line">            list.next = Merge(list1, list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge1</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode list = <span class="keyword">null</span>;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    temp = list1;</span><br><span class="line">                    list = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.next = list1;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    temp = list2;</span><br><span class="line">                    list = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.next = list2;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36. 两个链表的第一个公共结点"></a>36. 两个链表的第一个公共结点</h3><p><strong><em>题目描述</em></strong><br>输入两个链表，找出它们的第一个公共结点。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = (p1 == <span class="keyword">null</span> ? pHead2 : p1.next);</span><br><span class="line">            p2 = (p2 == <span class="keyword">null</span> ? pHead1 : p2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55. 链表中环的入口结点"></a>55. 链表中环的入口结点</h3><p><strong><em>题目描述</em></strong><br>一个链表中包含环，请找出该链表的环的入口结点。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表<br><strong>分析：</strong><br><strong>设置快慢指针方法</strong><br>设置一个<strong>慢指针每次走1步</strong>，一个<strong>快指针每次走2步</strong>，如果有环，一定会在<strong>环内相遇</strong>。<br>然后让一个指针回到起点，<strong>起点开始走</strong>，让一个指针从<strong>相遇点开始继续往后走</strong>，两个指针速度一样。<br>那么，两者恰好在<strong>环的入口点相遇</strong>。如图：</p>
<p><img src="/images/img_offer_list.png" alt="img_offer_list"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用HashSet存储结点</span></span><br><span class="line"><span class="comment">   * 如果已经存在，这个结点就是入环结点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pHead</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(pHead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(pHead)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pHead;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(pHead);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置快慢指针</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(pHead == <span class="keyword">null</span>|| pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         ListNode node1 = pHead.next;</span><br><span class="line">         ListNode node2 = pHead.next.next;</span><br><span class="line">         <span class="keyword">while</span>(node1 != node2) &#123;</span><br><span class="line">             <span class="keyword">if</span>(node1.next != <span class="keyword">null</span> &amp;&amp; node2.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 node1 = node1.next;</span><br><span class="line">                 node2 = node2.next.next;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         node1 = pHead;</span><br><span class="line">         <span class="keyword">while</span>(node1 != node2) &#123;</span><br><span class="line">             node1 = node1.next;</span><br><span class="line">             node2 = node2.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> node1;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56. 删除链表中重复的结点"></a>56. 删除链表中重复的结点</h3><p><strong><em>题目描述</em></strong><br>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，<br>重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode first = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);  <span class="comment">//添加一个头结点，这样可以保证逻辑的连贯性</span></span><br><span class="line">        first.next = pHead;</span><br><span class="line">        ListNode p = pHead;</span><br><span class="line">        ListNode last = first;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val == p.next.val) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = p.val;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; val == p.val) &#123;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">                last.next = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer(一) 数组和字符串</title>
    <url>/2020/02/25/%E5%89%91%E6%8C%87Offer-1-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="1-二维数组的查找"><a href="#1-二维数组的查找" class="headerlink" title="1. 二维数组的查找"></a>1. 二维数组的查找</h3><p><strong><em>题目描述</em></strong><br>在一个二维数组中，每一行都按照<strong>从左到右递增</strong>的顺序排序，<br>每一列都按照<strong>从上到下递增</strong>的顺序排序。<br>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<a id="more"></a>

<p>时间限制：1秒 空间限制：32768K<br>本题知识点： 查找</p>
<p><strong>解题关键：</strong> 行列同时从不同方向进行查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">0</span> || array[<span class="number">0</span>].length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = array.length;</span><br><span class="line">        <span class="keyword">int</span> cols = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = cols - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= rows - <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;  <span class="comment">//注意：使用while循环</span></span><br><span class="line">            <span class="keyword">if</span> (target == array[i][j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; array[i][j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h3><p><strong><em>题目描述</em></strong><br>请实现一个函数，将一个字符串中的空格替换成“%20”。<br>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 字符串<br><strong>注意：</strong><br>实际上这个题考察的是单个字符在数组中的位置，<br>需要进行数组的遍历和复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：利用String的replaceAll函数直接字符串替换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  str.toString().replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：利用StringBuffer重新进行字符串的拼接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace1</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = str.toString();</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                result.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法3：新创建一个数组，进行数组元素的复制（技巧：从后向前进行数组的复制）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace2</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toString().toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        <span class="comment">//减少空间开销，求出替换后的数组长度</span></span><br><span class="line">        <span class="keyword">int</span> newLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                newLen += <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newLen++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] copys = <span class="keyword">new</span> <span class="keyword">char</span>[newLen];</span><br><span class="line">        <span class="keyword">int</span> j = newLen - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                copys[j--] = <span class="string">'0'</span>;</span><br><span class="line">                copys[j--] = <span class="string">'2'</span>;</span><br><span class="line">                copys[j--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                copys[j--] = chars[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(copys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h3><p><strong><em>题目描述</em></strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个<strong>非递减</strong>排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br>时间限制：3秒 空间限制：32768K<br>本题知识点： 查找<br><strong>注意：</strong><br>题目中隐含的条件，首先数组的旋转只是变换一次，<br>因此旋转数组的最小元素一定位于数组的中间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：排序，输出最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：采用二分法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray1</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//待旋转的数组一定满足： array[start] &gt;= array[end]</span></span><br><span class="line">        <span class="keyword">while</span> (array[start] &gt;= array[end]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> array[end];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt;= array[start]) &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt;= array[end]) &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13. 调整数组顺序使奇数位于偶数前面"></a>13. 调整数组顺序使奇数位于偶数前面</h3><p><strong><em>题目描述</em></strong><br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，<br>使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，<br>并保证奇数和奇数，偶数和偶数之间的<strong>相对位置不变</strong>。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test13</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：数组实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = res[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：队列实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray1</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变形： 不考虑顺序的情况，只需要一次遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray2</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; array[start] % <span class="number">2</span> == <span class="number">1</span>) &#123;  <span class="comment">//找偶数</span></span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; array[end] % <span class="number">2</span> == <span class="number">0</span>)&#123;  <span class="comment">//找奇数</span></span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = array[start];</span><br><span class="line">            array[start] = array[end];</span><br><span class="line">            array[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19. 顺时针打印矩阵"></a>19. 顺时针打印矩阵</h3><p><strong><em>题目描述</em></strong><br>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，<br>例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16<br>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1   2   3   4</span></span><br><span class="line"><span class="comment"> 5   6   7   8</span></span><br><span class="line"><span class="comment"> 9   10  11  12</span></span><br><span class="line"><span class="comment"> 13  14  15  16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：根据圈数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt; <span class="number">0</span> || matrix[<span class="number">0</span>].length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> circle = ((row &lt; col ? row : col) - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">//根据规律可知</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;circle; i++) &#123;</span><br><span class="line">            <span class="comment">//左-&gt;右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;col-i; j++)</span><br><span class="line">                result.add(matrix[i][j]);</span><br><span class="line">            <span class="comment">//上-&gt;下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>; k&lt;row-i; k++)</span><br><span class="line">                result.add(matrix[k][col-<span class="number">1</span>-i]);</span><br><span class="line">            <span class="comment">//右-&gt;左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m = col-i-<span class="number">2</span>; (m&gt;=i)&amp;&amp;(row-i-<span class="number">1</span>!=i); m--)</span><br><span class="line">                result.add(matrix[row-i-<span class="number">1</span>][m]);</span><br><span class="line">            <span class="comment">//下-&gt;上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n = row-i-<span class="number">2</span>; (n&gt;i)&amp;&amp;(col-i-<span class="number">1</span>!=i); n--)</span><br><span class="line">                result.add(matrix[n][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：限定边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix2</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt; <span class="number">0</span> || matrix[<span class="number">0</span>].length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, top = <span class="number">0</span>, right = col - <span class="number">1</span>, bottom = row - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="comment">// 左 -&gt; 右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                result.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上 -&gt; 下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class="line">                result.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右 -&gt; 左</span></span><br><span class="line">            <span class="keyword">if</span> (top != bottom) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">                    result.add(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下 -&gt; 上</span></span><br><span class="line">            <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; i--) &#123;</span><br><span class="line">                    result.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            top++;</span><br><span class="line">            right--;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29-最小的k个数"><a href="#29-最小的k个数" class="headerlink" title="29. 最小的k个数"></a>29. 最小的k个数</h3><p><strong><em>题目描述</em></strong><br>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(input);  <span class="comment">//数组快排</span></span><br><span class="line"><span class="comment">//        Collections.sort(list);  //链表快排</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34. 第一个只出现一次的字符"></a>34. 第一个只出现一次的字符</h3><p><strong><em>题目描述</em></strong><br>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(str.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">int</span> value = hashMap.get(str.charAt(i));</span><br><span class="line">                hashMap.put(str.charAt(i), value + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(str.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.get(str.charAt(i)) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="42-和为S的两个数字"><a href="#42-和为S的两个数字" class="headerlink" title="42. 和为S的两个数字"></a>42. 和为S的两个数字</h3><p><strong><em>题目描述</em></strong><br>输入一个<strong>递增</strong>排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br>输出描述:<br>对应每个测试案例，输出两个数，小的先输出。<br>时间限制：1秒 空间限制：32768K</p>
<p><strong>解题关键：</strong> 对于已排序数组来说，越靠近中间，乘积越大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[left] + array[right] &lt; sum) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[left] + array[right] &gt; sum) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.add(array[left]);</span><br><span class="line">                result.add(array[right]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44. 翻转单词顺序列"></a>44. 翻转单词顺序列</h3><p><strong><em>题目描述</em></strong><br>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。<br>同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student a am I”。<br>后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。<br>Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span> || str.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        String[] subStrs = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = subStrs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">//            StringBuilder builder = new StringBuilder(subStrs[i]);</span></span><br><span class="line"><span class="comment">//            result += builder.reverse().toString() + " ";  //tneduts a ma I</span></span><br><span class="line">            result += subStrs[i] + <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java 总结</title>
    <url>/2020/02/24/Effective-Java-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>本专栏文章为《Effective Java》一书内容的总结提炼。该书总结了优秀Java程序员必备的78条经验总结，这些经验总结针对Java程序员每天都会遇到的编程问题提出了最有效、最实用的解决方案。每条经验总结都详细阐明了应该怎么做，不应该怎么做，以及这样做的原因。</p>
</blockquote>
<a id="more"></a>

<p>　　同《Java编程思想》一样，本书也是Java编程的必读书目之一，熟练掌握书中的各条经验总结，必将大幅提高编码水平。书中有些经验总结，并不仅仅只对Java有效，对其他面向对象语言也是适用的。</p>
<p>　　本书的作者Joshua Bloch 带队设计过Java平台的许多特性，尤其是主导并实现了JDK5.0中的Java集合框架，因此，学习他的经验总结，对更好地阅读并理解JDK源码也是大有裨益的。</p>
<p><strong>思维导图：</strong></p>
<p><img src="/images/img_effective_java.png" alt="img_effective_java"></p>
<p>　　<em>本文主要是为了测试博客效果，要想查看完整内容，请前往我的CSDN专栏！</em></p>
<p><strong>CSDN专栏：<a href="https://blog.csdn.net/qq_34519487/category_9710430.html" target="_blank" rel="noopener">Effective Java</a></strong></p>
<p><a href="https://blog.csdn.net/qq_34519487/article/details/104252662" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
