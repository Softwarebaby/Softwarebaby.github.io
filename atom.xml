<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flow Garden</title>
  
  <subtitle>Bob Du&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lvmdu.gitee.io/"/>
  <updated>2020-03-01T08:10:56.010Z</updated>
  <id>https://lvmdu.gitee.io/</id>
  
  <author>
    <name>Bob Du</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开源框架（二） 依赖注入框架</title>
    <link href="https://lvmdu.gitee.io/2020/03/01/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-2-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/"/>
    <id>https://lvmdu.gitee.io/2020/03/01/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-2-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/</id>
    <published>2020-03-01T03:49:00.000Z</published>
    <updated>2020-03-01T08:10:56.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ButterKnife"><a href="#一、ButterKnife" class="headerlink" title="一、ButterKnife"></a>一、ButterKnife</h2><p>　　从严格意义讲不算是依赖注入框架， 它只是专注于Android系统的View注入框架， 并不支持其他方面的注入。 它可以减少大量的findViewById（@BindView）以及setOnClickListener（@OnClick）代码， 简化代码并提升开发效率。</p><a id="more"></a><p>　　ButterKnife 采用的是<strong>编译时注解</strong>。</p><ul><li>ButterKnife.bind(this)：根据Activity对应的Class得到一个继承了Unbinder的Constructor，最后通过<strong>反射</strong>constructor.newInstance(target, source)得到Unbinder子类的一个新的实例（MainActivity_ViewBinding的实例）。其中获取Constructor是通过LinkedHashMap缓存了对应的Class和Constructor以提高效率。</li><li>注解处理器：通过注解处理器，将source值、ID等参数传入MainActivity_ViewBinding的findRequiredViewAsType方法，在该方法内部调用了findRequiredView方法，findRequiredView方法又调用了DecorView的findViewById方法并将R.id.tv_text对应的View返回。接着findRequiredViewAsType方法调用castView方法，将View强制转换成传入的Class值的类型（即对应的View.class），最终强制转换为对应的组件并返回，MainActivity_ViewBinding辅助类会把这个返回的组件会赋值给target，也就是MainActivity，这样在MainActivity就可以使用这个组件了。</li></ul><h2 id="二、Dagger"><a href="#二、Dagger" class="headerlink" title="二、Dagger"></a>二、Dagger</h2><p>　　Dagger是一个基于Java依赖注入标准的依赖注入框架， 在编译期间自动生成代码， 负责依赖对象的创建。</p><h3 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p>（1）创建Module容器（类），它的作用是提供实例化的对象，需要添加 @Module 注解。同时，创建提供实体类实例的方法并添加 @Provides 注解。<br>（2）创建Component连接件（接口），它是沟通调用者和容器的桥梁，需要添加 @Component 注解，并且用注解的modules属性指明作为容器的类。并在Component中定义抽象的inject注入方法。<br>（3）Rebuild项目，这时Dagger框架会自动创建一个以Dagger-开头的辅助类（DaggerMainComponent）。<br>（4）调用者首先使用DaggerMainComponent采用Builder模式来创建一个DaggerMainComponent的实例，需要传入一个Module容器的实例。接着调用inject方法将调用者注入。<br>（5）在调用者类中，声明一个实体类的变量，使用 @Inject 注解标记，即可获得该实体类的实例。</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>　　DaggerMainComponent重写了MainComponent接口的inject()方法，里边调用的injectMainActivity()方法是完成依赖注入的关键。它会调用生成的MainActivity_MembersInjector类，这个类中会将实例提供给被注入的Activity，而实例的生成则是通过另一个生成的MainModule_ProvideXxxxFactory来实现的，这个Factory中传入了我们创建的Module容器，并在里面调用我们所创建的provide实体的方法。最终就完成了实例的创建和注入，归根到底所创建的实例还是我们在Module里面定义和创建的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、ButterKnife&quot;&gt;&lt;a href=&quot;#一、ButterKnife&quot; class=&quot;headerlink&quot; title=&quot;一、ButterKnife&quot;&gt;&lt;/a&gt;一、ButterKnife&lt;/h2&gt;&lt;p&gt;　　从严格意义讲不算是依赖注入框架， 它只是专注于Android系统的View注入框架， 并不支持其他方面的注入。 它可以减少大量的findViewById（@BindView）以及setOnClickListener（@OnClick）代码， 简化代码并提升开发效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://lvmdu.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>开源框架（一） 网络框架</title>
    <link href="https://lvmdu.gitee.io/2020/03/01/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-1-%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    <id>https://lvmdu.gitee.io/2020/03/01/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-1-%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</id>
    <published>2020-03-01T02:40:00.000Z</published>
    <updated>2020-03-01T03:59:56.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Volley"><a href="#一、Volley" class="headerlink" title="一、Volley"></a>一、Volley</h2><h3 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p>（1）通过Volley.newRequestQueue获取一个RequestQueue对象<br>（2）创建一个Request(StringRequest/JsonRequest/ImageRequest)对象<br>（3）将Request对象通过add方法添加到RequestQueue中</p><a id="more"></a><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p><img src="/images/img_volley.png" alt="img_volley"></p><h2 id="二-OkHttp"><a href="#二-OkHttp" class="headerlink" title="二. OkHttp"></a>二. OkHttp</h2><h3 id="1-使用方法-1"><a href="#1-使用方法-1" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p>（1）通过Request.Builder创建一个Request对象<br>（2）创建一个OkHttpClient对象<br>（3）将Request传入OkHttpClient对象中(mOkHttpClient.newCall(request))，来创建一个Call对象<br>（4）调用Call对象的execute(同步)/enqueue(异步)方法来执行</p><h3 id="2-原理-1"><a href="#2-原理-1" class="headerlink" title="2. 原理"></a>2. 原理</h3><p><img src="/images/img_okhttp.png" alt="img_okhttp"></p><h2 id="三、Retrofit"><a href="#三、Retrofit" class="headerlink" title="三、Retrofit"></a>三、Retrofit</h2><h3 id="1-使用方法-2"><a href="#1-使用方法-2" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p><strong>一般用法：</strong><br>（1）定义请求接口类，使用@GET/@POST注解注解编写网络请求接口<br>（2）使用Buider模式创建Retrofit实例<br>（3）通过Retrofit对象的create方法传入之前的请求接口类，来创建请求实体对象<br>（4）调用请求对象的请求方法生成能够发起网络请求的Call对象<br>（5）调用Call对象的enqueue方法发起异步网络请求</p><p><strong>高级用法：</strong><br>适配OkHttpCall的Factory：<br>（1）定义请求接口类，使用@GET/@POST注解编写网络请求接口<br>（2）使用单例模式创建一个RetrofitFactory<br>（3）在RetrofitFactory内部创建一个OkHttpClient，并通过Builder模式利用OkHttpClient来创建一个Retrofit实例<br>（4）通过Retrofit对象的create方法传入之前的请求接口类，来创建请求实体对象<br>（5）客户端通过RetroFactory来调用请求对象的请求方法生成能够发起网络请求的Call对象<br>（6）调用Call对象的enqueue方法发起异步网络请求</p><h3 id="2-原理-2"><a href="#2-原理-2" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>　　Retrofit的create方法通过<strong>动态代理</strong>的模式，生成了实现了具体的网络请求接口的对象，并在InvocationHandler的invoke方法中统一处理网络请求接口实体对象的方法，根据方法生成一个ServiceMethod对象，并将其放入缓存中，然后根据ServiceMethod对象和网络请求的参数去构造一个OkHttpCall对象，最后调用serviceMethod的callAdapter的adapt方法，传入将OkHttpCall对象。（callAdapter的目的主要是为了适配OkHttpCall对象，其内部会对OkHttpCall对象进行包装，生成对应返回类型的对象。）底层真正处理网络请求的还是OkHttp框架。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Volley&quot;&gt;&lt;a href=&quot;#一、Volley&quot; class=&quot;headerlink&quot; title=&quot;一、Volley&quot;&gt;&lt;/a&gt;一、Volley&lt;/h2&gt;&lt;h3 id=&quot;1-使用方法&quot;&gt;&lt;a href=&quot;#1-使用方法&quot; class=&quot;headerlink&quot; title=&quot;1. 使用方法&quot;&gt;&lt;/a&gt;1. 使用方法&lt;/h3&gt;&lt;p&gt;（1）通过Volley.newRequestQueue获取一个RequestQueue对象&lt;br&gt;（2）创建一个Request(StringRequest/JsonRequest/ImageRequest)对象&lt;br&gt;（3）将Request对象通过add方法添加到RequestQueue中&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://lvmdu.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android新特性</title>
    <link href="https://lvmdu.gitee.io/2020/02/29/Android%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://lvmdu.gitee.io/2020/02/29/Android%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-02-29T13:07:00.000Z</published>
    <updated>2020-02-29T13:54:05.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Android-5-0-新特性"><a href="#一、Android-5-0-新特性" class="headerlink" title="一、Android 5.0 新特性"></a>一、Android 5.0 新特性</h2><ol><li>全新的 Material Design 设计风格</li><li>引入 RecyclerView 代替 ListView</li><li>增加不重要通知隐藏功能</li><li>ART 虚拟机代替了 Dalvik 虚拟机</li><li>多任务视图</li></ol><a id="more"></a><h2 id="二、Android-6-0-新特性"><a href="#二、Android-6-0-新特性" class="headerlink" title="二、Android 6.0 新特性"></a>二、Android 6.0 新特性</h2><ol><li>运行时权限</li><li>集成了Android Pay</li><li>指纹支持</li><li>Doze 电量管理</li></ol><h2 id="三、Android-7-0-新特性"><a href="#三、Android-7-0-新特性" class="headerlink" title="三、Android 7.0 新特性"></a>三、Android 7.0 新特性</h2><ol><li>多窗口模式</li><li>Data Saver（流量保护机制）</li><li>支持Java 8</li><li>通知栏快速回复</li><li>通知栏快捷开关</li></ol><h2 id="四、Android-8-0-新特性"><a href="#四、Android-8-0-新特性" class="headerlink" title="四、Android 8.0 新特性"></a>四、Android 8.0 新特性</h2><ol><li>Notification Channel（通知渠道）</li><li>PIP（画中画模式）</li><li>自适应图标</li><li>长按图标弹出子菜单</li><li>权限新增安装权限</li><li>电量优化（大部分静态注册广播失效）</li></ol><h2 id="五、Android-9-0-新特性"><a href="#五、Android-9-0-新特性" class="headerlink" title="五、Android 9.0 新特性"></a>五、Android 9.0 新特性</h2><ol><li>全面屏支持</li><li>多摄像头支持</li><li>手势操作</li><li>增加黑夜模式</li><li>设置应用程序时间限制</li><li>基于人工智能的电量自适应和亮度自适应</li></ol><h2 id="六、Android-10-0-新特性"><a href="#六、Android-10-0-新特性" class="headerlink" title="六、Android 10.0 新特性"></a>六、Android 10.0 新特性</h2><ol><li>可折叠的应用程序</li><li>5G 网络</li><li>基于人工智能的回复操作</li><li>可适用于系统和应用的暗黑主题</li><li>类似于PC的桌面模式</li><li>面部识别</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Android-5-0-新特性&quot;&gt;&lt;a href=&quot;#一、Android-5-0-新特性&quot; class=&quot;headerlink&quot; title=&quot;一、Android 5.0 新特性&quot;&gt;&lt;/a&gt;一、Android 5.0 新特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;全新的 Material Design 设计风格&lt;/li&gt;
&lt;li&gt;引入 RecyclerView 代替 ListView&lt;/li&gt;
&lt;li&gt;增加不重要通知隐藏功能&lt;/li&gt;
&lt;li&gt;ART 虚拟机代替了 Dalvik 虚拟机&lt;/li&gt;
&lt;li&gt;多任务视图&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://lvmdu.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android内存泄漏</title>
    <link href="https://lvmdu.gitee.io/2020/02/29/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://lvmdu.gitee.io/2020/02/29/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2020-02-29T08:19:00.000Z</published>
    <updated>2020-03-01T01:03:43.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ANR"><a href="#一、ANR" class="headerlink" title="一、ANR"></a>一、ANR</h2><h3 id="1-什么是ANR？"><a href="#1-什么是ANR？" class="headerlink" title="1. 什么是ANR？"></a>1. 什么是ANR？</h3><p>　　<strong>ANR</strong> 即Application Not Responding，它是一个提示“应用程序无响应”的对话框。</p><a id="more"></a><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2. 原因"></a>2. 原因</h3><p>　　当应用程序的<strong>UI线程响应超时</strong>才会引起ANR，超时产生原因一般有两种：</p><ul><li>当前的事件没有机会得到处理（例如UI线程正在响应另外一个事件），当前事件由于某种原因被阻塞了。</li><li>当前的事件正在处理，但是由于耗时太长没能及时完成。</li></ul><p>　　从本质上讲，<strong>产生ANR的原因有三种</strong>，大致可以对应到Android 中四大组件中的三个（Activity/View，BroadcastReceiver和Service）。</p><ul><li>KeyDispatchTimeOut ：最常见的一种类型，原因是View的按键事件或者触摸事件在特定的时间（5秒）内无法得到响应。</li><li>BroadcaseTimeOut：原因是BroadcastReceiver的onReceiver()函数运行在主线程中，在特定的时间（10秒）内无法完成处理。</li><li>ServiceTimeOut：比较少出现的一种类型，原因是Service的各个生命周期函数在特定时间（20秒）内无法完成处理。</li></ul><p>　　<strong>根本原因</strong> 在主线程(UI线程)里面做了太多的耗时操作, 例如文件读写、数据库读写等。<br><strong>注意：</strong><br>　　Android 4.0 之后网络IO不允许在主线程中。</p><h4 id="补充：Android中哪些操作是在主线程中？"><a href="#补充：Android中哪些操作是在主线程中？" class="headerlink" title="补充：Android中哪些操作是在主线程中？"></a>补充：Android中哪些操作是在主线程中？</h4><ul><li>Activity的所有生命周期回调都是执行在主线程中</li><li>Service默认是执行在<strong>主线程</strong>中</li><li>BroadcastReceiver的onReceiver()回调执行在主线程中</li><li>没有使用子线程的Looper的Handler，它的handleMessage和post(Runnable)是执行在主线程中</li><li>AsyncTask的回调中除了doInBackground，其他的都是执行在主线程中</li><li>View的post(Runnable)是执行在主线程中</li></ul><h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><p>　　<strong>原则：</strong> 将耗时操作放在子线程中，主线程只做UI相关的操作。</p><ul><li>使用Handler机制，进行线程调度</li><li>使用Thread或者HandlerThread，开启子线程处理耗时操作</li><li>使用AsyncTask，处理异步任务</li><li>尽量避免在Activity的生命周期回调中做耗时操作</li></ul><h3 id="4-ANR的定位和分析"><a href="#4-ANR的定位和分析" class="headerlink" title="4. ANR的定位和分析"></a>4. ANR的定位和分析</h3><p>　　当发生ANR时，开发者可以通过结合<strong>Logcat日志</strong>和生成的位于手机内部存储的/data/anr/ <strong>traces.txt文件</strong>进行分析和定位。</p><p><strong>Logcat日志：</strong><br>从Logcat日志中，可以得到的信息主要有：<br>（1）导致ANR的类命及所在包名：MainActivity, com.asce1885.anrdemo<br>（2）发生ANR的进程名称及ID: com.asce1885.anrdemo,8672<br>（3）ANR产生的原因（类型）：Input disptching time out ，属于KeyDispatchTimeOut类型</p><p><strong>traces文件：</strong><br>　　从Logcat的日志信息我们可以知道引发ANR的具体的类信息以及ANR的类型，但是这不足够开发者定位到具体引发问题的代码行，为了获得进一步的信息，我们需要借助于ANR过程中生成的堆栈信息文件traces文件。<br>　　当app出现ANR会在data/anr/目录下生成traces.txt日志文件。每次发生ANR时都会删除旧的traces文件，重新创建新文件。也就是说Android只保留最后一次发生ANR时的信息。</p><p>　　一般trace文件顶部的线程即为ANR的元凶，进而分析ANR方法线程堆栈信息，重点关注主线程。最终定位出具体类的某个方法所导致的问题。</p><h2 id="二、OOM"><a href="#二、OOM" class="headerlink" title="二、OOM"></a>二、OOM</h2><h3 id="1-什么是OOM？"><a href="#1-什么是OOM？" class="headerlink" title="1. 什么是OOM？"></a>1. 什么是OOM？</h3><p>　　当前占用的内存加上我们申请的内存资源在超过了Dalvik虚拟机的最大内存限制，就会抛出 Out of Memory 的异常。<br>　　大部分的OOM异常都是大图加载所造成的。</p><h3 id="2-容易混淆的概念"><a href="#2-容易混淆的概念" class="headerlink" title="2. 容易混淆的概念"></a>2. 容易混淆的概念</h3><ul><li>内存溢出：即OOM</li><li>内存泄漏：内存泄漏积累到一定程度就会导致OOM。</li><li>内存抖动：短时间内大量的对象被创建，然后又被马上释放，瞬间产生的对象会严重占用内存区域。当达到阈值时触发GC，这样刚刚创建的对象就马上被回收。这些对象叠加在一起造成堆内存的压力，触发更多的GC。</li></ul><p>严重程度：内存溢出 &gt; 内存泄漏 &gt; 内存抖动</p><h3 id="3-解决方法-1"><a href="#3-解决方法-1" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><p>（1）有关Bitmap</p><ul><li>图片显示：加载合适的图片，例如加载缩略图的时候，我们不要进行网络请求加载大图。</li><li>及时释放内存：Bitmap的内存包含Java和Native两部分，其中Java的内存会被Java GC自动回收。可以在onDestory中手动去调用bitmap.recycle()进行内存释放。</li><li>图片压缩：设置inSampleSize（缩放比例）</li><li>使用inBitmap属性：复用内存区域</li><li>捕获异常：Error</li></ul><p>（2）其他</p><ul><li>ListView：<br>a: 使用convertView进行复用<br>b: 加载大图使用LRU机制进行缓存</li><li>自定义View：避免在onDraw方法里面执行对象的创建</li></ul><h2 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h2><h3 id="（一）Java的内存泄漏"><a href="#（一）Java的内存泄漏" class="headerlink" title="（一）Java的内存泄漏"></a>（一）Java的内存泄漏</h3><p>　　指的是无用的对象（不再使用的对象）持续占用内存而得不到 GC 回收，从而造成内存空间的浪费。</p><h4 id="1-Java-内存分配策略"><a href="#1-Java-内存分配策略" class="headerlink" title="1. Java 内存分配策略"></a>1. Java 内存分配策略</h4><p>　　Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配。 对应的， 三种存储策略使用的内存空间主要分别是： 静态存储区（也称方法区）、栈区和堆区。<br><strong>静态存储区（方法区）</strong> ： 主要存放静态数据、 全局 static 数据和常量。 这块内存在程序编译时就已经分配好， 并且在程序整个运行期间都存在。<br><strong>栈区</strong> ： 当方法被执行时， 方法体内的局部变量都在栈上创建， 并在方法执行结束时这些局部变量所持有的内存将会自动被释放。 因为栈内存分配运算内置于处理器的指令集中， 效率很高， 但是分配的内存容量有限。<br><strong>堆区</strong> ： 又称动态内存分配， 通常就是指在程序运行时直接 new 出来的内存。 这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</p><h4 id="2-什么样的对象会被GC？"><a href="#2-什么样的对象会被GC？" class="headerlink" title="2. 什么样的对象会被GC？"></a>2. 什么样的对象会被GC？</h4><p>　　可达性分析算法：如果一个对象到GCRoots没有任何引用链相连， 那么就认为这个对象不再被引用， 可以被 GC 回收。</p><h3 id="（二）Android的内存泄漏"><a href="#（二）Android的内存泄漏" class="headerlink" title="（二）Android的内存泄漏"></a>（二）Android的内存泄漏</h3><p>　　简单来说，就是该被释放的对象一直被某个或某些实例所持有却不再被使用导致内存得不到释放。 <strong>内存管理的目的</strong> 就是在开发中怎么有效的避免应用出现内存泄漏的问题。</p><h4 id="1-造成内存泄漏的情况"><a href="#1-造成内存泄漏的情况" class="headerlink" title="1. 造成内存泄漏的情况"></a>1. 造成内存泄漏的情况</h4><p>（1）单例<br>　　原因：由于单例的静态特性使得它和App的生命周期一样长，上下文如果是一个Activity的Context，那么它将一直持有Activity的引用，导致Activity无法被回收<br>　　解决方法：使用ApplicationContext<br>　　<br>（2）非静态内部类/匿名内部类<br>　　原因：默认持有外部类的引用，从而导致外部类（如：Activity）无法被回收<br>　　解决方法：改为静态内部类</p><p>（3）Handler<br>　　原因：由于Handler属于TLS(Thread Local Storage)变量，生命周期和Activity是不一致的； 万一Handler发送的Message尚未被处理， 则该Message及发送它的Handler对象将被线程MessageQueue一直持有。<br>　　解决方法：将Handler改写为静态内部类，同时在内部持有外部类的弱引用</p><p>（4）AsyncTask<br>　　原因：同非静态内部类<br>　　解决方法：可以在onDestory中调用asyncTask.cancle(boolean)</p><p>（5）static变量<br>　　原因：将变量声明为static时，将导致它的声明周期和整个App一样长，这部分的内存将不会被回收。<br>　　解决方法：考虑懒加载，尽量避免使用static变量；如果一定要使用，记得管理生命周期（onDestory中设为null）</p><p>（6）资源未关闭<br>　　如：Broadcast Receiver、Stream、Observer、Socket、Bitmap等<br>　　当Activity销毁前，记得注销这些资源，否则这些资源有可能无法回收，进而导致内存泄漏</p><h4 id="2-内存泄漏的定位和分析"><a href="#2-内存泄漏的定位和分析" class="headerlink" title="2. 内存泄漏的定位和分析"></a>2. 内存泄漏的定位和分析</h4><h5 id="（1）adb命令验证是否存在内存泄漏"><a href="#（1）adb命令验证是否存在内存泄漏" class="headerlink" title="（1）adb命令验证是否存在内存泄漏"></a>（1）adb命令验证是否存在内存泄漏</h5><p>1）打开要测试的apk，然后返回退出到主界面<br>2）AS的Terminal中输入命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="bash"> dumpsys meminfo 包名 -d</span></span><br></pre></td></tr></table></figure><p>　　然后便可以看到内存的一些情况<br>拉到下面可以看到：<br><img src="/images/img_memory_1.jpg" alt="img_memory_1"><br>　　退出APK之后，对象本应该都被回收，然而这里可以看到，还有View以及Activity占用着内存，由此可以知道内存泄漏了。</p><h5 id="（2）Android-Profiler（性能分析器）定位内存泄漏"><a href="#（2）Android-Profiler（性能分析器）定位内存泄漏" class="headerlink" title="（2）Android Profiler（性能分析器）定位内存泄漏"></a>（2）Android Profiler（性能分析器）定位内存泄漏</h5><p>1）进入内存分析界面<br>2）打开apk，然后返回键退出，然后点击上图中垃圾桶形状的图标进行垃圾回收，多点几次，直到内存没有什么变化<br>3）获取内存快照<br>4）查看Head Dump<br><img src="/images/img_memory_2.jpg" alt="img_memory_2"></p><ul><li>Shallow Heap（浅堆） 表示该对象自身占用的堆内存，不包括它引用的对象。</li><li>Retained Heap（深堆） 表示当前对象大小 + 当前对象可直接或间接引用到的对象的大小总和。<br>换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。</li></ul><p>　　从而分析出了内存泄漏的具体类</p><h5 id="（3）MAT-定位内存泄漏"><a href="#（3）MAT-定位内存泄漏" class="headerlink" title="（3）MAT 定位内存泄漏"></a>（3）MAT 定位内存泄漏</h5><p>1）进行格式转化</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hprof-conv -z <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>hprof <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>hprof</span><br></pre></td></tr></table></figure><p>2）Open Heap Dump 打开刚刚保存的内存快照，并点击点击 Histogram<br>3）可以看到引起内存泄漏的类，Objects那一列不为0，则是说明发生了内存泄漏<br>4）过滤掉虚引用，软引用，弱引用，之后可以看到引用路径即为发生内存泄漏的具体位置<br><img src="/images/img_memory_3.jpg" alt="img_memory_3"></p><p><img src="/images/img_memory_4.jpg" alt="img_memory_4"></p><h5 id="（4）LeakCanary-检测内存泄漏"><a href="#（4）LeakCanary-检测内存泄漏" class="headerlink" title="（4）LeakCanary 检测内存泄漏"></a>（4）LeakCanary 检测内存泄漏</h5><p>LeakCanary 是一个用于检测内存泄露的开源类库。<br>1）在代码中引入LeakCanary<br>2）启动app，当检测到内存泄漏的时候，会出现一个弹窗，然后手机桌面会出现一个Leaks的图标<br>3）点击即可看到内存泄漏的原因<br><img src="/images/img_memory_5.jpg" alt="img_memory_5"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、ANR&quot;&gt;&lt;a href=&quot;#一、ANR&quot; class=&quot;headerlink&quot; title=&quot;一、ANR&quot;&gt;&lt;/a&gt;一、ANR&lt;/h2&gt;&lt;h3 id=&quot;1-什么是ANR？&quot;&gt;&lt;a href=&quot;#1-什么是ANR？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是ANR？&quot;&gt;&lt;/a&gt;1. 什么是ANR？&lt;/h3&gt;&lt;p&gt;　　&lt;strong&gt;ANR&lt;/strong&gt; 即Application Not Responding，它是一个提示“应用程序无响应”的对话框。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://lvmdu.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化</title>
    <link href="https://lvmdu.gitee.io/2020/02/29/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://lvmdu.gitee.io/2020/02/29/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2020-02-29T08:19:00.000Z</published>
    <updated>2020-03-01T01:42:20.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、布局优化"><a href="#一、布局优化" class="headerlink" title="一、布局优化"></a>一、布局优化</h2><p>① 删除布局中无用的控件和层次， 其次有选择地使用性能比较低的ViewGroup</p><a id="more"></a><p>　　例如： 如果布局中既可以使用LinearLayout也可以使用RelativeLayout， 那么就采用LinearLayout， 这是因为RelativeLayout的功能比较复杂， 它的布局过程需要花费更<br>多的CPU时间。<br>② 采用&lt;include&gt; 标签、&lt;merge&gt; 标签和ViewStub</p><ul><li>&lt;include&gt; 标签：布局重用</li><li>&lt;merge&gt; 标签：减少布局层级</li><li>ViewStub：按需加载</li></ul><p>③ 避免多度绘制</p><h2 id="二、绘制优化"><a href="#二、绘制优化" class="headerlink" title="二、绘制优化"></a>二、绘制优化</h2><p>① onDraw中不要创建新的局部对象<br>② onDraw方法中不要做耗时的任务</p><h2 id="三、内存泄漏优化"><a href="#三、内存泄漏优化" class="headerlink" title="三、内存泄漏优化"></a>三、内存泄漏优化</h2><p>① 在开发过程中避免写出有内存泄漏的代码<br>② 通过一些分析工具比如MAT来找出潜在的内存泄露</p><h2 id="四、响应速度优化"><a href="#四、响应速度优化" class="headerlink" title="四、响应速度优化"></a>四、响应速度优化</h2><p>核心思想：避免在主线程中做耗时操作</p><h2 id="五、ListView-RecycleView及Bitmap优化"><a href="#五、ListView-RecycleView及Bitmap优化" class="headerlink" title="五、ListView/RecycleView及Bitmap优化"></a>五、ListView/RecycleView及Bitmap优化</h2><h4 id="ListView-RecycleView："><a href="#ListView-RecycleView：" class="headerlink" title="ListView/RecycleView："></a>ListView/RecycleView：</h4><p>① 使用ViewHolder模式来提高效率<br>② 异步加载： 耗时的操作放在异步线程中<br>③ ListView/RecycleView的滑动时停止加载和分页加载</p><h4 id="Bitmap："><a href="#Bitmap：" class="headerlink" title="Bitmap："></a>Bitmap：</h4><p>　　主要是对加载图片进行压缩，避免加载图片多大导致OOM出现。</p><h2 id="六、线程优化"><a href="#六、线程优化" class="headerlink" title="六、线程优化"></a>六、线程优化</h2><p>　　尽量采用线程池，而不是每次都要创建一个Thread对象</p><h2 id="七、其他性能优化的建议"><a href="#七、其他性能优化的建议" class="headerlink" title="七、其他性能优化的建议"></a>七、其他性能优化的建议</h2><p>①　避免过度的创建对象<br>②　不要过度使用枚举， 枚举占用的内存空间要比整型大<br>③　常量请使用static final来修饰<br>④　使用一些Android特有的数据结构， 比如SparseArray和Pair等<br>⑤　适当采用软引用和弱引用<br>⑥　采用内存缓存和磁盘缓存<br>⑦　尽量采用静态内部类</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、布局优化&quot;&gt;&lt;a href=&quot;#一、布局优化&quot; class=&quot;headerlink&quot; title=&quot;一、布局优化&quot;&gt;&lt;/a&gt;一、布局优化&lt;/h2&gt;&lt;p&gt;① 删除布局中无用的控件和层次， 其次有选择地使用性能比较低的ViewGroup&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://lvmdu.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>专业基础知识之计算机网络</title>
    <link href="https://lvmdu.gitee.io/2020/02/28/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://lvmdu.gitee.io/2020/02/28/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-02-28T12:08:00.000Z</published>
    <updated>2020-03-01T02:39:50.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-网络分层体系结构"><a href="#1-网络分层体系结构" class="headerlink" title="1. 网络分层体系结构"></a>1. 网络分层体系结构</h3><p><img src="/images/img_web.jpg" alt="img_web"></p><a id="more"></a><ul><li>应用层：提供用户与网络交互的接口，定义了应用程序间通信和交互的规则。—— HTTP、FTP、POP、SMTP</li><li>运输层：负责不同主机进程之间的数据传输。—— TCP、UDP</li><li>网络层：负责不同主机之间的数据传输。—— IP</li><li>数据链路层：负责相邻结点之间的数据传输。—— PPP</li><li>物理层：在物理介质上的传输。</li></ul><p><strong>PDU（协议数据单元）：</strong></p><ul><li>应用层：各应用报文</li><li>运输层：TCP/UDP数据段</li><li>网络层：IP数据包</li><li>数据链路层：帧</li><li>物理层：比特</li></ul><h3 id="2-GET-和-POST-两种请求方式的区别"><a href="#2-GET-和-POST-两种请求方式的区别" class="headerlink" title="2. GET 和 POST 两种请求方式的区别"></a>2. GET 和 POST 两种请求方式的区别</h3><p>（1）URL可见性</p><ul><li>get：URL参数可见</li><li>post：URL参数不可见</li></ul><p>（2）数据传输</p><ul><li>get：通过拼接URL进行传递参数</li><li>post：通过Body体传递参数</li></ul><p>（3）缓存性</p><ul><li>get：可缓存</li><li>post：不可缓存</li></ul><p>（4）后退页面的反应</p><ul><li>get：页面后退后，不产生影响</li><li>post：页面后退后，会重新提交请求</li></ul><p>（5）传输数据的大小</p><ul><li>get：有限制（一般不超过2k-4k）</li><li>post：没有限制</li></ul><p>（6）安全性</p><ul><li>get：不安全（URL参数可见）</li><li>post：安全</li></ul><h3 id="3-TCP-和-UDP-的区别"><a href="#3-TCP-和-UDP-的区别" class="headerlink" title="3. TCP 和 UDP 的区别"></a>3. TCP 和 UDP 的区别</h3><p>主要区别：<br><strong>TCP：</strong><br>1）<strong>面向连接的</strong>，连接的建立需要三次握手，；连接的释放需要四次挥手<br>2）<strong>面向字节流</strong>，会把上层传输下来的数据当作是无结构的字节流<br>3）<strong>一对一通信</strong><br>4）<strong>能够保证可靠传输</strong>，具有超时重传机制，并有数据校验<br><strong>UDP：</strong><br>1）<strong>无连接的</strong>，一方向另一方发送数据不需要建立连接<br>2）<strong>面向报文</strong>，从上层接受的数据如果报文不大于传输限制，则直接加上首部；如果过大，则进行IP分片后，再加上首部进行传输<br>3）<strong>可以一对一通信，也可以一对多通信</strong><br>4）<strong>不保证可靠传输</strong>，仅仅是尽最大努力交付</p><p>详细区别：<br><img src="/images/img_tcp_udp.jpg" alt="img_tcp_udp"></p><p><strong>什么时候应该使用TCP？</strong><br>当对网络通讯质量有要求的时候， 比如： 整个数据要准确无误的传递给对方， 这往往用于一些要求可靠的应用， 比如HTTP、 HTTPS、 FTP等传输文件的协议， POP、 SMTP等邮件传输的协议。</p><p><strong>什么时候应该使用UDP？</strong><br>当对网络通讯质量要求不高的时候， 要求网络通讯速度能尽量的快， 这时就可以使用UDP。比如DNS域名系统。</p><h3 id="4-TCP连接的建立与终止"><a href="#4-TCP连接的建立与终止" class="headerlink" title="4. TCP连接的建立与终止"></a>4. TCP连接的建立与终止</h3><p><img src="/images/img_tcp.png" alt="img_tcp"></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>• 第一次握手： 建立连接。 客户端发送连接请求报文段， 将 SYN 设置为 1、 Sequence Number（seq）为 x； 接下来客户端进入 SYN_SENT 状态， 等待服务端的确认。<br>• 第二次握手： 服务器收到客户端的 SYN 报文段， 对 SYN 报文段进行确认， 设置 Acknowledgment Number（ACK） 为 x+1（seq+1） ； 同时自己还要发送 SYN 请求信息， 将 SYN 设置为1、 seq 为 y。 服务端将上述所有信息放到 SYN+ACK 报文段中， 一并发送给客户端， 此时服务端进入 SYN_RCVD 状态。<br>• 第三次握手： 客户端收到服务端的 SYN+ACK 报文段； 然后将 ACK 设置为 y+1， 向服务端发送 ACK 报文段， 这个报文段发送完毕后， 客户端和服务端都进入 ESTABLISHED （TCP连接成功） 状态。</p><p><strong>为什么要三次握手？</strong><br>　　为了防止已失效的连接请求报文段突然又传送到了服务端， 因而产生错误。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>• 第一次挥手： 客户端设置 seq 和 ACK， 向服务端发送一个 FIN 报文段。 此时， 客户端进入 FIN_WAIT_1 状态， 表示客户端没有数据要发送给服务端了。<br>• 第二次挥手： 服务端收到了客户端发送的 FIN 报文段， 向客户端回了一个 ACK 报文段。<br>• 第三次挥手： 服务端向客户端发送 FIN 报文段， 请求关闭连接， 同时服务端进入 LAST_ACK 状态。<br>• 第四次挥手： 客户端收到服务端发送的 FIN 报文段， 向服务端发送 ACK 报文段， 然后客户端进入 TIME_WAIT 状态。 服务端收到客户端的 ACK 报文段以后， 就关闭连接。 此时， 客户端等待 2MSL（最大报文段生存时间） 后依然没有收到回复， 则说明服务端已正常关闭， 这样客户端也可以关闭连接了。</p><p><strong>为什么要四次挥手？</strong><br>　　为了保证在最后断开的时候，客户端能够发送最后一个ACK报文段能够被服务器接收到，从而避免在下一个连接中出现上一个连接的滞留的报文。</p><h3 id="5-状态码"><a href="#5-状态码" class="headerlink" title="5. 状态码"></a>5. 状态码</h3><p>　　状态码由3位数字组成， 第一个数字定义了响应的类别， 且有以下5种可能取值。<br>• 1xx： 指示信息， 收到请求， 需要请求者继续执行操作。<br>• 2xx： 请求成功， 请求已被成功接收并处理。<br>• 3xx： 重定向， 要完成请求必须进行更进一步的操作。<br>• 4xx： 客户端错误， 请求有语法错误或请求无法实现。<br>• 5xx： 服务器错误， 服务器不能实现合法的请求。<br>常见的状态码如下：<br>• 200 OK： 客户端请求成功。<br>• 400 Bad Request： 客户端请求有语法错误， 服务器无法理解。<br>• 401 Unauthorized： 客户端请求未经授权， 这个状态码必须和WWW-Authenticate报头域一起使用。<br>• 403 Forbidden： 客户端请求被服务端拒绝。<br>• 404 Not Found： 客户端请求地址错误， 资源未找到<br>• 500 Internal Server Error： 服务器内部错误， 无法完成请求。<br>• 503 Server Unavailable： 服务器当前不能处理客户端的请求， 一段时间后可能恢复正常。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-网络分层体系结构&quot;&gt;&lt;a href=&quot;#1-网络分层体系结构&quot; class=&quot;headerlink&quot; title=&quot;1. 网络分层体系结构&quot;&gt;&lt;/a&gt;1. 网络分层体系结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/img_web.jpg&quot; alt=&quot;img_web&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业基础知识" scheme="https://lvmdu.gitee.io/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="网络" scheme="https://lvmdu.gitee.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识汇总</title>
    <link href="https://lvmdu.gitee.io/2020/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>https://lvmdu.gitee.io/2020/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</id>
    <published>2020-02-28T09:20:00.000Z</published>
    <updated>2020-02-28T12:09:13.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java基本数据类型的字节数"><a href="#1-Java基本数据类型的字节数" class="headerlink" title="1. Java基本数据类型的字节数"></a>1. Java基本数据类型的字节数</h3><table><thead><tr><th align="center">基本数据类型</th><th align="center">字节数</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">1</td></tr><tr><td align="center">boolean</td><td align="center">1</td></tr><tr><td align="center">char</td><td align="center">2</td></tr><tr><td align="center">short</td><td align="center">2</td></tr><tr><td align="center">int</td><td align="center">4</td></tr><tr><td align="center">long</td><td align="center">8</td></tr><tr><td align="center">float</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">8</td></tr></tbody></table><p>注：long double：8</p><a id="more"></a><h3 id="2-基本数据类型和引用类型的区别"><a href="#2-基本数据类型和引用类型的区别" class="headerlink" title="2. 基本数据类型和引用类型的区别"></a>2. 基本数据类型和引用类型的区别</h3><p><strong>基本类型变量：</strong></p><ul><li>在内存中存储的是一个基本类型 值</li><li>可以在栈中直接分配内存</li><li>将一个变量的实际值赋给另一个变量：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = <span class="number">2</span>;</span><br><span class="line">j = i;  <span class="comment">//就是将基本类型变量 j 的内容复制给基本类型变量 i</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>引用类型变量：</strong></p><ul><li>在内存中存储的是一个引用，它指向对象的存储地址</li><li>对象的引用在栈中，对象实际存放在堆中</li><li>将一个变量的引用赋给另一个变量：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c1 = <span class="keyword">new</span> Circle(<span class="number">9</span>);</span><br><span class="line">c2 = <span class="keyword">new</span> Circle(<span class="number">6</span>);</span><br><span class="line">c2 = c1;  <span class="comment">//就是将c2的引用赋给c1，赋值之后，变量c2和c1指向同一个对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个时候c1以前的引用对象不再有用，因此，现在它就称为垃圾。垃圾会占用内存空间。</span></span><br><span class="line"><span class="comment">Java运行系统会检测垃圾并自动回收它所占据的空间，这个过程称为垃圾回收。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong> 如果你不再需要某个对象，可以显式地给该对象的引用变量赋值为null。 如果该对象没有被任何引用变量所引用，Java虚拟机会自动回收它所占据的空间。</p><h3 id="3-equals-和-的区别"><a href="#3-equals-和-的区别" class="headerlink" title="3. equals 和 == 的区别"></a>3. equals 和 == 的区别</h3><p><strong>==</strong><br>　　既可以比较基本数据类型类型的变量，又可以比较引用类型的变量。</p><ul><li>如果作用于基本的数据类型变量，则直接比较 <strong>值</strong> 是否相等；</li><li>如果作用于引用类型的变量，则比较所指向的 <strong>对象的地址</strong> 是否相等。</li></ul><p><strong>equals</strong><br>　　只能比较引用类型的变量，而不能比较基本数据类型的变量。</p><ul><li>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的 <strong>对象的地址</strong> 是否相等；</li><li>如果对equals方法进行重写（如String、Date等），则比较所指向 <strong>对象的内容</strong> 是否相等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Java基本数据类型的字节数&quot;&gt;&lt;a href=&quot;#1-Java基本数据类型的字节数&quot; class=&quot;headerlink&quot; title=&quot;1. Java基本数据类型的字节数&quot;&gt;&lt;/a&gt;1. Java基本数据类型的字节数&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;基本数据类型&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;字节数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;byte&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;boolean&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;char&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;short&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;int&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;long&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;float&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;double&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;注：long double：8&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://lvmdu.gitee.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://lvmdu.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>详解事件分发机制</title>
    <link href="https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-27T10:05:00.000Z</published>
    <updated>2020-02-28T03:57:29.858Z</updated>
    
    <content type="html"><![CDATA[<p>　　安卓上面的View是树形结构的，View可能会重叠在一起，当点击的地方有多个View可以响应的时候，这个点击事件应该给谁呢？为了解决这个问题，就有了<strong>事件分发机制</strong>。</p><a id="more"></a><h2 id="一、对象"><a href="#一、对象" class="headerlink" title="一、对象"></a>一、对象</h2><p>　　事件分发的<strong>三个主要对象</strong>：<strong>Activiy、ViewGroup、View</strong><br>　　事件分发的主要顺序： <strong>Activity(Window) -&gt; ViewGroup -&gt; View</strong><br>　　Android的UI界面是由Activity、 ViewGroup、 View及其派生类所构成的。<br><img src="/images/img_view_2.jpg" alt="img_view_2"></p><p>　　Activity的构成如下：<br><img src="/images/img_view_1.png" alt="img_view_1"></p><ul><li>PhoneWindow：是抽象类Window的唯一实现类，抽象类Window是所有视图最顶层的容器，包括View视图的外观和行为都归Window管。</li><li>DecorView：PhoneWindow的内部类，DecorView将屏幕氛围2个部分：TitleView 和 ContentView，我们平常加载的布局就是ContentView。通过DecorView传递信息给下面的View，下面的View也通过DecorView返回消息给PhoneWindow。</li></ul><p>事件分发的具体顺序： <strong>PhoneWindow -&gt; DecorView -&gt; ViewGroup -&gt; View</strong></p><h2 id="二、重要方法"><a href="#二、重要方法" class="headerlink" title="二、重要方法"></a>二、重要方法</h2><ul><li><strong>dispatchTouchEvent：</strong> 进行事件的分发</li><li><strong>onInterceptTouchEvent：</strong> 进行事件的拦截， 在 dispatchTouchEvent 内部调用。</li><li><strong>onTouchEvent：</strong> 处理事件，在 dispatchTouchEvent 内部调用。</li></ul><h2 id="三、分发流程"><a href="#三、分发流程" class="headerlink" title="三、分发流程"></a>三、分发流程</h2><p><img src="/images/img_view_3.jpg" alt="img_view_3"></p><p><img src="/images/img_view_4.jpg" alt="img_view_4"></p><p>（1）当点击事件产生后首先会由Activity来处理，在内部先传递到PhoneWindow，再传递给DecorView。之后传递到顶层的ViewGroup。<br>（2）ViewGroup的dispatchTouchEvent方法会进行判断：</p><ul><li>如果onInterceptTouchEvent方法返回true，则该ViewGroup就拦截这个事件，并交给它的onTouchEvent方法处理；</li><li>如果onInterceptTouchEvent方法返回false，则该ViewGroup就不会拦截这个事件，因此，交给它的子元素(ViewGroup/View)的dispatchTouchEvent方法处理。如果子元素的onInterceptTouchEvent方法仍返回false，则继续向下传递……</li></ul><p>（3）如此反复，直到传递到底层的View。<br>（4）底层View的onTouchEvent方法：</p><ul><li>如果返回true，则事件由底层View消耗并处理。</li><li>如果返回false，则事件不做处理，传递到父元素(ViewGroup/View)的onTouchEvent处理。如果父元素的onTouchEvent方法仍返回false，则继续向上传递……</li></ul><p>（5）如此反复，直到传递到Activity。如果Activity的onTouchEvent方法仍返回false，则该事件将会被抛弃。</p><p>　　整个过程采用了<strong>责任链模式</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　安卓上面的View是树形结构的，View可能会重叠在一起，当点击的地方有多个View可以响应的时候，这个点击事件应该给谁呢？为了解决这个问题，就有了&lt;strong&gt;事件分发机制&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>详解消息机制</title>
    <link href="https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-27T09:32:00.000Z</published>
    <updated>2020-02-28T02:21:09.157Z</updated>
    
    <content type="html"><![CDATA[<p>　　Android的<strong>消息机制</strong>也就是Handler机制。主要的作用是用来在不同线程之间的通信，通常使用在子线程执行完成一些耗时操作，需要回到主线程更新界面UI时，通过Handler将有关UI的操作切换到主线程。</p><a id="more"></a><h2 id="一、消息机制存在的意义"><a href="#一、消息机制存在的意义" class="headerlink" title="一、消息机制存在的意义"></a>一、消息机制存在的意义</h2><p><strong>为什么不能在非UI线程中操作UI控件？</strong><br>　　因为Android的UI控件（View）不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态。<br><strong>为什么不对UI控件加上锁机制？</strong><br>　　首先加上锁会让UI访问的逻辑变得复杂；其次锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。</p><h2 id="二、消息机制的工作原理"><a href="#二、消息机制的工作原理" class="headerlink" title="二、消息机制的工作原理"></a>二、消息机制的工作原理</h2><p>消息机制主要包含： <strong>MessageQueue</strong>、<strong>Handler</strong> 和<strong>Looper</strong>这三大部分，以及<strong>Message</strong>。</p><ul><li>Message： 需要传递的消息， 可以传递数据；</li><li>MessageQueue： 消息队列， 但是它的内部实现并不是用的队列， 实际上是通过一个<strong>单链表</strong>的数据结构来维护消息列表， 因为单链表在插入和删除上比较有优势。 主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next)；</li><li>Handler： 消息辅助类， 主要功能向消息池发送各种消息事件(Handler.sendMessage)和处理相应消息事件(Handler.handleMessage)；</li><li>Looper： 不断循环执行(Looper.loop)， 从MessageQueue中读取消息， 按分发机制将消息分发给目标处理者。<br><img src="/images/img_handler.jpg" alt="img_handler"><h4 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h4>（1）应用程序启动的时候，在主线程中会默认调用了 Looper.preper()方法，初始化Looper对象并绑定到当前线程中，并在Looper内部维护一个MessageQueue。<br>（2）接着调用handler.sendMessage()发送消息（handler.postRunnable()实际上底层也是调用了handler.sendMessage()，只不过进行了封装），会通过MessageQueue.enqueueMessage()向MessageQueue中添加一条消息。<br>（3）主线程调用Looper.looper()开启循环，不断轮询消息队列，通过MessageQueue.next()取出消息。<br>（4）取出的message不为空则调用msg.target.dispatchMessage()传递分发消息，目标handler收到消息后会执行handler.handlerMessage()方法处理消息。</li></ul><p><strong>MessageQueue、Handler 和 Looper 三者之间的关系：</strong></p><ul><li><strong>一个线程中只能存在一个Looper</strong>， Looper是保存在ThreadLocal中的。 主线程（UI线程）已经创建了一个Looper， 所以在主线程中不需要再创建Looper， 但是在其他线程中需要创建Looper。</li><li>每个线程中可以有多个Handler， 即<strong>一个Looper可以处理来自多个Handler的消息</strong>。</li><li><strong>一个Looper中维护一个MessageQueue</strong>， 来维护消息队列， 消息队列中的Message可以来自不同的Handler。</li></ul><h2 id="三、深入理解消息机制"><a href="#三、深入理解消息机制" class="headerlink" title="三、深入理解消息机制"></a>三、深入理解消息机制</h2><h4 id="1-为什么一个线程只有一个Looper？"><a href="#1-为什么一个线程只有一个Looper？" class="headerlink" title="1. 为什么一个线程只有一个Looper？"></a>1. 为什么一个线程只有一个Looper？</h4><p>　　因为线程对应的Looper是在<strong>ThreadLocal</strong>里面存储，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其它线程来说无法获取到数据。另外，在Looper的创建方法Looper.prepare()中，会进行判断，如果当前线程已经存在Looper对象，就会报RunTimeException异常。<br><strong>补充：为什么ThreadLocal可以在多个线程中互不干扰的存储和修改数据？</strong> ThreadLocal所做的读写操作仅限于各自线程的内部</p><h4 id="2-为什么主线程中可以直接使用Handler，而不用创建Looper？"><a href="#2-为什么主线程中可以直接使用Handler，而不用创建Looper？" class="headerlink" title="2. 为什么主线程中可以直接使用Handler，而不用创建Looper？"></a>2. 为什么主线程中可以直接使用Handler，而不用创建Looper？</h4><p>　　<strong>UI线程(ActivityThread)被创建时默认初始化了Looper</strong>。因此在主线程中可以直接使用Handler。</p><h4 id="3-可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？"><a href="#3-可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？" class="headerlink" title="3. 可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？"></a>3. 可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？</h4><p>　　子线程中不可以直接使用Handler，子线程中默认是没有Looper的，同时MessageQueue又是Looper来维护的。因此如果在子线程中直接发送消息，是没有关联MessageQueue可以存储消息。因此会抛出异常。<br>　　如果想在子线程中使用Handler，必须通过Looper.prepare()去初始化一个Looper，并且再通过Looper.loop()开启循环。</p><h4 id="4-Looper-loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？"><a href="#4-Looper-loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？" class="headerlink" title="4. Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？"></a>4. Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？</h4><p>　　在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。（因此，looper.looper()阻塞不会消耗大量的CPU资源。）<br>　　epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。<br>　　所谓ANR便是Looper.loop没有得到及时处理，一旦没有消息，Linux的epoll机制则会通过管道写文件描述符的方式来对主线程进行唤醒与睡眠，Android里调用了linux层的代码实现在适当时会睡眠主线程。</p><p><strong>消息循环（死循环）的必要性：</strong><br>　　线程既然是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出。例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。<br>　　ActivityThread的main方法主要就是做消息循环，一旦退出消息循环，那么你的应用也就退出了。如果main方法中没有Looper进行循环，那么主线程一运行完毕就会退出。</p><h2 id="四、Handler引起的内存泄漏"><a href="#四、Handler引起的内存泄漏" class="headerlink" title="四、Handler引起的内存泄漏"></a>四、Handler引起的内存泄漏</h2><h3 id="1-原因："><a href="#1-原因：" class="headerlink" title="1. 原因："></a>1. 原因：</h3><p>　　<strong>非静态、匿名内部类会隐式持有外部类的引用，导致外部Activity无法回收。</strong></p><h3 id="2-解决方法："><a href="#2-解决方法：" class="headerlink" title="2. 解决方法："></a>2. 解决方法：</h3><p>（1）将Handler修改为静态内部类<br>（2）Handler内部持有外部Activity的弱引用<br>（3）在onDestory()中调用handler.removeCallbackAndMessages(null)</p><h2 id="五、AsyncTask"><a href="#五、AsyncTask" class="headerlink" title="五、AsyncTask"></a>五、AsyncTask</h2><h4 id="1-核心方法"><a href="#1-核心方法" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h4><ul><li>onPreExecute()</li><li>doInBackground(Params…params)</li><li>onProgressUpdate(Params…params)</li><li>onPostExecute(Result result)</li></ul><p><strong>注意：</strong><br>（1）只有onProgressUpdate在线程池中执行，可以执行耗时任务；其他方法都是在主线程中。<br>（2）AsyncTask的类必须在主线程中加载；对象必须在主线程中创建；execute方法必须在UI线程中调用。<br>（3）不要在程序中直接调用4个核心方法<br>（4）一个AsyncTask对象只能执行一次，只能调用一次execute方法。<br>（5）Android 1.6之前，AsyncTask是串行执行的。之后的版本加入了并行执行。可以通过executeOnExecutor并行执行任务，但不建议。</p><h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h4><p>　　AsyncTask内部封装了一个静态线程池，通过内部的InternalHandler在UI线程和子线程之间传递消息。</p><h4 id="3-使用不当的后果"><a href="#3-使用不当的后果" class="headerlink" title="3. 使用不当的后果"></a>3. 使用不当的后果</h4><p>1）生命周期<br>　　AsyncTask不与任何组件绑定生命周期， 所以在Activity/或者Fragment中创建执行AsyncTask时， 最好在Activity/Fragment的onDestory()调用cancel(boolean)。<br>2）内存泄漏<br>　　如果AsyncTask被声明为Activity的非静态的内部类， 那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用。 如果Activity已经被销毁， AsyncTask的后台线程还在执行， 它将继续在内存里保留这个引用， 导致Activity无法被回收， 引起内存泄露。<br>3）结果丢失<br>　　屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建， 之前运行的AsyncTask（非静态的内部类）会持有一个之前Activity的引用， 这个引用已经无效， 这时再去更新界面将不再生效。</p><h2 id="六、HandlerThread"><a href="#六、HandlerThread" class="headerlink" title="六、HandlerThread"></a>六、HandlerThread</h2><p>　　HandlerThread继承了Thread，同时它的内部创建了MessageQueue，可以进行Looper循环，是一个具有消息循环的线程。我们通过它可以直接使用Handler。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Android的&lt;strong&gt;消息机制&lt;/strong&gt;也就是Handler机制。主要的作用是用来在不同线程之间的通信，通常使用在子线程执行完成一些耗时操作，需要回到主线程更新界面UI时，通过Handler将有关UI的操作切换到主线程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>详解Binder机制</title>
    <link href="https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3Binder%E6%9C%BA%E5%88%B6/"/>
    <id>https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3Binder%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-27T09:04:00.000Z</published>
    <updated>2020-02-27T14:31:20.452Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong>Binder机制</strong> 是Android中的一种跨进程的通信机制。</p><a id="more"></a><h2 id="一、IPC原理"><a href="#一、IPC原理" class="headerlink" title="一、IPC原理"></a>一、IPC原理</h2><p>　　从进程角度来看IPC（Interprocess Communication）机制：<br>    <img src="/images/img_ipc.jpg" alt="img_ipc"><br>　　每个Android的进程， 只能运行在自己进程所拥有的虚拟地址空间（<strong>进程隔离</strong>）。 <strong>对于用户空间， 不同进程之间是不能共享的， 而内核空间却是可共享的。</strong> Client进程向Server进程通信， 恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的。 Client端与Server端进程往往采用ioctl（设备控制接口）等方法完成用户空间与内核空间的驱动进行交互。</p><h2 id="二、为什么要使用Binder？"><a href="#二、为什么要使用Binder？" class="headerlink" title="二、为什么要使用Binder？"></a>二、为什么要使用Binder？</h2><h3 id="1-性能方面"><a href="#1-性能方面" class="headerlink" title="1. 性能方面"></a>1. 性能方面</h3><p>　　在Android设备上（性能受限制，比如要省电）， 广泛地使用跨进程通信对通信机制的性能有严格的要求， Binder相对于传统的Socket方式， 更加高效。 Binder数据拷贝只需要一次， 而管道、 消息队列、 Socket都需要两次， 而共享内存方式虽然一次内存拷贝都不需要， 但实现方式又比较复杂。</p><h3 id="2-安全方面"><a href="#2-安全方面" class="headerlink" title="2. 安全方面"></a>2. 安全方面</h3><p>　　传统的进程通信方式对于通信双方的身份并没有做出严格的验证， 比如Socket通信的IP地址是客户端手动填入， 很容易进行伪造。 然而， Binder机制从协议本身就支持对通信双方做身份校检， 从而大大提升了安全性。</p><h2 id="三、Binder原理"><a href="#三、Binder原理" class="headerlink" title="三、Binder原理"></a>三、Binder原理</h2><p>　　Binder通信采用<strong>C/S架构</strong>， 从组件视角来说， 包含<strong>Client、 Server、 ServiceManager以及Binder驱动</strong>， 其中ServiceManager用于管理系统中的各种服务。<br>架构图如下所示：<br><img src="/images/img_binder.jpg" alt="img_binder"></p><h4 id="Binder通信的四个角色："><a href="#Binder通信的四个角色：" class="headerlink" title="Binder通信的四个角色："></a>Binder通信的四个角色：</h4><ul><li>Client进程： 使用服务的进程。</li><li>Server进程： 提供服务的进程。</li><li>ServiceManager进程： ServiceManager的作用是将字符形式的<strong>Binder名字转化成Client中对该Binder的引用</strong>， 使得Client能够通过Binder名字获得对Server中Binder实体的引用(代理对象)。</li><li>Binder驱动： 驱动负责进程之间Binder通信的建立。</li></ul><p><strong>注意：</strong><br>对于Service进程来说，Binder指的是Binder本地对象；<br>对于Client进程来说，Binder指的是Binder代理对象。</p><h4 id="Binder运行机制："><a href="#Binder运行机制：" class="headerlink" title="Binder运行机制："></a>Binder运行机制：</h4><p>（1）<strong>注册服务</strong>： Server进程要先注册Service到ServiceManager。 该过程： Server是客户端， ServiceManager是服务端。<br>（2）<strong>获取服务</strong>： Client进程使用某个Service前， 须先向ServiceManager中获取相应的Service。 该过程： Client是客户端， ServiceManager是服务端。<br>（3）<strong>使用服务</strong>： Client根据得到的Service信息建立与Service所在的Server进程通信的通路， 然后就可以直接与Service交互。 该过程： Client是客户端， Server是服务端。</p><h2 id="四、AIDL"><a href="#四、AIDL" class="headerlink" title="四、AIDL"></a>四、AIDL</h2><p>　　<strong>AIDL</strong> (Android Interface Definition Language) 是一种接口定义语言， 用于生成可以在Android设备上两个进程之间进行进程间通信(Interprocess Communication, IPC)的代码。 如果在一个进程中（ 例如Activity） 要调用另一个进程中（ 例如Service）对象的操作， 就可以使用AIDL生成可序列化的参数， 来完成进程间通信。<br>　　AIDL之所以能够实现进程间通信， 其内部是通过<strong>Binder机制</strong>来实现的。</p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h4><p>服务端：</p><ul><li>创建JavaBean，并实现进行序列化</li><li>新建同名的AIDL文件，并在文件中声明JavaBean对象</li><li>新建AIDL接口文件，并且在其中定义方法</li><li>创建继承Service的自定义服务并重写onBind方法</li><li>声明Stub类型变量（Binder类型），并实现接口方法</li></ul><p>客户端：</p><ul><li>将服务端中AIDL文件夹移植到客户端</li><li>声明接口类型变量</li><li>声明ServiceConnection类型变量，并完成bindService</li><li>在serviceConnected方法中通过IBookManager.Stub.asInterface(service)获取接口对象</li></ul><p>　　这样就可以通过接口对象调用服务端接口中的定义的方法了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt;Binder机制&lt;/strong&gt; 是Android中的一种跨进程的通信机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件之ContentProvider</title>
    <link href="https://lvmdu.gitee.io/2020/02/27/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BContentProvider/"/>
    <id>https://lvmdu.gitee.io/2020/02/27/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BContentProvider/</id>
    <published>2020-02-27T08:10:00.000Z</published>
    <updated>2020-02-28T01:55:24.572Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong>内容提供者（ContentProvider）</strong> 是用于在不同的应用程序之间实现数据共享的一种组件。它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。</p><a id="more"></a><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>　　进程间进行数据的交互和共享，即跨进程通信（IPC）。<br><img src="/images/img_content_provider.jpg" alt="img_content_provider"></p><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p>　　ContentProvider的底层通信是采用Android中的<strong>Binder机制</strong>。<br><img src="/images/img_content_provider_new.jpg" alt="img_content_provider_new"></p><h4 id="ContentProvider类"><a href="#ContentProvider类" class="headerlink" title="ContentProvider类"></a>ContentProvider类</h4><p>　　ContentProvider主要以表格的形式组织数据，同时也支持文件数据，只是表格形式用得比较多。每个表格中包含多张表， 每张表包含行 &amp; 列，分别对应记录 &amp; 字段。</p><h4 id="ContentResolver类"><a href="#ContentResolver类" class="headerlink" title="ContentResolver类"></a>ContentResolver类</h4><p>　　统一管理不同ContentProvider间的操作。外部进程通过ContentResolver类，从而与ContentProvider类进行交互。<br>　　一般来说，一款应用要使用多个ContentProvider，若需要了解每个ContentProvider的不同实现从而再完成数据交互，操作成本高 &amp; 难度大。所以在ContentProvider类上加多了一个ContentResolver类对所有的ContentProvider进行统一管理。</p><p>　　Android 提供了3个用于辅助 ContentProvide 的工具类：</p><ul><li><strong>ContentUris</strong>：操作 URI</li><li><strong>UriMatcher</strong>：<br>1）在 ContentProvider 中注册 URI<br>2）根据 URI 匹配 ContentProvider 中对应的数据表</li><li><strong>ContentObserver</strong>：观察 URI 引起 ContentProvider 中的数据变化并通知数据访问者</li></ul><h2 id="三、用法"><a href="#三、用法" class="headerlink" title="三、用法"></a>三、用法</h2><h3 id="1-主要用法："><a href="#1-主要用法：" class="headerlink" title="1. 主要用法："></a>1. 主要用法：</h3><p>（1）使用现有的内容提供者来读取和操作现有的程序中的数据。<br>（2）创建自己的内容提供者给我们的程序提供外部访问接口。</p><h3 id="2-创建ContentProvider基本流程"><a href="#2-创建ContentProvider基本流程" class="headerlink" title="2. 创建ContentProvider基本流程"></a>2. 创建ContentProvider基本流程</h3><p>1）创建数据库类DBHelper继承自SQLiteOpenHelper<br>2）定义一个类DataProvider继承自ContentProvider<br>3）实现其onCreate、getType、insert、delete、update、query方法<br>4）在清单文件中注册ContentProvider<br>5）将访问途径Uri提供出去</p><h3 id="3-使用ContentProvider基本流程"><a href="#3-使用ContentProvider基本流程" class="headerlink" title="3. 使用ContentProvider基本流程"></a>3. 使用ContentProvider基本流程</h3><p>1）通过getContentResolver获取ContentResolver对象resolver<br>2）通过Uri对ContentProvider中的数据进行增删改查操作</p><h3 id="4-统一资源标识符（URI）"><a href="#4-统一资源标识符（URI）" class="headerlink" title="4. 统一资源标识符（URI）"></a>4. 统一资源标识符（URI）</h3><p>定义： Uniform Resource Identifier ， 即统一资源标识符<br>作用： 唯一标识 ContentProvider &amp; 其中的数据<br>　　外界进程通过 URI 找到对应的ContentProvider &amp; 其中的数据， 再进行数据操作。<br>具体使用：<br>　　URI分为 系统预置（如通讯录、 日程表等） &amp; 自定义<br><img src="/images/img_uri.jpg" alt="img_uri"></p><h2 id="四、优点"><a href="#四、优点" class="headerlink" title="四、优点"></a>四、优点</h2><h3 id="1-安全"><a href="#1-安全" class="headerlink" title="1. 安全"></a>1. 安全</h3><p>　　ContentProvider为应用间的数据交互提供了一个安全的环境：允许把自己的应用数据<strong>根据需求</strong>开放给其他应用进行增、删、改、 查，而不用担心因为直接开放数据库权限而带来的安全问题。</p><h3 id="2-访问简单-amp-高效"><a href="#2-访问简单-amp-高效" class="headerlink" title="2. 访问简单 &amp; 高效"></a>2. 访问简单 &amp; 高效</h3><p>　　对比于其他对外共享数据的方式，数据访问方式会因数据存储的方式而不同：</p><ul><li>采用 文件方式 对外共享数据， 需要进行文件操作读写数据；</li><li>采用 Sharedpreferences 共享数据， 需要使用sharedpreferences API读写数据<br>这使得访问数据变得复杂 &amp; 难度大。<br>　　而采用ContentProvider方式，其解耦了底层数据的存储方式， 使得无论底层数据存储采用何种方式，外界对数据的访问方式都是统一的， 这使得访问简单 &amp;　高效。</li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><img src="/images/img_content_provider_all.jpg" alt="img_content_provider_all"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt;内容提供者（ContentProvider）&lt;/strong&gt; 是用于在不同的应用程序之间实现数据共享的一种组件。它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件之BroadcastReceiver</title>
    <link href="https://lvmdu.gitee.io/2020/02/27/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BBroadcastReceiver/"/>
    <id>https://lvmdu.gitee.io/2020/02/27/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BBroadcastReceiver/</id>
    <published>2020-02-27T03:16:00.000Z</published>
    <updated>2020-02-28T01:02:42.005Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong>广播接收者（BroadcastReceiver）</strong> 是Android中用于接收广播的一种组件。广播是一种广泛运用的在应用程序之间传递信息的机制。广播类似于Java中的观察者模式，广播的内容是一个携带信息的Intent。</p><a id="more"></a><h2 id="一、广播的分类"><a href="#一、广播的分类" class="headerlink" title="一、广播的分类"></a>一、广播的分类</h2><h3 id="1-按形式分："><a href="#1-按形式分：" class="headerlink" title="1. 按形式分："></a>1. 按形式分：</h3><ul><li>标准广播：异步执行、没有先后顺序、效率高、无法被截断</li><li>有序广播：同步执行、有先后顺序、效率低、可以被截断（前面的广播可以截断后面正在传递的广播）<h3 id="2-按级别分："><a href="#2-按级别分：" class="headerlink" title="2. 按级别分："></a>2. 按级别分：</h3></li><li>普通广播：正常定义的广播（注意：广播是可以跨App直接通信的）</li><li>系统广播：系统定义的广播</li><li>本地广播：可理解为一种局部广播， 广播的发送者和接收者都同属于一个App。<br>相比于全局广播（普通广播），本地广播优势体现在：安全性高、效率高</li><li>粘性广播：Intent会一直保留到广播事件结束，并且没有10秒限制。（10秒限制是指普通的广播如果onReceive方法执行时间太长，超过10秒的时候系统会将这个广播置为可以干掉的candidate，一旦系统资源不够的时候，就会干掉这个广播而让它不执行。）</li></ul><p><strong>注意：</strong><br>粘性广播在Android 5.0(API 21)中已弃用。</p><h2 id="二、注册方式"><a href="#二、注册方式" class="headerlink" title="二、注册方式"></a>二、注册方式</h2><h3 id="1-动态注册"><a href="#1-动态注册" class="headerlink" title="1. 动态注册"></a>1. 动态注册</h3><p>（1）创建一个自定义的广播接收者，继承于BroadcastReceiver，并重写onReceive方法。<br>（2）在Activity中，通过registerReceiver方法注册广播接收者。</p><ul><li>非常驻型广播：跟随组件的生命周期，如果应用程序关闭，动态注册的广播就无法接收</li><li>优先级较高</li></ul><p><strong>注意：</strong><br>1）在Activity生命周期结束前，记得注销广播接收者，否则会导致内存泄漏。<br>2）动态注册广播最好应该在onResume中注册、在onPause()中注销。</p><h3 id="2-静态注册"><a href="#2-静态注册" class="headerlink" title="2. 静态注册"></a>2. 静态注册</h3><p>（1）创建一个自定义的广播接收者，继承于BroadcastReceiver，并重写onReceive方法。<br>（2）在AndroidManifest文件中，通过&lt;receiver&gt;标签注册广播接收者。</p><ul><li>常驻型广播：不受组件生命周期的影响，即使应用程序关闭，静态注册的广播仍能够接收</li><li>优先级较低<br>缺点：耗电、占内存</li></ul><p><strong>注意：</strong></p><ol><li><strong>Android 8.0以上版本，绝大部分的广播不能进行静态注册。</strong> 由于静态注册的方式非常的耗电，Google专门进行了优化。</li><li><strong>不要在onReceive()方法中进行任何耗时操作。</strong> 由于，onReceive()方法运行在主线程中，耗时操作会导致ANR（通常是10秒）。</li><li><strong>广播接收者不允许开启子线程</strong>，原因：</li></ol><ul><li>对于静态注册的广播接收者来说，广播接收者对象的生命周期较短，执行完onReceive()方法就会变为垃圾对象而被回收。在子线程执行完之前，若对应的Activity退出，他们所在进程就变成了空进程(没有任何活动组件的进程)，系统需要内存时可能会优先终止该进程，进程被终止，其内的子线程也会被终止，导致子线程无法执行完。</li><li>对于动态注册的广播接收者来说，Activity退出时会调用unregisteReceiver()方法执行解注册，此时广播接收者对象也会变成垃圾对象而被回收。在子线程执行完之前，对应的Activity退出，同样它们所在进程就变成了空进程，其内的子线程也无法执行完。</li></ul><ol start="4"><li><strong>如果必须执行耗时任务可以考虑，在onReceive中开启服务来执行。</strong> 系统就会认为这个进程里还有其他活动组件在运行，就不会任意时刻回收此进程。</li></ol><h2 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h2><p><img src="/images/img_broadcast_receiver.jpg" alt="img_broadcast_receiver"></p><ol><li>广播接收者通过<strong>Binder机制</strong>向AMS(Activity Manager Service)进行注册；</li><li>广播发送者通过<strong>Binder机制</strong>向AMS发送广播；</li><li>AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，AMS将广播发送到上述符合条件的BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；</li><li>BroadcastReceiver通过消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。</li></ol><p><strong>注意：</strong><br>　　广播发送者和广播接收者的执行是<strong>异步</strong>的，发出去的广播不会关心有无接收者接收，也不确定接收者到底是何时才能接收到。</p><h2 id="四、LocalBroadcastManager"><a href="#四、LocalBroadcastManager" class="headerlink" title="四、LocalBroadcastManager"></a>四、LocalBroadcastManager</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h3><p>（1）使用它发送的广播只能在自身App内传播，因此不必担心泄漏隐私数据；<br>（2）其它App无法对你的App发送广播，具有更高的安全性；<br>（3）比系统的全局广播更加高效。</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>　　内部是通过<strong>Handler</strong>实现的。它的sendBroadcast方法其实是通过Handler发送了一个Message。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt;广播接收者（BroadcastReceiver）&lt;/strong&gt; 是Android中用于接收广播的一种组件。广播是一种广泛运用的在应用程序之间传递信息的机制。广播类似于Java中的观察者模式，广播的内容是一个携带信息的Intent。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(六) 数学问题</title>
    <link href="https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-6-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
    <id>https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-6-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-26T13:04:00.000Z</published>
    <updated>2020-02-26T13:24:30.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h3><p><strong><em>题目描述：</em></strong><br>输入一个整数，输出概述二进制表示中1的个数，其中负数用补码表示<br>时间限制：1秒 空间限制：32768K</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：每一位和 1 相与：1 -&gt; 1  0 -&gt; 0</span></span><br><span class="line"><span class="comment">     *       然后将1每次左移一位，1 -&gt; 10 -&gt; 100 ...</span></span><br><span class="line"><span class="comment">     *       统计需要做多少次运算变成0</span></span><br><span class="line"><span class="comment">     *       （该方法无法通过全部的测试用例）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = ~n + <span class="number">1</span>;  <span class="comment">//求补码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getNumberOf1(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：一个整数减去1和原整数想与，</span></span><br><span class="line"><span class="comment">     *       会将该整数最右边的一个1变成0，</span></span><br><span class="line"><span class="comment">     *       统计需要做多少次运算将变成0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf11</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h3><p><strong><em>题目描述</em></strong><br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：传统公式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//        int exp = Math.abs(exponent);</span></span><br><span class="line">        <span class="keyword">int</span> exp = exponent;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exp = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exp; i++) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：数学函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power1</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result;</span><br><span class="line">        <span class="keyword">if</span> (exponent &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            result = Math.pow(base, exponent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = Math.pow(base, -exponent);</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法3：按位运算</span></span><br><span class="line"><span class="comment">     * 举例: 10^1101 = 10^0001*10^0100*10^1000。</span></span><br><span class="line"><span class="comment">     *      通过&amp;1和&gt;&gt;1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power2</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> exp = exponent;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exp = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (exp != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((exp &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                result *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            base *= base;</span><br><span class="line">            exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &lt; <span class="number">0</span> ? <span class="number">1</span> / result : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31-从1到n整数中1出现的次数"><a href="#31-从1到n整数中1出现的次数" class="headerlink" title="31. 从1到n整数中1出现的次数"></a>31. 从1到n整数中1出现的次数</h3><p><strong><em>题目描述</em></strong><br>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？<br>为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。<br>ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp % <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="46-圆圈中最后剩下的数"><a href="#46-圆圈中最后剩下的数" class="headerlink" title="46. 圆圈中最后剩下的数"></a>46. 圆圈中最后剩下的数</h3><p><strong><em>题目描述</em></strong><br>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。<br>HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。<br>然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,<br>然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….<br>直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。<br>请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 模拟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//约瑟夫环问题</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            s = (s + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48. 不用加减乘除做加法"></a>48. 不用加减乘除做加法</h3><p><strong><em>题目描述</em></strong><br>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num1 ^ num2;</span><br><span class="line">            num2 =  (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;11-二进制中1的个数&quot;&gt;&lt;a href=&quot;#11-二进制中1的个数&quot; class=&quot;headerlink&quot; title=&quot;11. 二进制中1的个数&quot;&gt;&lt;/a&gt;11. 二进制中1的个数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;题目描述：&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;输入一个整数，输出概述二进制表示中1的个数，其中负数用补码表示&lt;br&gt;时间限制：1秒 空间限制：32768K&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://lvmdu.gitee.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lvmdu.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(五) 动态规划</title>
    <link href="https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-02-26T12:54:00.000Z</published>
    <updated>2020-02-26T13:27:39.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h3><p><strong><em>题目描述</em></strong><br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39<br>斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……</p><a id="more"></a><p>在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           result = num1 + num2;</span><br><span class="line">           num1 = num2;</span><br><span class="line">           num2 = result;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划（递归）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> f[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      f[n] = Fibonacci2(n - <span class="number">1</span>) + Fibonacci2(n - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划（非递归）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> f[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(k &lt;= n) &#123;</span><br><span class="line">        f[k] = f[k-<span class="number">1</span>] + f[k-<span class="number">2</span>];</span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递推公式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">       <span class="keyword">double</span> root1 = (<span class="number">1</span> + sqrt5) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">double</span> root2 = (<span class="number">1</span> - sqrt5) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">new</span> Double((Math.pow(root1, n) - Math.pow(root2, n)) / sqrt5)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h3><p><strong><em>题目描述</em></strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于本题,前提只有 一次 1阶或者2阶的跳法。</span></span><br><span class="line"><span class="comment">a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);</span></span><br><span class="line"><span class="comment">b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)</span></span><br><span class="line"><span class="comment">c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"><span class="comment">d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</span></span><br><span class="line"><span class="comment">e.可以发现最终得出的是一个斐波那契数列：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           | 1, (n=1)</span></span><br><span class="line"><span class="comment">f(n) =     | 2, (n=2)</span></span><br><span class="line"><span class="comment">           | f(n-1)+f(n-2) ,(n&gt;2,n为整数)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>) + JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h3><p><strong><em>题目描述</em></strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1:1 2:2 3:4 4:8</span></span><br><span class="line"><span class="comment">可得规律</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-矩阵覆盖"><a href="#10-矩阵覆盖" class="headerlink" title="10. 矩阵覆盖"></a>10. 矩阵覆盖</h3><p><strong><em>题目描述</em></strong><br>我们可以用2<em>1的小矩阵横着或者竖着区覆盖更大的矩阵。<br>请问用n个2\</em>1的小矩阵无重叠地覆盖一个2*n的大矩阵，总共多少种方法？<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">斐波那契数列变形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target-<span class="number">1</span>) + RectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;7-斐波那契数列&quot;&gt;&lt;a href=&quot;#7-斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;7. 斐波那契数列&quot;&gt;&lt;/a&gt;7. 斐波那契数列&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;题目描述&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。&lt;br&gt;n&amp;lt;=39&lt;br&gt;斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://lvmdu.gitee.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lvmdu.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(四) 树</title>
    <link href="https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-4-%E6%A0%91/"/>
    <id>https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-4-%E6%A0%91/</id>
    <published>2020-02-26T12:12:00.000Z</published>
    <updated>2020-02-26T13:27:37.278Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h3><p><strong><em>题目描述</em></strong><br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。<br>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。<br>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><a id="more"></a><p>时间限制：1秒 空间限制：32768K<br>本题知识点： 二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length != in.length || pre.length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归，构建原始二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre  前序遍历序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ps   前序遍历起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pe   前序遍历终止位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in   后序遍历序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is   后序遍历起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ie   后序遍历终止位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, <span class="keyword">int</span>[] in, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ps &gt; pe) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = pre[ps];</span><br><span class="line">        <span class="keyword">int</span> index = is;</span><br><span class="line">        <span class="comment">//中序遍历中找到根节点的位置</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt;= ie &amp;&amp; in[index] != root) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果在整个中序遍历的数组中没有找到，证明输入不合法，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; ie) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Invalid Input"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归构建子二叉树</span></span><br><span class="line">        TreeNode treeNode = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        <span class="comment">//左子树的元素个数：index-is+1</span></span><br><span class="line">        <span class="comment">//左子树对应的前序遍历的位置是：[ps+1, ps+index-is]</span></span><br><span class="line">        <span class="comment">//左子树对应的中序遍历的位置是：[is, index-1]</span></span><br><span class="line">        treeNode.left = constructBinaryTree(pre, ps+<span class="number">1</span>, ps+index-is, in, is, index-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右子树的元素个数：ie-index</span></span><br><span class="line">        <span class="comment">//右子树对应的前序遍历的位置是：[ps+index-is+1, pe]</span></span><br><span class="line">        <span class="comment">//右子树对应的中序遍历的位置是：[index+1, ie]</span></span><br><span class="line">        treeNode.right = constructBinaryTree(pre, ps+index-is+<span class="number">1</span>, pe, in, index+<span class="number">1</span>, ie);</span><br><span class="line">        <span class="keyword">return</span> treeNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17. 树的子结构"></a>17. 树的子结构</h3><p><strong><em>题目描述</em></strong><br>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;  <span class="comment">//此时Tree2先遍历完，证明是子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) &#123;  <span class="comment">//此时Tree1先遍历完，证明不是子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1.val == root2.val &amp;&amp; isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18. 二叉树的镜像"></a>18. 二叉树的镜像</h3><p><strong><em>题目描述</em></strong><br>操作给定的二叉树，将其变换为源二叉树的镜像。<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入描述:</span></span><br><span class="line"><span class="comment">二叉树的镜像定义：</span></span><br><span class="line"><span class="comment">源二叉树</span></span><br><span class="line"><span class="comment">        8</span></span><br><span class="line"><span class="comment">       / \</span></span><br><span class="line"><span class="comment">      6   10</span></span><br><span class="line"><span class="comment">     / \  / \</span></span><br><span class="line"><span class="comment">    5  7 9  11</span></span><br><span class="line"><span class="comment">    镜像二叉树</span></span><br><span class="line"><span class="comment">        8</span></span><br><span class="line"><span class="comment">       / \</span></span><br><span class="line"><span class="comment">      10   6</span></span><br><span class="line"><span class="comment">     / \  / \</span></span><br><span class="line"><span class="comment">    11 9 7  5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22. 从上往下打印二叉树"></a>22. 从上往下打印二叉树</h3><p>题目描述<br>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：使用队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：不使用队列 (使用ArrayList模拟队列)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = list.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38. 二叉树的深度"></a>38. 二叉树的深度</h3><p><strong><em>题目描述</em></strong><br>输入一棵二叉树，求该树的深度。<br>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(TreeDepth(root.left) + <span class="number">1</span>, TreeDepth(root.right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60. 把二叉树打印成多行"></a>60. 把二叉树打印成多行</h3><p><strong><em>题目描述</em></strong><br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        depth(pRoot, <span class="number">1</span>, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">depth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; list.size()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        list.get(depth-<span class="number">1</span>).add(root.val);</span><br><span class="line">        depth(root.left, depth + <span class="number">1</span>, list);</span><br><span class="line">        depth(root.right, depth + <span class="number">1</span>, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;4-重建二叉树&quot;&gt;&lt;a href=&quot;#4-重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;4. 重建二叉树&quot;&gt;&lt;/a&gt;4. 重建二叉树&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;题目描述&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。&lt;br&gt;假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;br&gt;例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://lvmdu.gitee.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lvmdu.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(三) 栈和队列</title>
    <link href="https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2020-02-26T11:54:00.000Z</published>
    <updated>2020-02-26T13:27:49.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5. 用两个栈实现队列"></a>5. 用两个栈实现队列</h3><p><strong><em>题目描述</em></strong><br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 队列 栈</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20. 包含min函数的栈"></a>20. 包含min函数的栈</h3><p><strong><em>题目描述</em></strong><br>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; smin = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        st.push(node);</span><br><span class="line">        <span class="keyword">if</span> (smin.empty()) &#123;</span><br><span class="line">            smin.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node &lt; smin.peek()) &#123;</span><br><span class="line">            smin.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st.peek() == smin.peek()) &#123;</span><br><span class="line">            smin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> smin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21. 栈的压入、弹出序列"></a>21. 栈的压入、弹出序列</h3><p><strong><em>题目描述</em></strong><br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。<br>假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，<br>但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：使用栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pushA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> popA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span> &amp;&amp; stack.peek() == popA[j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不使用栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pushA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> popA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder1</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pushA[i] != popA[j]) &#123;</span><br><span class="line">                arrayList.add(pushA[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrayList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrayList.get(i) != popA[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;5-用两个栈实现队列&quot;&gt;&lt;a href=&quot;#5-用两个栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;5. 用两个栈实现队列&quot;&gt;&lt;/a&gt;5. 用两个栈实现队列&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;题目描述&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;br&gt;时间限制：1秒 空间限制：32768K&lt;br&gt;本题知识点： 队列 栈&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://lvmdu.gitee.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lvmdu.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件之Service</title>
    <link href="https://lvmdu.gitee.io/2020/02/26/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BService/"/>
    <id>https://lvmdu.gitee.io/2020/02/26/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BService/</id>
    <published>2020-02-26T09:33:00.000Z</published>
    <updated>2020-02-27T08:21:25.698Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong>服务（Service）</strong> 是一种可以在后台执行长时间运行操作而没有用户界面的组件。<br>　　比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。　　</p><a id="more"></a><p><strong>注意：</strong></p><ol><li><strong>Service默认运行在UI线程（主线程）中， 因此， 不要在Service中执行耗时的操作。</strong>　除非在Service中创建子线程。</li><li>Android的后台就是指它的运行是完全不依赖UI（线程）。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。</li></ol><h2 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h2><p><img src="/images/img_service_life_cycle.png" alt="img_service_life_cycle"></p><h3 id="1-startService-stopService"><a href="#1-startService-stopService" class="headerlink" title="1.startService / stopService"></a>1.startService / stopService</h3><p><strong>生命周期顺序： onCreate-&gt;onStartCommand-&gt;onDestroy</strong><br>　　如果一个Service被某个Activity 调用 Context.startService方法启动， 那么不管是否有Activity使用bindService绑定或unbindService解除绑定到该Service， 该Service都在后台运行， 直到被调用stopService， 或自身的stopSelf方法。 当然如果系统资源不足， android系统也可能结束服务， 还有一种方法可以关闭服务， 在设置中， 通过应用-&gt;找到自己应用-&gt;停止。<br><strong>注意点：</strong><br>①第一次 startService 会触发 onCreate 和 onStartCommand， 以后在服务运行过程中， 每次 startService 都<strong>只会触发 onStartCommand</strong><br>②不论 startService 多少次， stopService 一次就会停止服务</p><h3 id="2-bindService-unbindService"><a href="#2-bindService-unbindService" class="headerlink" title="2.bindService / unbindService"></a>2.bindService / unbindService</h3><p><strong>生命周期顺序： onCreate-&gt;onBind-&gt;onUnBind-&gt;onDestroy</strong><br>　　如果一个Service在某个Activity中被调用bindService方法启动， 不论bindService被调用几次， Service的onCreate方法只会执行一次， 同时onStartCommand方法始终不会调用。<br>当建立连接后， Service会一直运行， 除非调用unbindService来接触绑定、 断开连接或调用该Service的Context不存在了（如Activity被Finish——即<strong>通过bindService启动的Service的生命周期依附于启动它的Context</strong>）， 系统在这时会自动停止该Service。<br><strong>注意点：</strong><br>第一次 bindService 会触发 onCreate 和 onBind， 以后在服务运行过程中， 每次 bindService 都<strong>不会触发任何回调</strong></p><h3 id="3-混合型（上面两种方式的交互）"><a href="#3-混合型（上面两种方式的交互）" class="headerlink" title="3.混合型（上面两种方式的交互）"></a>3.混合型（上面两种方式的交互）</h3><p>　　当一个Service在被启动(startService)的同时又被绑定(bindService)， 该Service将会一直在后台运行， 并且不管调用几次， onCreate方法始终只会调用一次， onStartCommand的调用次数与startService调用的次数一致（使用bindService方法不会调用onStartCommand）。 同时， 调用unBindService将不会停止Service， 必须调用stopService或Service自身的stopSelf来停止服务。</p><h2 id="二、启动方式"><a href="#二、启动方式" class="headerlink" title="二、启动方式"></a>二、启动方式</h2><h3 id="1-startService"><a href="#1-startService" class="headerlink" title="1. startService"></a>1. startService</h3><p>首先，在AndroidManifest文件中进行注册。<br>(1)服务端，创建BindService并继承自Service。<br>(2)客户端，通过startService()方法启动服务。</p><h3 id="2-bindService"><a href="#2-bindService" class="headerlink" title="2. bindService"></a>2. bindService</h3><p>首先，在AndroidManifest文件中进行注册。<br>(1)服务端，创建BindService并继承自Service；创建一个实现IBindler接口的实例对象，并提供公共方法给客户端调用；从onBind()回调方法返回此Binder实例。<br>(2)客户端，创建一个ServiceConnection对象，并在其onServiceConnected()回调方法中接收Binder对象；然后通过bindService()方法绑定服务。</p><h2 id="三、类型"><a href="#三、类型" class="headerlink" title="三、类型"></a>三、类型</h2><h3 id="1-按运行位置："><a href="#1-按运行位置：" class="headerlink" title="1. 按运行位置："></a>1. 按运行位置：</h3><ul><li>本地服务（Local Service）：服务依附于主进程</li><li>远程服务（Remote Service）：服务为独立的进程<h3 id="2-按运行类型："><a href="#2-按运行类型：" class="headerlink" title="2. 按运行类型："></a>2. 按运行类型：</h3></li><li>前台服务：通知栏显示Notification，如天气更新、日期同步等</li><li>后台服务：通知栏不显示Notification，如音乐播放器<h3 id="3-按启动方式："><a href="#3-按启动方式：" class="headerlink" title="3. 按启动方式："></a>3. 按启动方式：</h3></li><li>startService启动的服务</li><li>bindService启动的服务</li><li>同时用两种方式启动的服务</li></ul><h2 id="四、Service和Thread的区别"><a href="#四、Service和Thread的区别" class="headerlink" title="四、Service和Thread的区别"></a>四、Service和Thread的区别</h2><p>　　本质上来说，两者没有任何关系，它们是完全不同的概念。</p><ol><li>定义上：</li></ol><ul><li>Thread：Thread是程序执行的最小单元，它是分配CPU的基本单位。可以用Thread来执行一些异步的操作。</li><li>Service：Service是android的一种机制，当它运行的时候如果是Local Service，那么对应的Service是运行在<strong>主进程的主线程上</strong>；如果是Remote Service，那么对应的Service则是运行在<strong>独立进程的主线程上</strong>。</li></ul><ol start="2"><li>使用上：</li></ol><ul><li>Thread的运行是独立的，也就是说当一个Activity被finish之后，如果没有主动停止Thread或者Thread里的run方法没有执行完毕的话，Thread也会一直执行。 这样会导致的问题：1) 当Activity被finish之后，不再持有该Thread的引用，也就是不能再控制该Thread。2）没有办法在不同的Activity中对同一Thread进行控制。</li><li>所有的Activity都可以与Service进行关联，也就是说多个Activity可以同时控制同一个Service，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。</li></ul><p><strong>什么时候使用Service，什么时候使用Thread呢?</strong><br>（1）在应用中，如果是<strong>长时间的在后台运行，而且不需要交互</strong>的情况下，使用<strong>Service</strong>。<br>（2）在后台运行，不需要交互的情况下，如果只是完成某个任务，之后就不需要运行，而且可能是多个任务，需要长时间运行的情况下，使用<strong>Thread</strong>。<br>（3）如果任务占用CPU时间多，资源大的情况下，使用<strong>Thread</strong>。</p><h2 id="五、IntentService"><a href="#五、IntentService" class="headerlink" title="五、IntentService"></a>五、IntentService</h2><p> 　　继承于Service，内部有一个HandlerThread对象，可以看做是Service和HandlerThread的结合体。</p><h3 id="1-特点："><a href="#1-特点：" class="headerlink" title="1. 特点："></a>1. 特点：</h3><ul><li>在IntentService<strong>内有一个工作线程</strong>来处理耗时操作。</li><li>当任务执行完后，IntentService 会自动停止，不需要我们去手动结束。</li><li>如果启动 IntentService 多次，那么每一个耗时操作会以工作队列的方式在 IntentService 的 onHandleIntent 回调方法中执行，依次去执行，使用串行的方式，执行完自动结束。</li></ul><h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h3><p><img src="/images/img_service_intent_service.jpg" alt="img_service_intent_service"></p><p> <strong>注意：</strong> 若启动IntentService多次， 那么每个耗时操作则以队列的方式在IntentService的onHandleIntent回调方法中依次执行， 执行完自动结束。</p><p> <strong>启动IntentService为什么不需要新建线程？</strong><br>　　IntentService内部的HandlerThread继承自Thread，内部封装了Looper，在这里新建线程并启动，所以启动IntentService不需要新建线程。</p><p><strong>为什么多次启动 IntentService 会顺序执行事件，停止服务后，后续的事件得不到执行？</strong><br>　　IntentService 中使用的 Handler、Looper、MessageQueue 机制把消息发送到线程中去执行的，所以<strong>多次启动IntentService不会重新创建新的服务和新的线程</strong>，只是把消息加入消息队列中等待执行，而如果服务停止，会清除消息队列中的消息，后续的事件得不到执行。</p><h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><ul><li>线程任务需要按顺序、 在后台执行的使用场景</li></ul><p><em>最常见的场景：离线下载</em></p><ul><li>由于所有的任务都在同一个Thread looper里面来做， 所以不符合多个数据同时请求的场景。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt;服务（Service）&lt;/strong&gt; 是一种可以在后台执行长时间运行操作而没有用户界面的组件。&lt;br&gt;　　比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。
　　&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件之Activity</title>
    <link href="https://lvmdu.gitee.io/2020/02/26/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity/"/>
    <id>https://lvmdu.gitee.io/2020/02/26/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity/</id>
    <published>2020-02-26T07:51:00.000Z</published>
    <updated>2020-02-28T00:34:30.813Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong>活动（Activity）</strong> 是一种可以包含用户界面的组件，主要用于和用户进行交互。</p><a id="more"></a><h2 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h2><p><img src="/images/img_activity_life_cycle.jpg" alt="img_activity_life_cycle"></p><p>同时，生命周期也对应了Activity的<strong>四种状态</strong>：</p><p>1) 运行状态(Running)<br>2) 暂停状态(Paused)<br>3) 停止状态(Stopped)<br>4) 销毁状态(Killed)</p><p><strong>注意</strong><br>onStart()和onResume()区别：</p><ul><li>onStart()：前台不可见，不能进行交互</li><li>onResume()：前台可见，可以进行交互</li></ul><h3 id="特定场景下的生命周期回调："><a href="#特定场景下的生命周期回调：" class="headerlink" title="特定场景下的生命周期回调："></a>特定场景下的生命周期回调：</h3><p>（1）用户打开新的Activiy的时候，之前的Activity： onPause()-&gt;onStop()<br>（2）按Back键回退时： onPause()-&gt;onStop()-&gt;onDestory()<br>（3）按Home键切换到桌面后又回到该Actitivy： onPause()-&gt;onStop()-&gt;onRestart()-&gt;onStart()-&gt;onResume()<br>（4）调用finish()方法： onDestory()<br>（5）横竖屏切换：onPause()-&gt;onSaveInstanceState()-&gt; onStop()-&gt;onDestroy()-&gt;onCreate()-&gt;onStart()-&gt;onRestoreInstanceState()-&gt;onResume()</p><h4 id="onSaveInstanceState和onRestoreInstanceState"><a href="#onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="onSaveInstanceState和onRestoreInstanceState"></a>onSaveInstanceState和onRestoreInstanceState</h4><p>　　在Activity由于异常情况下终止时， 系统会调用<strong>onSaveInstanceState</strong>来保存当前Activity的状态。 当异常终止的Activity被重建以后， 系统会调用<strong>onRestoreInstanceState</strong>， 并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象参数同时传递给onRestoreInstanceState和onCreate方法。<br>onCreate和onRestoreInstanceState方法来恢复Activity的状态的区别：<br>onRestoreInstanceState回调则表明其中Bundle对象非空， 不用加非空判断； onCreate需要非空判断。 建议使用onRestoreInstanceState。<br><strong>调用时机：</strong></p><ul><li>onSaveInstanceState()：onStop()之前</li><li>onRestoreInstanceState()：onStart()之后</li></ul><p>通过在AndroidManifest文件的Activity中指定如下属性：</p><blockquote><p>android:configChanges = “orientation|screenSize”</p></blockquote><p>来避免横竖屏切换时， Activity的销毁和重建。<br>而是回调了下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、启动模式"><a href="#二、启动模式" class="headerlink" title="二、启动模式"></a>二、启动模式</h2><h3 id="1-标准模式（Standard）"><a href="#1-标准模式（Standard）" class="headerlink" title="1. 标准模式（Standard）"></a>1. 标准模式（Standard）</h3><p>　　每启动一次Activity，就会创建一个新的Activity实例并置于栈顶。</p><h3 id="2-栈顶复用模式（SingleTop）"><a href="#2-栈顶复用模式（SingleTop）" class="headerlink" title="2. 栈顶复用模式（SingleTop）"></a>2. 栈顶复用模式（SingleTop）</h3><p>　　如果需要新建的Activity位于任务栈栈顶，那么此Activity的实例就不会重建，而是重用栈顶的实例。<br><strong>应用场景：</strong><br>（1）在通知栏点击收到的通知，然后需要启动一个Activity，这个Activity就可以用singleTop，否则每次点击都会新建一个Activity。<br>（2）某个场景下连续快速点击，启动了两个Activity。如果这个时候待启动的Activity使用SingleTop模式可以避免这个Bug。</p><h3 id="3-栈内复用模式（SingleTask）"><a href="#3-栈内复用模式（SingleTask）" class="headerlink" title="3. 栈内复用模式（SingleTask）"></a>3. 栈内复用模式（SingleTask）</h3><p>　　该模式是一种<strong>单例模式</strong>，即<strong>一个栈内只有一个该Activity实例</strong>。该模式可以通过在AndroidManifest文件中Activity的android:taskAffinity属性的需要加载到那个栈中。<br>　　如果Activity指定的栈不存在，则创建一个栈，并把创建的Activity压入栈内。如果Activity指定的栈存在，如果其中没有该Activity实例，则会创建Activity并压入栈顶，如果其中有该Activity实例，则把该Activity实例之上的Activity清除出栈，重用并让该Activity实例处在栈顶。<br><strong>应用场景：</strong><br>　　大多数App的主页。对于大部分应用，当我们在主界面点击回退按钮的时候都是退出应用，那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，主界面Activity上所有的Activity都会被移除，从而主界面Activity处于栈顶。通过这种方式能够保证退出应用时所有的Activity都能销毁。</p><h3 id="4-单例模式（SingleInstance）"><a href="#4-单例模式（SingleInstance）" class="headerlink" title="4. 单例模式（SingleInstance）"></a>4. 单例模式（SingleInstance）</h3><p>　　一个栈中只有一个Activity的实例。<br>　　一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例。<br><strong>应用场景：</strong><br>　　呼叫来电界面</p><h4 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="* 特殊情况："></a>* 特殊情况：</h4><ol><li><p>前台栈和后台栈的交互<br>假如目前有两个任务栈。 前台任务栈为AB， 后台任务栈为CD， 这里假设CD的启动模式均为SingleTask,现在请求启动D， 那么这个后台的任务栈都会被切换到前台，这个时候整个后退列表就变成了ABCD。 当用户按Back返回时， 列表中的Activity会一一出栈， 如下图：<br><img src="/images/img_activity_1.jpg" alt="img_activity_1"><br>如果不是请求启动D而是启动C， 那么情况又不一样， 如下图：<br><img src="/images/img_activity_2.jpg" alt="img_activity_2"><br>　　<strong>调用SingleTask模式的后台任务栈中的Activity， 会把整个栈的Actvity压入当前栈的栈顶。</strong> SingleTask会具有ClearTop特性， 把之上的栈内Activity清除。</p></li><li><p>SingleInstance深入理解<br>（1）A：Standard  B：SingleInstance<br> 启动顺序：A -&gt; B -&gt; A<br> 回退顺序：A -&gt; A -&gt; B<br>（2）A：Standard  B：SingleInstance C：Standard<br> 启动顺序：A -&gt; B -&gt; C<br> 回退顺序：C -&gt; A -&gt; B</p></li></ol><p><strong>注意：</strong> 回退是按照该栈的压入顺序进行的，而不是按照启动顺序进行。</p><h2 id="三、启动流程"><a href="#三、启动流程" class="headerlink" title="三、启动流程"></a>三、启动流程</h2><p><img src="/images/img_activity_start.jpg" alt="img_activity_start"></p><ol><li>Activity1调用startActivity，实际会调用Instrumentation类的execStartActivity方法</li></ol><p>Instrumentation是系统用来监控Activity运行的一个类，提供各种Activity生命周期的控制方法。</p><ol start="2"><li><p>通过跨进程的binder调用，进入到ActivityManagerService中，其内部会处理Activity栈，通知Activity1 Pause，Activity1 执行Pause 后告知AMS</p></li><li><p>在ActivityManagerService中的startProcessLocked中调用了Process.start方法。并通过连接调用Zygote的native方法forkAndSpecialize，执行fork任务。之后再通过跨进程调用进入到Activity2所在的进程中。</p></li><li><p>主线程发起bind Application，AMS会做一些配置工作，然后让主线程bind ApplicationThread，ApplicationThread将启动Activity2的信息通过H对象发送给主线程。（发送的消息是EXECUTE_TRANSACTION，消息体是一个 ClientTransaction，即 LaunchActivityItem。）主线程拿到Activity2的信息后，调用Instrumentation类的newActivity方法，其内通过ClassLoader创建Activity2实例。</p></li></ol><p>ApplicationThread是一个binder对象，其运行在binder线程池中，内部包含一个H类，该类继承于类Handler。</p><ol start="5"><li>通知Activity2去performCreate(执行onCreate方法)。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt;活动（Activity）&lt;/strong&gt; 是一种可以包含用户界面的组件，主要用于和用户进行交互。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱(三) Android进阶知识</title>
    <link href="https://lvmdu.gitee.io/2020/02/26/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-3-Android%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    <id>https://lvmdu.gitee.io/2020/02/26/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-3-Android%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/</id>
    <published>2020-02-26T05:20:00.000Z</published>
    <updated>2020-02-26T05:21:11.165Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/img_mind_map_android_2.png" alt="img_mind_map_android_2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/img_mind_map_android_2.png&quot; alt=&quot;img_mind_map_android_2&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="知识图谱" scheme="https://lvmdu.gitee.io/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="脑图" scheme="https://lvmdu.gitee.io/tags/%E8%84%91%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱(二) Android基础知识</title>
    <link href="https://lvmdu.gitee.io/2020/02/26/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-2-Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://lvmdu.gitee.io/2020/02/26/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-2-Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-02-26T02:17:00.000Z</published>
    <updated>2020-02-26T02:17:43.664Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/img_mind_map_android_1.png" alt="img_mind_map_android_1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/img_mind_map_android_1.png&quot; alt=&quot;img_mind_map_android_1&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="知识图谱" scheme="https://lvmdu.gitee.io/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="脑图" scheme="https://lvmdu.gitee.io/tags/%E8%84%91%E5%9B%BE/"/>
    
  </entry>
  
</feed>
