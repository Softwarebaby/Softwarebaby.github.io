<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flow Garden</title>
  
  <subtitle>Bob Du&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lvmdu.gitee.io/"/>
  <updated>2020-03-01T15:12:02.676Z</updated>
  <id>https://lvmdu.gitee.io/</id>
  
  <author>
    <name>Bob Du</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android系统之SystemUI</title>
    <link href="https://lvmdu.gitee.io/2020/03/01/Android%E7%B3%BB%E7%BB%9F-SystemUI/"/>
    <id>https://lvmdu.gitee.io/2020/03/01/Android%E7%B3%BB%E7%BB%9F-SystemUI/</id>
    <published>2020-03-01T15:42:00.000Z</published>
    <updated>2020-03-01T15:12:02.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是SystemUI"><a href="#一、什么是SystemUI" class="headerlink" title="一、什么是SystemUI?"></a>一、什么是SystemUI?</h2><p>　　SystemUI是为用户提供系统级别的信息显示与交互的一套UI组件。<br>　　屏幕顶端的状态栏、底部的导航栏、图片壁纸以及Recent-Panel（近期使用的APP列表）都属于SystemUI的范畴。SystemUI中还有一个名为TakeScreenshotService的服务，用于在用户按下音量下键与电源键时进行截屏操作。</p><a id="more"></a><p>　　SystemUI还提供了PowerUI和RingtonePlayer两个服务。前者负责监控系统的剩余电量并在必要时为用户显示低电警告，后者则依托AudioService向其他应用程序提供播放铃声的功能。</p><h2 id="二、SystemUIService的启动"><a href="#二、SystemUIService的启动" class="headerlink" title="二、SystemUIService的启动"></a>二、SystemUIService的启动</h2><p>　　尽管SystemUI的表现形式与普通的Android应用程序大相径庭，但它却是以一个<strong>APK</strong>的形式存在于系统之中，即它与普通的Android应用程序并没有本质上的区别。无非是通过Android 4大组件中的Activity、Service、BroadcastReceiver接受外界的请求并执行相关的操作，只不过它们所接受的请求主要来自各个系统服务而已。<br>　　SystemUI包罗万象，并且大部分功能之间相互独立，比如RecentPanel、TakeScreen-shotService等均是按需启动，并在完成其既定任务后退出，这与普通的Activity以及Service别无二致。比较特殊的是状态栏、导航栏等组件的启动方式。它们运行于一个称为<strong>SystemUIService</strong>的Service中。因此讨论<strong>状态栏与导航栏的启动过程其实就是SystemUIService的启动过程</strong>。</p><p>　　SystemUIService是一个容器。在其启动时，将会逐个实例化定义在SERVICIES列表中的继承自SystemUI抽象类的子服务。在调用子服务的start（）方法之后，SystemUIService便不再做任何其他的事情，任由各个子服务自行运行。</p><h4 id="状态栏与导航栏的启动过程："><a href="#状态栏与导航栏的启动过程：" class="headerlink" title="状态栏与导航栏的启动过程："></a>状态栏与导航栏的启动过程：</h4><ul><li>获取IStatusBarService。IStatusBarService是运行于system_server的一个系统服务，它接受操作状态栏/导航栏的请求并将其转发给BaseStatusBar。为了保证SystemUI意外退出后不会发生信息丢失，IStatusBarService保存了所有需要状态栏与导航栏进行显示或处理的信息副本。</li><li>将一个继承自IStatusBar.Stub的CommandQueue的实例注册到IStatusBarService以建立通信，并将信息副本取回。</li><li>通过调用子类的createAndAddWindows（）方法完成状态栏与导航栏的控件树及窗口的创建与显示。</li><li>使用从IStatusBarService取回的信息副本。</li></ul><h2 id="三、SystemUI-体系结构"><a href="#三、SystemUI-体系结构" class="headerlink" title="三、SystemUI 体系结构"></a>三、SystemUI 体系结构</h2><p><img src="/images/img_system_ui.png" alt="img_system_ui"></p><ul><li><strong>SystemUIService</strong>：一个普通的Android服务，它以一个容器的角色运行于SystemUI进程中。在它内部运行着多个子服务，其中之一便是状态栏与导航栏的实现者——BaseStatusBar的子类之一。</li><li><strong>StatusBarManagerService</strong>：是状态栏/导航栏向外界提供服务的前端接口，运行于system_server进程中。</li><li><strong>BaseStatusBar</strong>：BaseStatusBar及其子类是状态栏与导航栏的实际实现者，运行于SystemUIService中。</li><li><strong>CommandQueue</strong>：SystemUI中的CommandQueue是联系StatusBarManagerService与BaseStatusBar的桥梁。</li></ul><p>　　SystemUI中还包含了ImageWallpaper、RecentPanel以及TakeScreenshotService等功能的实现。它们是Service、Activity等标准的Android应用程序组件，并且互相独立。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是SystemUI&quot;&gt;&lt;a href=&quot;#一、什么是SystemUI&quot; class=&quot;headerlink&quot; title=&quot;一、什么是SystemUI?&quot;&gt;&lt;/a&gt;一、什么是SystemUI?&lt;/h2&gt;&lt;p&gt;　　SystemUI是为用户提供系统级别的信息显示与交互的一套UI组件。&lt;br&gt;　　屏幕顶端的状态栏、底部的导航栏、图片壁纸以及Recent-Panel（近期使用的APP列表）都属于SystemUI的范畴。SystemUI中还有一个名为TakeScreenshotService的服务，用于在用户按下音量下键与电源键时进行截屏操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://lvmdu.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM之垃圾收集算法和垃圾回收机制</title>
    <link href="https://lvmdu.gitee.io/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://lvmdu.gitee.io/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-01T10:07:00.000Z</published>
    <updated>2020-03-01T13:57:18.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、何时GC？"><a href="#一、何时GC？" class="headerlink" title="一、何时GC？"></a>一、何时GC？</h2><h3 id="（一）引用计数算法"><a href="#（一）引用计数算法" class="headerlink" title="（一）引用计数算法"></a>（一）引用计数算法</h3><p>　　给对象添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加1； 当引用失效时， 计数器值就减1； 任何时刻计数器为0的对象就是不可能被再使用的。<br>　　主流的JVM里面没有选用引用计数算法来管理内存， 其中最主要的原因是它<strong>很难解决对象间的互循环引用的问题</strong>。</p><a id="more"></a><h3 id="（二）可达性分析算法"><a href="#（二）可达性分析算法" class="headerlink" title="（二）可达性分析算法"></a>（二）可达性分析算法</h3><p>通过一些列的称为“<strong>GC Roots</strong>”的对象作为起始点， 从这些节点开始向下搜索， 搜索所走过的路径称为<strong>引用链</strong>， <em>当一个对象到GC Roots没有任何引用链相连时</em>（就是从GC Roots 到这个对象是不可达）， 则证明此对象是不可用的。 所以它们会被判定为可回收对象。</p><p>在Java语言中， <strong>可以作为GC Roots的对象</strong>包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象；</li></ul><p>　　总结就是， 方法运行时， 方法中引用的对象； 类的静态变量引用的对象； 类中常量引用的对象； Native方法中引用的对象</p><h4 id="判断对象“死亡”："><a href="#判断对象“死亡”：" class="headerlink" title="判断对象“死亡”："></a>判断对象“死亡”：</h4><p>　　在可达性分析算法中， 要真正宣告一个对象死亡， 至少要经历<strong>两次标记</strong>过程：</p><ol><li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链， 那它将会被第一次标记并且进行一次筛选， 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有 覆盖finalize()方法， 或者finalize()方法已经被虚拟机调用过， 虚拟机将这两种情况都视为“没有必要执行”。</li><li>如果这个对象被判定为有必要执行finalize()方法， 那么这个对象将会放置在一个叫做F-Queue队列之中， 并在稍后由一个由虚拟机自动建立的、 低优先级的Finalizer线程去执行它。 finalize()方法是对象逃脱死亡命运的最后一次机会， 稍候GC将对F-Queue中的对象进行第二次小规模的标记， 如果对象要在finalie()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可， 譬如把自己（this关键字） 赋值给某个类变量或者对象的成员变量， 那在第二次标记时它将会被移除出“即将回收”的集合； 如果对象这时候还没有逃脱， 那基本上它就真的被回收了。</li></ol><h4 id="什么是强引用、-软引用、-弱引用、-虚引用？"><a href="#什么是强引用、-软引用、-弱引用、-虚引用？" class="headerlink" title="什么是强引用、 软引用、 弱引用、 虚引用？"></a>什么是强引用、 软引用、 弱引用、 虚引用？</h4><p>在JDK1.2之后， Java对引用的概念进行了扩充， 将引用分为强引用（Strong Reference）、 软引用（Soft Reference）、 弱引用（ Weak Reference）、 虚引用（Phantom Reference）四种， 这四种引用强度依次逐渐减弱。</p><ul><li>强引用： 就是指在程序代码之中普遍存在的， 类似“Object obj = new Object()”这类的引用， 只要强引用还存在， 垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用： 用来描述一些还有用但并非必须的对象。 在系统将要发生内存溢出异常之前， 将会把这些对象列进回收范围之中进行第二次回收。使用SoftReference来实现软引用。</li><li>弱引用： 用户描述非必须对象的。 被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 当垃圾收集器工作时， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。使用WeakReference来实现弱引用。</li><li>虚引用： 也称幽灵引用或幻影引用。 一个对象是否有虚引用存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例。 为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时刻得到一个系统通知。使用PhantomReference来实现虚引用。</li></ul><h2 id="二、垃圾收集算法"><a href="#二、垃圾收集算法" class="headerlink" title="二、垃圾收集算法"></a>二、垃圾收集算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h3><p>　　最基础的收集算法是“标记-清除”（Mark-Sweep）算法， 算法分为“标记”和“清除”两个阶段：<br>① 首先标记出所有需要回收的对象。<br>② 在标记完成后统一回收所有被标记的对象。<br>缺点：<br>效率问题： 标记和清除两个过程的效率都不高<br>空间问题： 标记清除之后产生大量不连续的内存碎片， 空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时， 无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h3><p>　　复制算法是为了解决效率问题。将可用内存按容量大小划分为大小相等的两块， 每次只使用其中的一块。 当一块内存使用完了， 就将还存活着的对象复制到另一块上面， 然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对整个半区进行内存回收， 内存分配时也就不用考虑内存碎片等复杂情况。<br>缺点： 将内存缩小为了原来的一半。</p><p>　　<strong>新生代</strong>中对象98%对象是“朝生夕死”的， 所以不需要按照1： 1的比例来划分内存空间， 而是将内存分为较大的Eden空间和两块较小的Survivor空间， 每次使用Eden和其中一块Survivor。 当回收时， 将Eden和Survivor中还存活着的对象一次性地复制到另外一块Eden空间上， 最后清理掉Eden和刚才用过的Survivor空间。</p><p>　　HotSpot虚拟机中默认Eden和Survivor的大小比例是8 : 1。这样只有10%的空间会被浪费。当然，如果另外空间一块Survivor空间没有足够空间（需要的空间大于10%）存放上一次新生代收集下来的存活对象时，这些对象将直接通过<strong>分配担保机制</strong>进入老年代。</p><h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3. 标记-整理算法"></a>3. 标记-整理算法</h3><p>　　复制算法在对象存活率较高时， 就要进行较多的复制操作， 效率就会变低。 根据<strong>老年代</strong>的特点， 提出了“标记-整理”算法。<br>标记过程仍然与”标记-清除“算法一样， 但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向一端移动， 然后直接清理掉边界以外的内存。</p><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><p>一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>， 这样就可以根据各个年代的特点采用最适当的收集算法。<br>（1）在新生代中， 每次垃圾收集时都发现有大批对象死去， 只有少量存活， 那就选用复制算法。<br>（2）在老年代中， 因为对象存活率高、 没有额外空间对它进行分配担保， 就必须采用“标记-清除”或“标记-整理”算法来进行回收。</p><h2 id="三、垃圾回收机制（GC）"><a href="#三、垃圾回收机制（GC）" class="headerlink" title="三、垃圾回收机制（GC）"></a>三、垃圾回收机制（GC）</h2><p>　　垃圾回收机制（Garbage Collection），简称GC。是Java语言的核心技术之一， 在Java中，当一个对象不能再被后续程序所引用到时，这个对象所占用的内存空间就没有存在的意义了，Java虚拟机会不定时的去检测内存中这样的对象，然后自动回收这块内存空间。这个机制就叫做垃圾回收机制。<br>　　下面介绍一些有关GC的概念问题。</p><h3 id="1-Minor-GC-和-Full-GC"><a href="#1-Minor-GC-和-Full-GC" class="headerlink" title="1. Minor GC 和 Full GC"></a>1. Minor GC 和 Full GC</h3><ul><li>Minor GC：指发生在新生代的垃圾收集动作， 该动作非常频繁。</li><li>Full GC/Major GC：指发生在老年代的垃圾收集动作， 出现了Major GC， 经常会伴随至少一次的Minor GC。 Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h3 id="2-JVM中的年代"><a href="#2-JVM中的年代" class="headerlink" title="2. JVM中的年代"></a>2. JVM中的年代</h3><p>　　JVM中分为年轻代（Young generation）和老年代(Tenured generation)。HotSpot JVM把年轻代分为了三部分： 1个Eden区和2个Survivor区（ 分别叫from和to） 。 默认比例为8： 1。<br>　　一般情况下， 新创建的对象都会被分配到Eden区(一些大对象特殊处理)， 这些对象经过第一次Minor GC后， 如果仍然存活， 将会被移到Survivor区。 对象在Survivor区中每熬过一次Minor GC， 年龄就会增加1岁， 当它的年龄增加到一定程度时， 就会被移动到年老代中。 因为年轻代中的对象基本都是朝生夕死的(80%以上)， 所以在年轻代的垃圾回收算法使用的是复制算法。复制算法不会产生内存碎片。在GC开始的时候， 对象只会存在于Eden区和名为“From”的Survivor区， Survivor区“To”是空的。 紧接着进行GC， Eden区中所有存活的对象都会被复制到“To”， 而在“From”区中， 仍存活的对象会根据他们的年龄值来决定去向。 年龄达到一定值(年龄阈值， 可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中， 没有达到阈值的对象会被复制到“To”区域。 经过这次GC后， Eden区和From区已经被清空。 这个时候， “From”和“To”会交换他们的角色， 也就是新的“To”就是上次GC前的“From”， 新的“From”就是上次GC前的“To”。 不管怎样， 都会保证名为To的Survivor区域是空的。 Minor GC会一直重复这样的过程， 直到“To”区被填满， “To”区被填满之后， 会将所有对象移动到年老代中。</p><h3 id="3-空间分配担保"><a href="#3-空间分配担保" class="headerlink" title="3. 空间分配担保"></a>3. 空间分配担保</h3><p>　　在发生Minor GC之前， 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间， 如果这个条件成立， 那么Minor GC可以 确保是安全的。 如果不成立， 则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许， 那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于， 则将尝试进行一次Minor GC， 尽管这个Minor GC是有风险的。 如果小于， 者HandlePromotionFailure设置不允许冒险， 那这时也要改为进行一次Full GC。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、何时GC？&quot;&gt;&lt;a href=&quot;#一、何时GC？&quot; class=&quot;headerlink&quot; title=&quot;一、何时GC？&quot;&gt;&lt;/a&gt;一、何时GC？&lt;/h2&gt;&lt;h3 id=&quot;（一）引用计数算法&quot;&gt;&lt;a href=&quot;#（一）引用计数算法&quot; class=&quot;headerlink&quot; title=&quot;（一）引用计数算法&quot;&gt;&lt;/a&gt;（一）引用计数算法&lt;/h3&gt;&lt;p&gt;　　给对象添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加1； 当引用失效时， 计数器值就减1； 任何时刻计数器为0的对象就是不可能被再使用的。&lt;br&gt;　　主流的JVM里面没有选用引用计数算法来管理内存， 其中最主要的原因是它&lt;strong&gt;很难解决对象间的互循环引用的问题&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java进阶" scheme="https://lvmdu.gitee.io/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java" scheme="https://lvmdu.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM之类加载机制和类加载器</title>
    <link href="https://lvmdu.gitee.io/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://lvmdu.gitee.io/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2020-03-01T09:18:00.000Z</published>
    <updated>2020-03-01T13:57:28.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、类加载机制"><a href="#一、类加载机制" class="headerlink" title="一、类加载机制"></a>一、类加载机制</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>　　虚拟机把描述类的数据从Class文件加载到内存， 并对数据进行校验、 转换解析和初始化， 最终形成可以被虚拟机直接使用的Java类型。</p><a id="more"></a><h3 id="2-类的声明周期"><a href="#2-类的声明周期" class="headerlink" title="2. 类的声明周期"></a>2. 类的声明周期</h3><p><img src="/images/img_class_life_cycle.png" alt="img_class_life_cycle"></p><p>　　其中，验证、准备、解析这三个步骤统称为连接。<br>　　类加载机制中的<strong>步骤</strong>：<strong>加载， 验证， 准备， 解析及初始化</strong> （解析阶段的顺序不一定，它在某些情况下可以在初始化完成后再开始）</p><h3 id="3-触发类加载的条件"><a href="#3-触发类加载的条件" class="headerlink" title="3. 触发类加载的条件"></a>3. 触发类加载的条件</h3><p>① 遇到new，getstatic，putstatic或invokestatic这4条字节码指令时， 如果类没有进行过初始化， 则需要先触发初始化。<br>② 使用java.lang.reflect包的方法对类进行反射调用的时候。<br>③ 当初始化一个类的时候， 发现其父类还没有进行过初始化， 则需要先出发父类的初始化。<br>④ 当虚拟机启动时， 用户需要指定一个要执行的主类（包含main()方法的那个类） ， 虚拟机会先初始化这个主类。<br>⑤ 当使用JDK1.7的动态语言支持时， 如果一个java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic,REF_putStatic,REF_invokeStatic 的方法句柄， 并且这个方法句柄所对应的类没有进行初始化， 则需要先出发初始化。</p><h3 id="4-类加载的具体过程"><a href="#4-类加载的具体过程" class="headerlink" title="4. 类加载的具体过程"></a>4. 类加载的具体过程</h3><h4 id="（1）加载"><a href="#（1）加载" class="headerlink" title="（1）加载"></a>（1）加载</h4><p>① 通过一个类的全限定名来获取定义此类的二进制字节流。<br>② 将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构。<br>③ 在内存中生成一个代表这个类的java.lang.Class对象， 作为方法区这个类的各种数据的访问入口。</p><h4 id="（2）验证"><a href="#（2）验证" class="headerlink" title="（2）验证"></a>（2）验证</h4><p>　　是连接阶段的第一步， 目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求， 并且不会危害虚拟机自身的安全。</p><p><strong>包含四个阶段的校验动作：</strong><br><strong>a.文件格式验证</strong><br>　　验证字节流是否符合Class文件格式的规范， 并且能被当前版本的虚拟机处理。<br><strong>b.元数据验证</strong><br>　　对类的元数据信息进行语义校验， 是否存在不符合Java语言规范的元数据信息。<br><strong>c.字节码验证</strong><br>　　最复杂的一个阶段， 主要目的是通过数据流和控制流分析， 确定程序语义是合法的， 符合逻辑的。 对类的方法体进行校验分析， 保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。<br><strong>d.符号引用验证</strong><br>　　确保解析动作能正常进行。</p><h4 id="（3）准备"><a href="#（3）准备" class="headerlink" title="（3）准备"></a>（3）准备</h4><p>　　准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。 这些变量所使用的内存都将在方法区中分配。 只包括类变量。 初始值“通常情况”下是数据类型的零值。<br>　　“特殊情况”下， 如果类字段的字段属性表中存在ConstantValue属性， 那么在准备阶段变量的值就会被初始化为ConstantValue属性所指定的值。</p><h4 id="（4）解析："><a href="#（4）解析：" class="headerlink" title="（4）解析："></a>（4）解析：</h4><p>　　虚拟机将常量池内的符号引用替换为直接引用的过程。<br>　　“动态解析”的含义就是必须等到程序实际运行到这条指令的时候， 解析动作才能进行。 相对的， 其余可触发解析的指令都是“静态”的， 可以在刚刚完成加载阶段， 还没有开始执行代码时就进行解析。</p><h4 id="（5）初始化："><a href="#（5）初始化：" class="headerlink" title="（5）初始化："></a>（5）初始化：</h4><p>　　类加载过程中的最后一步。简单地说， 初始化就是对类变量进行赋值及执行静态代码块。<br>　　初始化阶段是执行类构造器 &lt;clinit&gt;() 方法的过程。<br>　　&lt;clinit&gt;() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。<br>　　&lt;clinit&gt;() 与类的构造函数不同， 它不需要显示地调用父类构造器， 虚拟机会保证在子类的 &lt;clinit&gt;() 方法执行之前， 父类的 &lt;clinit&gt;() 方法已经执行完毕。</p><h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><p>　　类加载机制的加载部分的功能是将类的class文件读入内存， 并为之创建一个java.lang.Class对象。 这部分功能就是由类加载器来实现的。</p><h3 id="1-类加载器分类"><a href="#1-类加载器分类" class="headerlink" title="1. 类加载器分类"></a>1. 类加载器分类</h3><p>　　不同的类加载器负责加载不同的类。 主要分为两类。<br>（1）启动类加载器（Bootstrap ClassLoader）<br>　　由C++语言实现（针对HotSpot） ，负责将存放在\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中， 即负责加载Java的核心类。<br>（2）其他类加载器<br>　　由Java语言实现， 继承自抽象类ClassLoader。 如：</p><ul><li>扩展类加载器（Extension ClassLoader）： 负责载\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库， 即负责加载Java扩展的核心类之外的类。</li><li>应用程序类加载器（Application ClassLoader）： 负责加载用户类路径（classpath） 上的指定类库， 我们可以直接使用这个类加载器， 通过ClassLoader.getSystemClassLoader()方法直接获取。 一般情况， 如果我们没有自定义类加载器<strong>默认</strong>就是用这个加载器。</li></ul><h3 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2. 双亲委派模型"></a>2. 双亲委派模型</h3><h4 id="（1）工作流程"><a href="#（1）工作流程" class="headerlink" title="（1）工作流程"></a>（1）工作流程</h4><p>　　如果一个类加载器收到了类加载的请求， 它首先不会自己去尝试加载这个类， 而是把请求委托给父加载器去完成， 依次向上， 因此， 所有的类加载请求最终都应该被传递到顶层的启动类加载器中， 只有当父加载器在它的搜索范围中没有找到所需的类时， 即无法完成该加载， 子加载器才会尝试自己去加载该类。</p><h4 id="（2）好处"><a href="#（2）好处" class="headerlink" title="（2）好处"></a>（2）好处</h4><ul><li>无论哪个类加载器加载该类， 最终都是由启动类加载<br>器进行加载， 保证安全。</li><li>即使用户自己编写一个系统类（如：java.lang.Object类）并放入程序中，虽能正常编译， 但不会被加载运行， 保证不会出现混乱。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、类加载机制&quot;&gt;&lt;a href=&quot;#一、类加载机制&quot; class=&quot;headerlink&quot; title=&quot;一、类加载机制&quot;&gt;&lt;/a&gt;一、类加载机制&lt;/h2&gt;&lt;h3 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h3&gt;&lt;p&gt;　　虚拟机把描述类的数据从Class文件加载到内存， 并对数据进行校验、 转换解析和初始化， 最终形成可以被虚拟机直接使用的Java类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java进阶" scheme="https://lvmdu.gitee.io/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java" scheme="https://lvmdu.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>开源框架（二） 依赖注入框架</title>
    <link href="https://lvmdu.gitee.io/2020/03/01/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-2-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/"/>
    <id>https://lvmdu.gitee.io/2020/03/01/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-2-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/</id>
    <published>2020-03-01T03:49:00.000Z</published>
    <updated>2020-03-01T08:16:36.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ButterKnife"><a href="#一、ButterKnife" class="headerlink" title="一、ButterKnife"></a>一、ButterKnife</h2><p>　　从严格意义讲不算是依赖注入框架， 它只是专注于Android系统的View注入框架， 并不支持其他方面的注入。 它可以减少大量的findViewById（@BindView）以及setOnClickListener（@OnClick）代码， 简化代码并提升开发效率。</p><a id="more"></a><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><ul><li>ButterKnife.bind(this)：根据Activity对应的Class得到一个继承了Unbinder的Constructor，最后通过<strong>反射</strong>constructor.newInstance(target, source)得到Unbinder子类的一个新的实例（MainActivity_ViewBinding的实例）。其中获取Constructor是通过LinkedHashMap缓存了对应的Class和Constructor以提高效率。</li><li>注解处理器：通过注解处理器，将source值、ID等参数传入MainActivity_ViewBinding的findRequiredViewAsType方法，在该方法内部调用了findRequiredView方法，findRequiredView方法又调用了DecorView的findViewById方法并将R.id.tv_text对应的View返回。接着findRequiredViewAsType方法调用castView方法，将View强制转换成传入的Class值的类型（即对应的View.class），最终强制转换为对应的组件并返回，MainActivity_ViewBinding辅助类会把这个返回的组件会赋值给target，也就是MainActivity，这样在MainActivity就可以使用这个组件了。</li></ul><h2 id="二、Dagger"><a href="#二、Dagger" class="headerlink" title="二、Dagger"></a>二、Dagger</h2><p>　　Dagger是一个基于Java依赖注入标准的依赖注入框架， 在编译期间自动生成代码， 负责依赖对象的创建。</p><h3 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p>（1）创建Module容器（类），它的作用是提供实例化的对象，需要添加 @Module 注解。同时，创建提供实体类实例的方法并添加 @Provides 注解。<br>（2）创建Component连接件（接口），它是沟通调用者和容器的桥梁，需要添加 @Component 注解，并且用注解的modules属性指明作为容器的类。并在Component中定义抽象的inject注入方法。<br>（3）Rebuild项目，这时Dagger框架会自动创建一个以Dagger-开头的辅助类（DaggerMainComponent）。<br>（4）调用者首先使用DaggerMainComponent采用Builder模式来创建一个DaggerMainComponent的实例，需要传入一个Module容器的实例。接着调用inject方法将调用者注入。<br>（5）在调用者类中，声明一个实体类的变量，使用 @Inject 注解标记，即可获得该实体类的实例。</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>　　DaggerMainComponent重写了MainComponent接口的inject()方法，里边调用的injectMainActivity()方法是完成依赖注入的关键。它会调用生成的MainActivity_MembersInjector类，这个类中会将实例提供给被注入的Activity，而实例的生成则是通过另一个生成的MainModule_ProvideXxxxFactory来实现的，这个Factory中传入了我们创建的Module容器，并在里面调用我们所创建的provide实体的方法。最终就完成了实例的创建和注入，归根到底所创建的实例还是我们在Module里面定义和创建的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、ButterKnife&quot;&gt;&lt;a href=&quot;#一、ButterKnife&quot; class=&quot;headerlink&quot; title=&quot;一、ButterKnife&quot;&gt;&lt;/a&gt;一、ButterKnife&lt;/h2&gt;&lt;p&gt;　　从严格意义讲不算是依赖注入框架， 它只是专注于Android系统的View注入框架， 并不支持其他方面的注入。 它可以减少大量的findViewById（@BindView）以及setOnClickListener（@OnClick）代码， 简化代码并提升开发效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://lvmdu.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>开源框架（一） 网络框架</title>
    <link href="https://lvmdu.gitee.io/2020/03/01/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-1-%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    <id>https://lvmdu.gitee.io/2020/03/01/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-1-%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</id>
    <published>2020-03-01T02:40:00.000Z</published>
    <updated>2020-03-01T03:59:56.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Volley"><a href="#一、Volley" class="headerlink" title="一、Volley"></a>一、Volley</h2><h3 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p>（1）通过Volley.newRequestQueue获取一个RequestQueue对象<br>（2）创建一个Request(StringRequest/JsonRequest/ImageRequest)对象<br>（3）将Request对象通过add方法添加到RequestQueue中</p><a id="more"></a><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p><img src="/images/img_volley.png" alt="img_volley"></p><h2 id="二-OkHttp"><a href="#二-OkHttp" class="headerlink" title="二. OkHttp"></a>二. OkHttp</h2><h3 id="1-使用方法-1"><a href="#1-使用方法-1" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p>（1）通过Request.Builder创建一个Request对象<br>（2）创建一个OkHttpClient对象<br>（3）将Request传入OkHttpClient对象中(mOkHttpClient.newCall(request))，来创建一个Call对象<br>（4）调用Call对象的execute(同步)/enqueue(异步)方法来执行</p><h3 id="2-原理-1"><a href="#2-原理-1" class="headerlink" title="2. 原理"></a>2. 原理</h3><p><img src="/images/img_okhttp.png" alt="img_okhttp"></p><h2 id="三、Retrofit"><a href="#三、Retrofit" class="headerlink" title="三、Retrofit"></a>三、Retrofit</h2><h3 id="1-使用方法-2"><a href="#1-使用方法-2" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p><strong>一般用法：</strong><br>（1）定义请求接口类，使用@GET/@POST注解注解编写网络请求接口<br>（2）使用Buider模式创建Retrofit实例<br>（3）通过Retrofit对象的create方法传入之前的请求接口类，来创建请求实体对象<br>（4）调用请求对象的请求方法生成能够发起网络请求的Call对象<br>（5）调用Call对象的enqueue方法发起异步网络请求</p><p><strong>高级用法：</strong><br>适配OkHttpCall的Factory：<br>（1）定义请求接口类，使用@GET/@POST注解编写网络请求接口<br>（2）使用单例模式创建一个RetrofitFactory<br>（3）在RetrofitFactory内部创建一个OkHttpClient，并通过Builder模式利用OkHttpClient来创建一个Retrofit实例<br>（4）通过Retrofit对象的create方法传入之前的请求接口类，来创建请求实体对象<br>（5）客户端通过RetroFactory来调用请求对象的请求方法生成能够发起网络请求的Call对象<br>（6）调用Call对象的enqueue方法发起异步网络请求</p><h3 id="2-原理-2"><a href="#2-原理-2" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>　　Retrofit的create方法通过<strong>动态代理</strong>的模式，生成了实现了具体的网络请求接口的对象，并在InvocationHandler的invoke方法中统一处理网络请求接口实体对象的方法，根据方法生成一个ServiceMethod对象，并将其放入缓存中，然后根据ServiceMethod对象和网络请求的参数去构造一个OkHttpCall对象，最后调用serviceMethod的callAdapter的adapt方法，传入将OkHttpCall对象。（callAdapter的目的主要是为了适配OkHttpCall对象，其内部会对OkHttpCall对象进行包装，生成对应返回类型的对象。）底层真正处理网络请求的还是OkHttp框架。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Volley&quot;&gt;&lt;a href=&quot;#一、Volley&quot; class=&quot;headerlink&quot; title=&quot;一、Volley&quot;&gt;&lt;/a&gt;一、Volley&lt;/h2&gt;&lt;h3 id=&quot;1-使用方法&quot;&gt;&lt;a href=&quot;#1-使用方法&quot; class=&quot;headerlink&quot; title=&quot;1. 使用方法&quot;&gt;&lt;/a&gt;1. 使用方法&lt;/h3&gt;&lt;p&gt;（1）通过Volley.newRequestQueue获取一个RequestQueue对象&lt;br&gt;（2）创建一个Request(StringRequest/JsonRequest/ImageRequest)对象&lt;br&gt;（3）将Request对象通过add方法添加到RequestQueue中&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://lvmdu.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM之Java内存区域和内存模型</title>
    <link href="https://lvmdu.gitee.io/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8BJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://lvmdu.gitee.io/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8BJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-03-01T01:56:00.000Z</published>
    <updated>2020-03-01T13:57:35.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Java-内存区域"><a href="#一、Java-内存区域" class="headerlink" title="一、Java 内存区域"></a>一、Java 内存区域</h2><ul><li><strong>方法区（公有）</strong>： 用户存储已被虚拟机加载的 <em>类信息， 常量， 静态常量， 即时编译器编译后的代码</em> 等数据。<br>其中包含<strong>常量池</strong>： 用户存放编译器生成的各种字面量和符号引用。<br>异常状态： OutOfMemoryError</li></ul><a id="more"></a><ul><li><strong>堆（公有）</strong>： 是JVM所管理的内存中<strong>最大</strong>的一块。 唯一目的就是存放 <em>实例对象</em> ， 几乎所有的对象实例都在这里分配。 Java堆是<strong>垃圾收集器管理的主要区域</strong>， 因此很多时候也被称为“GC堆”。<br>异常状态：OutOfMemoryError</li><li><strong>虚拟机栈（线程私有）</strong>： 描述的是Java方法执行的内存模型： 每个方法在执行时都会创建一个栈帧， 用户存储 <em>局部变量表， 操作数栈， 动态链接， 方法出口</em> 等信息。每一个方法从调用直至完成的过程， 就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>异常状态：OutOfMemoryError、StackOverflowError</li><li><strong>本地方法栈（线程私有）</strong>: 与虚拟机栈所发挥的作用相似。 它们之间的区别不过是虚拟机栈为虚拟机执行Java方法， 而本地方法栈为虚拟机使用到的Native方法。<br>异常状态：OutOfMemoryError、StackOverflowError</li><li><strong>程序计数器（线程私有）</strong>： 一块较小的内存， 当前线程所执行的字节码的行号指示器。 字节码解释器工作时， 就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。<br>异常状态：无（唯一一个没有规定任何OutOfMemoryError情况的区域）<br><img src="/images/img_java_memory_area.png" alt="img_java_memory_area"></li></ul><h2 id="二、Java-内存模型"><a href="#二、Java-内存模型" class="headerlink" title="二、Java 内存模型"></a>二、Java 内存模型</h2><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h3><p>　　屏蔽掉各种硬件和操作系统的内存访问差异， 以实现让java程序在各种平台下都能达到一致的内存访问效果。</p><h3 id="2-内容"><a href="#2-内容" class="headerlink" title="2. 内容"></a>2. 内容</h3><ul><li>所有的变量都存储在<strong>主内存</strong>中。</li><li>每条线程中还有自己的<strong>工作内存</strong>， 工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来） 。</li><li>线程对变量的所有操作（读取、赋值）都必须在工作内存中进行。</li><li>不同线程之间无法直接访问对方工作内存中的变量。</li><li>线程间变量值的传递均需要通过主内存来完成。<br><img src="/images/img_java_memory_model.png" alt="img_java_memory_model"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Java-内存区域&quot;&gt;&lt;a href=&quot;#一、Java-内存区域&quot; class=&quot;headerlink&quot; title=&quot;一、Java 内存区域&quot;&gt;&lt;/a&gt;一、Java 内存区域&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法区（公有）&lt;/strong&gt;： 用户存储已被虚拟机加载的 &lt;em&gt;类信息， 常量， 静态常量， 即时编译器编译后的代码&lt;/em&gt; 等数据。&lt;br&gt;其中包含&lt;strong&gt;常量池&lt;/strong&gt;： 用户存放编译器生成的各种字面量和符号引用。&lt;br&gt;异常状态： OutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java进阶" scheme="https://lvmdu.gitee.io/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java" scheme="https://lvmdu.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java集合</title>
    <link href="https://lvmdu.gitee.io/2020/02/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88/"/>
    <id>https://lvmdu.gitee.io/2020/02/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88/</id>
    <published>2020-02-29T14:01:00.000Z</published>
    <updated>2020-03-03T02:22:20.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Java集合总览"><a href="#一、Java集合总览" class="headerlink" title="一、Java集合总览"></a>一、Java集合总览</h2><table><thead><tr><th align="center"></th><th align="center"></th><th align="center">是否有序</th><th align="center">是否允许重复元素</th></tr></thead><tbody><tr><td align="center">Collection</td><td align="center"></td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">Set</td><td align="center">HashSet</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">Set</td><td align="center">TreeSet</td><td align="center">是(二叉树)</td><td align="center">否</td></tr><tr><td align="center">Map</td><td align="center">HashMap</td><td align="center">否</td><td align="center">Key不允许重复，Value允许重复</td></tr><tr><td align="center">Map</td><td align="center">TreeMap</td><td align="center">是(二叉树)</td><td align="center">Key不允许重复，Value允许重复</td></tr><tr><td align="center">List</td><td align="center"></td><td align="center">是</td><td align="center">是</td></tr></tbody></table><h2 id="二、HashMap"><a href="#二、HashMap" class="headerlink" title="二、HashMap"></a>二、HashMap</h2><h3 id="（一）性质"><a href="#（一）性质" class="headerlink" title="（一）性质"></a>（一）性质</h3><p>（1）Key 和 Value 都可以为空<br>（2）value 允许重复， Key 不允许重复<br>（3）映射是无序的（散列有序），无法按照添加顺序遍历（注：LinkedHashMap 有序）<br>（4）HashMap是非线程同步的实现，因此不是线程安全的</p><p>注意：</p><ul><li>HashTable（Java 5.0 已废弃）是线程安全的，在单线程的条件下，速度要比HashMap慢</li><li>ConcurrentHashMap（Java 5.0 引入）不是线程安全的</li><li>HashMap可以通过以下语句实现同步：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizeMap(hashMap);</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h4><p>理想情况下，插入和查找的时间复杂度都是 O(1)。</p><p>（1）插入：<br>第一步：key.hashcode()，时间复杂度O(1)。<br>第二步：找到桶以后，判断桶里是否有元素，如果没有，直接new一个entey节点插入到数组中。时间复杂度O(1)。<br>第三步：如果桶里有元素，并且元素个数小于8，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(n)=O(n)。<br>第四步：如果桶里有元素，并且元素个数大于8，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(logn)=O(logn)。红黑树查询的时间复杂度是O(logn)。　　</p><p>（2）查找：<br>第一步：key.hashcode()，时间复杂度O(1)。<br>第二步：调用equals方法，比较是否存在相同名字的key，时间复杂度O(logn)/O(n)。</p><p>　　通过上面的分析，我们可以得出结论，HashMap实际的插入和查找的时间复杂度是不固定的，可能的值有O(1)、O(logn)、O(n)。</p><h4 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h4><p>两个重要参数：容量（Capacity）和 负载因子（Load Factor）</p><p>　　当Entry的数量大于（Capacity * Load Factor），则会重新resize一个原来长度 2 倍的HashMap，并且重新调用hash方法。</p><h3 id="（二）实现原理"><a href="#（二）实现原理" class="headerlink" title="（二）实现原理"></a>（二）实现原理</h3><h4 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1. 底层数据结构"></a>1. 底层数据结构</h4><ul><li>JDK 7：位桶(bucket)（Node[] table: 哈希桶数组） + 链表</li><li>JDK 8：位桶 + 链表/红黑树<br><img src="/images/img_hashmap.png" alt="img_hashmap"><h4 id="2-put方法-get方法"><a href="#2-put方法-get方法" class="headerlink" title="2. put方法 / get方法"></a>2. put方法 / get方法</h4>（1）<strong>put方法</strong> 原理：<br>1）先对key值进行hash操作计算hashCode， 然后再通过<br>hashCode进一步计算下标index；<br>2）根据index查找到对应的bucket</li><li>如果没发生碰撞直接放到bucket里；</li><li>如果碰撞了， 以链表的形式存在buckets后如果碰撞导致链表过长(大于等于 TREEIFY_THRESHOLD)， 就把链表转换成红黑树；<br>3）如果节点已经存在就替换old value(保证key的唯一性)；<br>4）如果bucket满了(超过load factor * current capacity)， 就要resize。<br><img src="/images/img_hashmap_put.png" alt="img_hashmap_put"></li></ul><p>（2）<strong>get方法</strong> 原理：<br>1）先对key值进行hash操作计算hashCode， 然后再通过<br>hashCode进一步计算下标index。<br>2）根据index查找到对应的bucket</p><ul><li>如果bucket里只有一个节点， 直接命中，取出它的value返回；</li><li>如果bucket的发生碰撞， 则通过key.equals()在链中找。<br>a. 若为链表， 则在链表中通过key.equals()查找， O(n)。<br>b. 若为树， 则在树中通过key.equals()查找， O(logn)；</li></ul><h2 id="三、ConcurrentHashMap"><a href="#三、ConcurrentHashMap" class="headerlink" title="三、ConcurrentHashMap"></a>三、ConcurrentHashMap</h2><h3 id="（一）引入ConcurrentHashMap的原因"><a href="#（一）引入ConcurrentHashMap的原因" class="headerlink" title="（一）引入ConcurrentHashMap的原因"></a>（一）引入ConcurrentHashMap的原因</h3><p>　　HashMap是非线程安全的。并发情况下，HashMap的put操作可能会导致Entry链表形成环，从而导致死循环。</p><h3 id="（二）实现原理-1"><a href="#（二）实现原理-1" class="headerlink" title="（二）实现原理"></a>（二）实现原理</h3><h4 id="JDK-1-6"><a href="#JDK-1-6" class="headerlink" title="JDK 1.6"></a>JDK 1.6</h4><p>　　ConcurrentHashMap采用 <strong>分段锁</strong> 的机制， 实现并发的更新操作， 底层采用　数组+链表+红黑树　的存储结构。 其包含两个核心静态内部类 Segment 和 HashEntry。</p><ol><li>Segment 继承 ReentrantLock 用来充当锁的角色， 每个 Segment 对象守护每个散列映射表的若干个桶；</li><li>HashEntry 用来封装映射表的键 / 值对；</li><li>每个桶是由若干个 HashEntry 对象链接起来的链表。</li></ol><p>　　一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。 结构如下：<br><img src="/images/img_concurrent_hashmap.png" alt="img_concurrent_hashmap"></p><p>（1）<strong>put方法</strong> 原理：<br>1）先对key值进行hash操作计算hashCode， 再通过<br>hashCode进一步计算 Segment 的索引，找到该 Segment 并调用相应的 put 方法；<br>2）调用 tryLock() 进行加锁；<br>4）判断是否碰撞…<br>5）判断Key是否存在…<br>6）判断是否需要扩容…</p><p>（2）<strong>get方法</strong> 原理：<br>　　同 HashMap 的原理相同。<br>注：get 方法是不加锁的。它将所有需要使用的变量使用 volatile 关键字进行修饰，保证了线程之间的可见性。</p><h4 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h4><p>　　JDK 1.8 的实现已经抛弃了 Segment 分段锁机制， 利用　<strong>CAS+Synchronized</strong>　来保证并发更新的安全， 底层依然采用 数组+链表+红黑树 的存储结构。<br>　　CAS：CompareAndSwap：比较和替换</p><p>（1）<strong>put方法</strong> 原理：<br>1）先对key值进行hash操作计算hashCode， 再通过<br>hashCode进一步计算 Segment 的索引；<br>4）判断是否碰撞。注意插入值时是采用CAS的方式。<br>5）判断Key是否存在…<br>6）判断是否需要扩容…</p><p><strong>补充：CAS原理：</strong><br>a. 3个操作数：</p><ul><li>内存地址 V</li><li>旧的预期值 A</li><li>即将要更新的目标值 B</li></ul><p>b. CAS执行命令时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则继续进行CAS自旋（无限循环）。</p><p>c. 缺点：</p><ul><li>循环时间长，开销很大</li><li>不能保证代码块的原子性，所保证的只是一个变量的原子性操作</li><li>ABA问题<br>什么是ABA问题?<br>在CAS操作中将判断“V的值是否仍然为A？”，并且如果是的话就继续执行更新操作，在某些算法中，如果V的值首先由A变为B，再由B变为A，那么CAS将会操作成功。<br>怎么避免ABA问题？<br>Java中提供了AtomicStampedReference和AtomicMarkableReference来解决ABA问题。</li></ul><p>（2）<strong>get方法</strong> 原理：<br>　　同 HashMap 的原理相同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Java集合总览&quot;&gt;&lt;a href=&quot;#一、Java集合总览&quot; class=&quot;headerlink&quot; title=&quot;一、Java集合总览&quot;&gt;&lt;/a&gt;一、Java集合总览&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Java进阶" scheme="https://lvmdu.gitee.io/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java" scheme="https://lvmdu.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android新特性</title>
    <link href="https://lvmdu.gitee.io/2020/02/29/Android%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://lvmdu.gitee.io/2020/02/29/Android%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-02-29T13:07:00.000Z</published>
    <updated>2020-02-29T13:54:05.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Android-5-0-新特性"><a href="#一、Android-5-0-新特性" class="headerlink" title="一、Android 5.0 新特性"></a>一、Android 5.0 新特性</h2><ol><li>全新的 Material Design 设计风格</li><li>引入 RecyclerView 代替 ListView</li><li>增加不重要通知隐藏功能</li><li>ART 虚拟机代替了 Dalvik 虚拟机</li><li>多任务视图</li></ol><a id="more"></a><h2 id="二、Android-6-0-新特性"><a href="#二、Android-6-0-新特性" class="headerlink" title="二、Android 6.0 新特性"></a>二、Android 6.0 新特性</h2><ol><li>运行时权限</li><li>集成了Android Pay</li><li>指纹支持</li><li>Doze 电量管理</li></ol><h2 id="三、Android-7-0-新特性"><a href="#三、Android-7-0-新特性" class="headerlink" title="三、Android 7.0 新特性"></a>三、Android 7.0 新特性</h2><ol><li>多窗口模式</li><li>Data Saver（流量保护机制）</li><li>支持Java 8</li><li>通知栏快速回复</li><li>通知栏快捷开关</li></ol><h2 id="四、Android-8-0-新特性"><a href="#四、Android-8-0-新特性" class="headerlink" title="四、Android 8.0 新特性"></a>四、Android 8.0 新特性</h2><ol><li>Notification Channel（通知渠道）</li><li>PIP（画中画模式）</li><li>自适应图标</li><li>长按图标弹出子菜单</li><li>权限新增安装权限</li><li>电量优化（大部分静态注册广播失效）</li></ol><h2 id="五、Android-9-0-新特性"><a href="#五、Android-9-0-新特性" class="headerlink" title="五、Android 9.0 新特性"></a>五、Android 9.0 新特性</h2><ol><li>全面屏支持</li><li>多摄像头支持</li><li>手势操作</li><li>增加黑夜模式</li><li>设置应用程序时间限制</li><li>基于人工智能的电量自适应和亮度自适应</li></ol><h2 id="六、Android-10-0-新特性"><a href="#六、Android-10-0-新特性" class="headerlink" title="六、Android 10.0 新特性"></a>六、Android 10.0 新特性</h2><ol><li>可折叠的应用程序</li><li>5G 网络</li><li>基于人工智能的回复操作</li><li>可适用于系统和应用的暗黑主题</li><li>类似于PC的桌面模式</li><li>面部识别</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Android-5-0-新特性&quot;&gt;&lt;a href=&quot;#一、Android-5-0-新特性&quot; class=&quot;headerlink&quot; title=&quot;一、Android 5.0 新特性&quot;&gt;&lt;/a&gt;一、Android 5.0 新特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;全新的 Material Design 设计风格&lt;/li&gt;
&lt;li&gt;引入 RecyclerView 代替 ListView&lt;/li&gt;
&lt;li&gt;增加不重要通知隐藏功能&lt;/li&gt;
&lt;li&gt;ART 虚拟机代替了 Dalvik 虚拟机&lt;/li&gt;
&lt;li&gt;多任务视图&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://lvmdu.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android内存泄漏</title>
    <link href="https://lvmdu.gitee.io/2020/02/29/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://lvmdu.gitee.io/2020/02/29/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2020-02-29T08:19:00.000Z</published>
    <updated>2020-03-01T01:03:43.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ANR"><a href="#一、ANR" class="headerlink" title="一、ANR"></a>一、ANR</h2><h3 id="1-什么是ANR？"><a href="#1-什么是ANR？" class="headerlink" title="1. 什么是ANR？"></a>1. 什么是ANR？</h3><p>　　<strong>ANR</strong> 即Application Not Responding，它是一个提示“应用程序无响应”的对话框。</p><a id="more"></a><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2. 原因"></a>2. 原因</h3><p>　　当应用程序的<strong>UI线程响应超时</strong>才会引起ANR，超时产生原因一般有两种：</p><ul><li>当前的事件没有机会得到处理（例如UI线程正在响应另外一个事件），当前事件由于某种原因被阻塞了。</li><li>当前的事件正在处理，但是由于耗时太长没能及时完成。</li></ul><p>　　从本质上讲，<strong>产生ANR的原因有三种</strong>，大致可以对应到Android 中四大组件中的三个（Activity/View，BroadcastReceiver和Service）。</p><ul><li>KeyDispatchTimeOut ：最常见的一种类型，原因是View的按键事件或者触摸事件在特定的时间（5秒）内无法得到响应。</li><li>BroadcaseTimeOut：原因是BroadcastReceiver的onReceiver()函数运行在主线程中，在特定的时间（10秒）内无法完成处理。</li><li>ServiceTimeOut：比较少出现的一种类型，原因是Service的各个生命周期函数在特定时间（20秒）内无法完成处理。</li></ul><p>　　<strong>根本原因</strong> 在主线程(UI线程)里面做了太多的耗时操作, 例如文件读写、数据库读写等。<br><strong>注意：</strong><br>　　Android 4.0 之后网络IO不允许在主线程中。</p><h4 id="补充：Android中哪些操作是在主线程中？"><a href="#补充：Android中哪些操作是在主线程中？" class="headerlink" title="补充：Android中哪些操作是在主线程中？"></a>补充：Android中哪些操作是在主线程中？</h4><ul><li>Activity的所有生命周期回调都是执行在主线程中</li><li>Service默认是执行在<strong>主线程</strong>中</li><li>BroadcastReceiver的onReceiver()回调执行在主线程中</li><li>没有使用子线程的Looper的Handler，它的handleMessage和post(Runnable)是执行在主线程中</li><li>AsyncTask的回调中除了doInBackground，其他的都是执行在主线程中</li><li>View的post(Runnable)是执行在主线程中</li></ul><h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><p>　　<strong>原则：</strong> 将耗时操作放在子线程中，主线程只做UI相关的操作。</p><ul><li>使用Handler机制，进行线程调度</li><li>使用Thread或者HandlerThread，开启子线程处理耗时操作</li><li>使用AsyncTask，处理异步任务</li><li>尽量避免在Activity的生命周期回调中做耗时操作</li></ul><h3 id="4-ANR的定位和分析"><a href="#4-ANR的定位和分析" class="headerlink" title="4. ANR的定位和分析"></a>4. ANR的定位和分析</h3><p>　　当发生ANR时，开发者可以通过结合<strong>Logcat日志</strong>和生成的位于手机内部存储的/data/anr/ <strong>traces.txt文件</strong>进行分析和定位。</p><p><strong>Logcat日志：</strong><br>从Logcat日志中，可以得到的信息主要有：<br>（1）导致ANR的类命及所在包名：MainActivity, com.asce1885.anrdemo<br>（2）发生ANR的进程名称及ID: com.asce1885.anrdemo,8672<br>（3）ANR产生的原因（类型）：Input disptching time out ，属于KeyDispatchTimeOut类型</p><p><strong>traces文件：</strong><br>　　从Logcat的日志信息我们可以知道引发ANR的具体的类信息以及ANR的类型，但是这不足够开发者定位到具体引发问题的代码行，为了获得进一步的信息，我们需要借助于ANR过程中生成的堆栈信息文件traces文件。<br>　　当app出现ANR会在data/anr/目录下生成traces.txt日志文件。每次发生ANR时都会删除旧的traces文件，重新创建新文件。也就是说Android只保留最后一次发生ANR时的信息。</p><p>　　一般trace文件顶部的线程即为ANR的元凶，进而分析ANR方法线程堆栈信息，重点关注主线程。最终定位出具体类的某个方法所导致的问题。</p><h2 id="二、OOM"><a href="#二、OOM" class="headerlink" title="二、OOM"></a>二、OOM</h2><h3 id="1-什么是OOM？"><a href="#1-什么是OOM？" class="headerlink" title="1. 什么是OOM？"></a>1. 什么是OOM？</h3><p>　　当前占用的内存加上我们申请的内存资源在超过了Dalvik虚拟机的最大内存限制，就会抛出 Out of Memory 的异常。<br>　　大部分的OOM异常都是大图加载所造成的。</p><h3 id="2-容易混淆的概念"><a href="#2-容易混淆的概念" class="headerlink" title="2. 容易混淆的概念"></a>2. 容易混淆的概念</h3><ul><li>内存溢出：即OOM</li><li>内存泄漏：内存泄漏积累到一定程度就会导致OOM。</li><li>内存抖动：短时间内大量的对象被创建，然后又被马上释放，瞬间产生的对象会严重占用内存区域。当达到阈值时触发GC，这样刚刚创建的对象就马上被回收。这些对象叠加在一起造成堆内存的压力，触发更多的GC。</li></ul><p>严重程度：内存溢出 &gt; 内存泄漏 &gt; 内存抖动</p><h3 id="3-解决方法-1"><a href="#3-解决方法-1" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><p>（1）有关Bitmap</p><ul><li>图片显示：加载合适的图片，例如加载缩略图的时候，我们不要进行网络请求加载大图。</li><li>及时释放内存：Bitmap的内存包含Java和Native两部分，其中Java的内存会被Java GC自动回收。可以在onDestory中手动去调用bitmap.recycle()进行内存释放。</li><li>图片压缩：设置inSampleSize（缩放比例）</li><li>使用inBitmap属性：复用内存区域</li><li>捕获异常：Error</li></ul><p>（2）其他</p><ul><li>ListView：<br>a: 使用convertView进行复用<br>b: 加载大图使用LRU机制进行缓存</li><li>自定义View：避免在onDraw方法里面执行对象的创建</li></ul><h2 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h2><h3 id="（一）Java的内存泄漏"><a href="#（一）Java的内存泄漏" class="headerlink" title="（一）Java的内存泄漏"></a>（一）Java的内存泄漏</h3><p>　　指的是无用的对象（不再使用的对象）持续占用内存而得不到 GC 回收，从而造成内存空间的浪费。</p><h4 id="1-Java-内存分配策略"><a href="#1-Java-内存分配策略" class="headerlink" title="1. Java 内存分配策略"></a>1. Java 内存分配策略</h4><p>　　Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配。 对应的， 三种存储策略使用的内存空间主要分别是： 静态存储区（也称方法区）、栈区和堆区。<br><strong>静态存储区（方法区）</strong> ： 主要存放静态数据、 全局 static 数据和常量。 这块内存在程序编译时就已经分配好， 并且在程序整个运行期间都存在。<br><strong>栈区</strong> ： 当方法被执行时， 方法体内的局部变量都在栈上创建， 并在方法执行结束时这些局部变量所持有的内存将会自动被释放。 因为栈内存分配运算内置于处理器的指令集中， 效率很高， 但是分配的内存容量有限。<br><strong>堆区</strong> ： 又称动态内存分配， 通常就是指在程序运行时直接 new 出来的内存。 这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</p><h4 id="2-什么样的对象会被GC？"><a href="#2-什么样的对象会被GC？" class="headerlink" title="2. 什么样的对象会被GC？"></a>2. 什么样的对象会被GC？</h4><p>　　可达性分析算法：如果一个对象到GCRoots没有任何引用链相连， 那么就认为这个对象不再被引用， 可以被 GC 回收。</p><h3 id="（二）Android的内存泄漏"><a href="#（二）Android的内存泄漏" class="headerlink" title="（二）Android的内存泄漏"></a>（二）Android的内存泄漏</h3><p>　　简单来说，就是该被释放的对象一直被某个或某些实例所持有却不再被使用导致内存得不到释放。 <strong>内存管理的目的</strong> 就是在开发中怎么有效的避免应用出现内存泄漏的问题。</p><h4 id="1-造成内存泄漏的情况"><a href="#1-造成内存泄漏的情况" class="headerlink" title="1. 造成内存泄漏的情况"></a>1. 造成内存泄漏的情况</h4><p>（1）单例<br>　　原因：由于单例的静态特性使得它和App的生命周期一样长，上下文如果是一个Activity的Context，那么它将一直持有Activity的引用，导致Activity无法被回收<br>　　解决方法：使用ApplicationContext<br>　　<br>（2）非静态内部类/匿名内部类<br>　　原因：默认持有外部类的引用，从而导致外部类（如：Activity）无法被回收<br>　　解决方法：改为静态内部类</p><p>（3）Handler<br>　　原因：由于Handler属于TLS(Thread Local Storage)变量，生命周期和Activity是不一致的； 万一Handler发送的Message尚未被处理， 则该Message及发送它的Handler对象将被线程MessageQueue一直持有。<br>　　解决方法：将Handler改写为静态内部类，同时在内部持有外部类的弱引用</p><p>（4）AsyncTask<br>　　原因：同非静态内部类<br>　　解决方法：可以在onDestory中调用asyncTask.cancle(boolean)</p><p>（5）static变量<br>　　原因：将变量声明为static时，将导致它的声明周期和整个App一样长，这部分的内存将不会被回收。<br>　　解决方法：考虑懒加载，尽量避免使用static变量；如果一定要使用，记得管理生命周期（onDestory中设为null）</p><p>（6）资源未关闭<br>　　如：Broadcast Receiver、Stream、Observer、Socket、Bitmap等<br>　　当Activity销毁前，记得注销这些资源，否则这些资源有可能无法回收，进而导致内存泄漏</p><h4 id="2-内存泄漏的定位和分析"><a href="#2-内存泄漏的定位和分析" class="headerlink" title="2. 内存泄漏的定位和分析"></a>2. 内存泄漏的定位和分析</h4><h5 id="（1）adb命令验证是否存在内存泄漏"><a href="#（1）adb命令验证是否存在内存泄漏" class="headerlink" title="（1）adb命令验证是否存在内存泄漏"></a>（1）adb命令验证是否存在内存泄漏</h5><p>1）打开要测试的apk，然后返回退出到主界面<br>2）AS的Terminal中输入命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="bash"> dumpsys meminfo 包名 -d</span></span><br></pre></td></tr></table></figure><p>　　然后便可以看到内存的一些情况<br>拉到下面可以看到：<br><img src="/images/img_memory_1.jpg" alt="img_memory_1"><br>　　退出APK之后，对象本应该都被回收，然而这里可以看到，还有View以及Activity占用着内存，由此可以知道内存泄漏了。</p><h5 id="（2）Android-Profiler（性能分析器）定位内存泄漏"><a href="#（2）Android-Profiler（性能分析器）定位内存泄漏" class="headerlink" title="（2）Android Profiler（性能分析器）定位内存泄漏"></a>（2）Android Profiler（性能分析器）定位内存泄漏</h5><p>1）进入内存分析界面<br>2）打开apk，然后返回键退出，然后点击上图中垃圾桶形状的图标进行垃圾回收，多点几次，直到内存没有什么变化<br>3）获取内存快照<br>4）查看Head Dump<br><img src="/images/img_memory_2.jpg" alt="img_memory_2"></p><ul><li>Shallow Heap（浅堆） 表示该对象自身占用的堆内存，不包括它引用的对象。</li><li>Retained Heap（深堆） 表示当前对象大小 + 当前对象可直接或间接引用到的对象的大小总和。<br>换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。</li></ul><p>　　从而分析出了内存泄漏的具体类</p><h5 id="（3）MAT-定位内存泄漏"><a href="#（3）MAT-定位内存泄漏" class="headerlink" title="（3）MAT 定位内存泄漏"></a>（3）MAT 定位内存泄漏</h5><p>1）进行格式转化</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hprof-conv -z <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>hprof <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>hprof</span><br></pre></td></tr></table></figure><p>2）Open Heap Dump 打开刚刚保存的内存快照，并点击点击 Histogram<br>3）可以看到引起内存泄漏的类，Objects那一列不为0，则是说明发生了内存泄漏<br>4）过滤掉虚引用，软引用，弱引用，之后可以看到引用路径即为发生内存泄漏的具体位置<br><img src="/images/img_memory_3.jpg" alt="img_memory_3"></p><p><img src="/images/img_memory_4.jpg" alt="img_memory_4"></p><h5 id="（4）LeakCanary-检测内存泄漏"><a href="#（4）LeakCanary-检测内存泄漏" class="headerlink" title="（4）LeakCanary 检测内存泄漏"></a>（4）LeakCanary 检测内存泄漏</h5><p>LeakCanary 是一个用于检测内存泄露的开源类库。<br>1）在代码中引入LeakCanary<br>2）启动app，当检测到内存泄漏的时候，会出现一个弹窗，然后手机桌面会出现一个Leaks的图标<br>3）点击即可看到内存泄漏的原因<br><img src="/images/img_memory_5.jpg" alt="img_memory_5"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、ANR&quot;&gt;&lt;a href=&quot;#一、ANR&quot; class=&quot;headerlink&quot; title=&quot;一、ANR&quot;&gt;&lt;/a&gt;一、ANR&lt;/h2&gt;&lt;h3 id=&quot;1-什么是ANR？&quot;&gt;&lt;a href=&quot;#1-什么是ANR？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是ANR？&quot;&gt;&lt;/a&gt;1. 什么是ANR？&lt;/h3&gt;&lt;p&gt;　　&lt;strong&gt;ANR&lt;/strong&gt; 即Application Not Responding，它是一个提示“应用程序无响应”的对话框。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://lvmdu.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化</title>
    <link href="https://lvmdu.gitee.io/2020/02/29/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://lvmdu.gitee.io/2020/02/29/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2020-02-29T08:19:00.000Z</published>
    <updated>2020-03-01T01:42:20.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、布局优化"><a href="#一、布局优化" class="headerlink" title="一、布局优化"></a>一、布局优化</h2><p>① 删除布局中无用的控件和层次， 其次有选择地使用性能比较低的ViewGroup</p><a id="more"></a><p>　　例如： 如果布局中既可以使用LinearLayout也可以使用RelativeLayout， 那么就采用LinearLayout， 这是因为RelativeLayout的功能比较复杂， 它的布局过程需要花费更<br>多的CPU时间。<br>② 采用&lt;include&gt; 标签、&lt;merge&gt; 标签和ViewStub</p><ul><li>&lt;include&gt; 标签：布局重用</li><li>&lt;merge&gt; 标签：减少布局层级</li><li>ViewStub：按需加载</li></ul><p>③ 避免多度绘制</p><h2 id="二、绘制优化"><a href="#二、绘制优化" class="headerlink" title="二、绘制优化"></a>二、绘制优化</h2><p>① onDraw中不要创建新的局部对象<br>② onDraw方法中不要做耗时的任务</p><h2 id="三、内存泄漏优化"><a href="#三、内存泄漏优化" class="headerlink" title="三、内存泄漏优化"></a>三、内存泄漏优化</h2><p>① 在开发过程中避免写出有内存泄漏的代码<br>② 通过一些分析工具比如MAT来找出潜在的内存泄露</p><h2 id="四、响应速度优化"><a href="#四、响应速度优化" class="headerlink" title="四、响应速度优化"></a>四、响应速度优化</h2><p>核心思想：避免在主线程中做耗时操作</p><h2 id="五、ListView-RecycleView及Bitmap优化"><a href="#五、ListView-RecycleView及Bitmap优化" class="headerlink" title="五、ListView/RecycleView及Bitmap优化"></a>五、ListView/RecycleView及Bitmap优化</h2><h4 id="ListView-RecycleView："><a href="#ListView-RecycleView：" class="headerlink" title="ListView/RecycleView："></a>ListView/RecycleView：</h4><p>① 使用ViewHolder模式来提高效率<br>② 异步加载： 耗时的操作放在异步线程中<br>③ ListView/RecycleView的滑动时停止加载和分页加载</p><h4 id="Bitmap："><a href="#Bitmap：" class="headerlink" title="Bitmap："></a>Bitmap：</h4><p>　　主要是对加载图片进行压缩，避免加载图片多大导致OOM出现。</p><h2 id="六、线程优化"><a href="#六、线程优化" class="headerlink" title="六、线程优化"></a>六、线程优化</h2><p>　　尽量采用线程池，而不是每次都要创建一个Thread对象</p><h2 id="七、其他性能优化的建议"><a href="#七、其他性能优化的建议" class="headerlink" title="七、其他性能优化的建议"></a>七、其他性能优化的建议</h2><p>①　避免过度的创建对象<br>②　不要过度使用枚举， 枚举占用的内存空间要比整型大<br>③　常量请使用static final来修饰<br>④　使用一些Android特有的数据结构， 比如SparseArray和Pair等<br>⑤　适当采用软引用和弱引用<br>⑥　采用内存缓存和磁盘缓存<br>⑦　尽量采用静态内部类</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、布局优化&quot;&gt;&lt;a href=&quot;#一、布局优化&quot; class=&quot;headerlink&quot; title=&quot;一、布局优化&quot;&gt;&lt;/a&gt;一、布局优化&lt;/h2&gt;&lt;p&gt;① 删除布局中无用的控件和层次， 其次有选择地使用性能比较低的ViewGroup&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://lvmdu.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>专业基础知识之操作系统</title>
    <link href="https://lvmdu.gitee.io/2020/02/28/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://lvmdu.gitee.io/2020/02/28/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-02-28T13:23:00.000Z</published>
    <updated>2020-03-01T13:51:51.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-进程与线程的区别"><a href="#1-进程与线程的区别" class="headerlink" title="1. 进程与线程的区别"></a>1. 进程与线程的区别</h3><p><strong>进程</strong>： 是系统进行资源分配和调度的一个独立单位。 引入进程是为了使多个程序可以并发的执行， 以提高系统的资源利用率和吞吐量。<br><strong>线程</strong>： 是比进程更小的可独立运行的基本单位， 可以看做是轻量级的进程。 引入目的是为了减少程序在并发执行过程中的开销。</p><a id="more"></a><p>两者区别：</p><ul><li>开销：进程之间的切换会产生更大的开销</li><li>内存分配：系统在运行时会为每个进程分配不同的内存空间；而系统不会为线程分配内存，线程所使用的的资源来自其所属进程的资源，线程之间只能共享资源</li><li>包含关系：一个进程可以有多个线程</li></ul><h3 id="2-进程的状态转换"><a href="#2-进程的状态转换" class="headerlink" title="2. 进程的状态转换"></a>2. 进程的状态转换</h3><p><img src="/images/img_process_state_change.png" alt="img_process_state_change"><br>就绪状态 -&gt; 运行状态： 处于就绪状态的进程被调度后， 获得处理机资源（分派处理机时间片） ， 于是进程由就绪状态转换为运行状态。<br>运行状态 -&gt; 就绪状态： 处于运行状态的进程在时间片用完后， 不得不让出处理机， 从而进程由运行状态转换为就绪状态。 此外， 在可剥夺的操作系统中， 当有更高优先级的进程就绪时， 调度程度将正执行的进程转换为就绪状态， 让更高优先级的进程执行。<br>运行状态 -&gt; 阻塞状态： 当进程请求某一资源（如外设） 的使用和分配或等待某一事件的发生（如I/O操作的完成） 时， 它就从运行状态转换为阻塞状态。<br>阻塞状态 -&gt; 就绪状态： 当进程等待的事件到来时， 如I/O操作结束或中断结束时， 中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。</p><h3 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h3><p>　　死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><h4 id="（1）死锁产生的必要条件"><a href="#（1）死锁产生的必要条件" class="headerlink" title="（1）死锁产生的必要条件"></a>（1）死锁产生的必要条件</h4><ul><li><strong>互斥条件</strong>：进程对所分配的资源进行排他性的使用</li><li><strong>请求和保持条件</strong>：进程被阻塞的时候并不释放锁申请到的资源</li><li><strong>不可剥夺条件</strong>：进程对于已经申请到的资源在使用完成之前不可以被剥夺</li><li><strong>环路等待条件</strong>：发生死锁的时候存在的一个 进程-资源 环形等待链</li></ul><h4 id="（2）死锁产生的原因"><a href="#（2）死锁产生的原因" class="headerlink" title="（2）死锁产生的原因"></a>（2）死锁产生的原因</h4><p>1） 竞争资源： 请求同一有限资源的进程数多于可用资源数<br>2） 进程推进顺序非法： 进程执行中， 请求和释放资源顺序不合理， 如资源等待链</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-进程与线程的区别&quot;&gt;&lt;a href=&quot;#1-进程与线程的区别&quot; class=&quot;headerlink&quot; title=&quot;1. 进程与线程的区别&quot;&gt;&lt;/a&gt;1. 进程与线程的区别&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;： 是系统进行资源分配和调度的一个独立单位。 引入进程是为了使多个程序可以并发的执行， 以提高系统的资源利用率和吞吐量。&lt;br&gt;&lt;strong&gt;线程&lt;/strong&gt;： 是比进程更小的可独立运行的基本单位， 可以看做是轻量级的进程。 引入目的是为了减少程序在并发执行过程中的开销。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业基础知识" scheme="https://lvmdu.gitee.io/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="操作系统" scheme="https://lvmdu.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>专业基础知识之计算机网络</title>
    <link href="https://lvmdu.gitee.io/2020/02/28/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://lvmdu.gitee.io/2020/02/28/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-02-28T12:08:00.000Z</published>
    <updated>2020-03-01T02:39:50.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-网络分层体系结构"><a href="#1-网络分层体系结构" class="headerlink" title="1. 网络分层体系结构"></a>1. 网络分层体系结构</h3><p><img src="/images/img_web.jpg" alt="img_web"></p><a id="more"></a><ul><li>应用层：提供用户与网络交互的接口，定义了应用程序间通信和交互的规则。—— HTTP、FTP、POP、SMTP</li><li>运输层：负责不同主机进程之间的数据传输。—— TCP、UDP</li><li>网络层：负责不同主机之间的数据传输。—— IP</li><li>数据链路层：负责相邻结点之间的数据传输。—— PPP</li><li>物理层：在物理介质上的传输。</li></ul><p><strong>PDU（协议数据单元）：</strong></p><ul><li>应用层：各应用报文</li><li>运输层：TCP/UDP数据段</li><li>网络层：IP数据包</li><li>数据链路层：帧</li><li>物理层：比特</li></ul><h3 id="2-GET-和-POST-两种请求方式的区别"><a href="#2-GET-和-POST-两种请求方式的区别" class="headerlink" title="2. GET 和 POST 两种请求方式的区别"></a>2. GET 和 POST 两种请求方式的区别</h3><p>（1）URL可见性</p><ul><li>get：URL参数可见</li><li>post：URL参数不可见</li></ul><p>（2）数据传输</p><ul><li>get：通过拼接URL进行传递参数</li><li>post：通过Body体传递参数</li></ul><p>（3）缓存性</p><ul><li>get：可缓存</li><li>post：不可缓存</li></ul><p>（4）后退页面的反应</p><ul><li>get：页面后退后，不产生影响</li><li>post：页面后退后，会重新提交请求</li></ul><p>（5）传输数据的大小</p><ul><li>get：有限制（一般不超过2k-4k）</li><li>post：没有限制</li></ul><p>（6）安全性</p><ul><li>get：不安全（URL参数可见）</li><li>post：安全</li></ul><h3 id="3-TCP-和-UDP-的区别"><a href="#3-TCP-和-UDP-的区别" class="headerlink" title="3. TCP 和 UDP 的区别"></a>3. TCP 和 UDP 的区别</h3><p>主要区别：<br><strong>TCP：</strong><br>1）<strong>面向连接的</strong>，连接的建立需要三次握手，；连接的释放需要四次挥手<br>2）<strong>面向字节流</strong>，会把上层传输下来的数据当作是无结构的字节流<br>3）<strong>一对一通信</strong><br>4）<strong>能够保证可靠传输</strong>，具有超时重传机制，并有数据校验<br><strong>UDP：</strong><br>1）<strong>无连接的</strong>，一方向另一方发送数据不需要建立连接<br>2）<strong>面向报文</strong>，从上层接受的数据如果报文不大于传输限制，则直接加上首部；如果过大，则进行IP分片后，再加上首部进行传输<br>3）<strong>可以一对一通信，也可以一对多通信</strong><br>4）<strong>不保证可靠传输</strong>，仅仅是尽最大努力交付</p><p>详细区别：<br><img src="/images/img_tcp_udp.jpg" alt="img_tcp_udp"></p><p><strong>什么时候应该使用TCP？</strong><br>当对网络通讯质量有要求的时候， 比如： 整个数据要准确无误的传递给对方， 这往往用于一些要求可靠的应用， 比如HTTP、 HTTPS、 FTP等传输文件的协议， POP、 SMTP等邮件传输的协议。</p><p><strong>什么时候应该使用UDP？</strong><br>当对网络通讯质量要求不高的时候， 要求网络通讯速度能尽量的快， 这时就可以使用UDP。比如DNS域名系统。</p><h3 id="4-TCP连接的建立与终止"><a href="#4-TCP连接的建立与终止" class="headerlink" title="4. TCP连接的建立与终止"></a>4. TCP连接的建立与终止</h3><p><img src="/images/img_tcp.png" alt="img_tcp"></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>• 第一次握手： 建立连接。 客户端发送连接请求报文段， 将 SYN 设置为 1、 Sequence Number（seq）为 x； 接下来客户端进入 SYN_SENT 状态， 等待服务端的确认。<br>• 第二次握手： 服务器收到客户端的 SYN 报文段， 对 SYN 报文段进行确认， 设置 Acknowledgment Number（ACK） 为 x+1（seq+1） ； 同时自己还要发送 SYN 请求信息， 将 SYN 设置为1、 seq 为 y。 服务端将上述所有信息放到 SYN+ACK 报文段中， 一并发送给客户端， 此时服务端进入 SYN_RCVD 状态。<br>• 第三次握手： 客户端收到服务端的 SYN+ACK 报文段； 然后将 ACK 设置为 y+1， 向服务端发送 ACK 报文段， 这个报文段发送完毕后， 客户端和服务端都进入 ESTABLISHED （TCP连接成功） 状态。</p><p><strong>为什么要三次握手？</strong><br>　　为了防止已失效的连接请求报文段突然又传送到了服务端， 因而产生错误。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>• 第一次挥手： 客户端设置 seq 和 ACK， 向服务端发送一个 FIN 报文段。 此时， 客户端进入 FIN_WAIT_1 状态， 表示客户端没有数据要发送给服务端了。<br>• 第二次挥手： 服务端收到了客户端发送的 FIN 报文段， 向客户端回了一个 ACK 报文段。<br>• 第三次挥手： 服务端向客户端发送 FIN 报文段， 请求关闭连接， 同时服务端进入 LAST_ACK 状态。<br>• 第四次挥手： 客户端收到服务端发送的 FIN 报文段， 向服务端发送 ACK 报文段， 然后客户端进入 TIME_WAIT 状态。 服务端收到客户端的 ACK 报文段以后， 就关闭连接。 此时， 客户端等待 2MSL（最大报文段生存时间） 后依然没有收到回复， 则说明服务端已正常关闭， 这样客户端也可以关闭连接了。</p><p><strong>为什么要四次挥手？</strong><br>　　为了保证在最后断开的时候，客户端能够发送最后一个ACK报文段能够被服务器接收到，从而避免在下一个连接中出现上一个连接的滞留的报文。</p><h3 id="5-状态码"><a href="#5-状态码" class="headerlink" title="5. 状态码"></a>5. 状态码</h3><p>　　状态码由3位数字组成， 第一个数字定义了响应的类别， 且有以下5种可能取值。<br>• 1xx： 指示信息， 收到请求， 需要请求者继续执行操作。<br>• 2xx： 请求成功， 请求已被成功接收并处理。<br>• 3xx： 重定向， 要完成请求必须进行更进一步的操作。<br>• 4xx： 客户端错误， 请求有语法错误或请求无法实现。<br>• 5xx： 服务器错误， 服务器不能实现合法的请求。<br>常见的状态码如下：<br>• 200 OK： 客户端请求成功。<br>• 400 Bad Request： 客户端请求有语法错误， 服务器无法理解。<br>• 401 Unauthorized： 客户端请求未经授权， 这个状态码必须和WWW-Authenticate报头域一起使用。<br>• 403 Forbidden： 客户端请求被服务端拒绝。<br>• 404 Not Found： 客户端请求地址错误， 资源未找到<br>• 500 Internal Server Error： 服务器内部错误， 无法完成请求。<br>• 503 Server Unavailable： 服务器当前不能处理客户端的请求， 一段时间后可能恢复正常。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-网络分层体系结构&quot;&gt;&lt;a href=&quot;#1-网络分层体系结构&quot; class=&quot;headerlink&quot; title=&quot;1. 网络分层体系结构&quot;&gt;&lt;/a&gt;1. 网络分层体系结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/img_web.jpg&quot; alt=&quot;img_web&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业基础知识" scheme="https://lvmdu.gitee.io/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="网络" scheme="https://lvmdu.gitee.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识汇总</title>
    <link href="https://lvmdu.gitee.io/2020/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>https://lvmdu.gitee.io/2020/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</id>
    <published>2020-02-28T09:20:00.000Z</published>
    <updated>2020-02-28T12:09:13.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java基本数据类型的字节数"><a href="#1-Java基本数据类型的字节数" class="headerlink" title="1. Java基本数据类型的字节数"></a>1. Java基本数据类型的字节数</h3><table><thead><tr><th align="center">基本数据类型</th><th align="center">字节数</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">1</td></tr><tr><td align="center">boolean</td><td align="center">1</td></tr><tr><td align="center">char</td><td align="center">2</td></tr><tr><td align="center">short</td><td align="center">2</td></tr><tr><td align="center">int</td><td align="center">4</td></tr><tr><td align="center">long</td><td align="center">8</td></tr><tr><td align="center">float</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">8</td></tr></tbody></table><p>注：long double：8</p><a id="more"></a><h3 id="2-基本数据类型和引用类型的区别"><a href="#2-基本数据类型和引用类型的区别" class="headerlink" title="2. 基本数据类型和引用类型的区别"></a>2. 基本数据类型和引用类型的区别</h3><p><strong>基本类型变量：</strong></p><ul><li>在内存中存储的是一个基本类型 值</li><li>可以在栈中直接分配内存</li><li>将一个变量的实际值赋给另一个变量：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = <span class="number">2</span>;</span><br><span class="line">j = i;  <span class="comment">//就是将基本类型变量 j 的内容复制给基本类型变量 i</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>引用类型变量：</strong></p><ul><li>在内存中存储的是一个引用，它指向对象的存储地址</li><li>对象的引用在栈中，对象实际存放在堆中</li><li>将一个变量的引用赋给另一个变量：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c1 = <span class="keyword">new</span> Circle(<span class="number">9</span>);</span><br><span class="line">c2 = <span class="keyword">new</span> Circle(<span class="number">6</span>);</span><br><span class="line">c2 = c1;  <span class="comment">//就是将c2的引用赋给c1，赋值之后，变量c2和c1指向同一个对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个时候c1以前的引用对象不再有用，因此，现在它就称为垃圾。垃圾会占用内存空间。</span></span><br><span class="line"><span class="comment">Java运行系统会检测垃圾并自动回收它所占据的空间，这个过程称为垃圾回收。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong> 如果你不再需要某个对象，可以显式地给该对象的引用变量赋值为null。 如果该对象没有被任何引用变量所引用，Java虚拟机会自动回收它所占据的空间。</p><h3 id="3-equals-和-的区别"><a href="#3-equals-和-的区别" class="headerlink" title="3. equals 和 == 的区别"></a>3. equals 和 == 的区别</h3><p><strong>==</strong><br>　　既可以比较基本数据类型类型的变量，又可以比较引用类型的变量。</p><ul><li>如果作用于基本的数据类型变量，则直接比较 <strong>值</strong> 是否相等；</li><li>如果作用于引用类型的变量，则比较所指向的 <strong>对象的地址</strong> 是否相等。</li></ul><p><strong>equals</strong><br>　　只能比较引用类型的变量，而不能比较基本数据类型的变量。</p><ul><li>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的 <strong>对象的地址</strong> 是否相等；</li><li>如果对equals方法进行重写（如String、Date等），则比较所指向 <strong>对象的内容</strong> 是否相等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Java基本数据类型的字节数&quot;&gt;&lt;a href=&quot;#1-Java基本数据类型的字节数&quot; class=&quot;headerlink&quot; title=&quot;1. Java基本数据类型的字节数&quot;&gt;&lt;/a&gt;1. Java基本数据类型的字节数&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;基本数据类型&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;字节数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;byte&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;boolean&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;char&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;short&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;int&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;long&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;float&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;double&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;注：long double：8&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://lvmdu.gitee.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://lvmdu.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>详解事件分发机制</title>
    <link href="https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-27T10:05:00.000Z</published>
    <updated>2020-02-28T03:57:29.858Z</updated>
    
    <content type="html"><![CDATA[<p>　　安卓上面的View是树形结构的，View可能会重叠在一起，当点击的地方有多个View可以响应的时候，这个点击事件应该给谁呢？为了解决这个问题，就有了<strong>事件分发机制</strong>。</p><a id="more"></a><h2 id="一、对象"><a href="#一、对象" class="headerlink" title="一、对象"></a>一、对象</h2><p>　　事件分发的<strong>三个主要对象</strong>：<strong>Activiy、ViewGroup、View</strong><br>　　事件分发的主要顺序： <strong>Activity(Window) -&gt; ViewGroup -&gt; View</strong><br>　　Android的UI界面是由Activity、 ViewGroup、 View及其派生类所构成的。<br><img src="/images/img_view_2.jpg" alt="img_view_2"></p><p>　　Activity的构成如下：<br><img src="/images/img_view_1.png" alt="img_view_1"></p><ul><li>PhoneWindow：是抽象类Window的唯一实现类，抽象类Window是所有视图最顶层的容器，包括View视图的外观和行为都归Window管。</li><li>DecorView：PhoneWindow的内部类，DecorView将屏幕氛围2个部分：TitleView 和 ContentView，我们平常加载的布局就是ContentView。通过DecorView传递信息给下面的View，下面的View也通过DecorView返回消息给PhoneWindow。</li></ul><p>事件分发的具体顺序： <strong>PhoneWindow -&gt; DecorView -&gt; ViewGroup -&gt; View</strong></p><h2 id="二、重要方法"><a href="#二、重要方法" class="headerlink" title="二、重要方法"></a>二、重要方法</h2><ul><li><strong>dispatchTouchEvent：</strong> 进行事件的分发</li><li><strong>onInterceptTouchEvent：</strong> 进行事件的拦截， 在 dispatchTouchEvent 内部调用。</li><li><strong>onTouchEvent：</strong> 处理事件，在 dispatchTouchEvent 内部调用。</li></ul><h2 id="三、分发流程"><a href="#三、分发流程" class="headerlink" title="三、分发流程"></a>三、分发流程</h2><p><img src="/images/img_view_3.jpg" alt="img_view_3"></p><p><img src="/images/img_view_4.jpg" alt="img_view_4"></p><p>（1）当点击事件产生后首先会由Activity来处理，在内部先传递到PhoneWindow，再传递给DecorView。之后传递到顶层的ViewGroup。<br>（2）ViewGroup的dispatchTouchEvent方法会进行判断：</p><ul><li>如果onInterceptTouchEvent方法返回true，则该ViewGroup就拦截这个事件，并交给它的onTouchEvent方法处理；</li><li>如果onInterceptTouchEvent方法返回false，则该ViewGroup就不会拦截这个事件，因此，交给它的子元素(ViewGroup/View)的dispatchTouchEvent方法处理。如果子元素的onInterceptTouchEvent方法仍返回false，则继续向下传递……</li></ul><p>（3）如此反复，直到传递到底层的View。<br>（4）底层View的onTouchEvent方法：</p><ul><li>如果返回true，则事件由底层View消耗并处理。</li><li>如果返回false，则事件不做处理，传递到父元素(ViewGroup/View)的onTouchEvent处理。如果父元素的onTouchEvent方法仍返回false，则继续向上传递……</li></ul><p>（5）如此反复，直到传递到Activity。如果Activity的onTouchEvent方法仍返回false，则该事件将会被抛弃。</p><p>　　整个过程采用了<strong>责任链模式</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　安卓上面的View是树形结构的，View可能会重叠在一起，当点击的地方有多个View可以响应的时候，这个点击事件应该给谁呢？为了解决这个问题，就有了&lt;strong&gt;事件分发机制&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>详解消息机制</title>
    <link href="https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-27T09:32:00.000Z</published>
    <updated>2020-02-28T02:21:09.157Z</updated>
    
    <content type="html"><![CDATA[<p>　　Android的<strong>消息机制</strong>也就是Handler机制。主要的作用是用来在不同线程之间的通信，通常使用在子线程执行完成一些耗时操作，需要回到主线程更新界面UI时，通过Handler将有关UI的操作切换到主线程。</p><a id="more"></a><h2 id="一、消息机制存在的意义"><a href="#一、消息机制存在的意义" class="headerlink" title="一、消息机制存在的意义"></a>一、消息机制存在的意义</h2><p><strong>为什么不能在非UI线程中操作UI控件？</strong><br>　　因为Android的UI控件（View）不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态。<br><strong>为什么不对UI控件加上锁机制？</strong><br>　　首先加上锁会让UI访问的逻辑变得复杂；其次锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。</p><h2 id="二、消息机制的工作原理"><a href="#二、消息机制的工作原理" class="headerlink" title="二、消息机制的工作原理"></a>二、消息机制的工作原理</h2><p>消息机制主要包含： <strong>MessageQueue</strong>、<strong>Handler</strong> 和<strong>Looper</strong>这三大部分，以及<strong>Message</strong>。</p><ul><li>Message： 需要传递的消息， 可以传递数据；</li><li>MessageQueue： 消息队列， 但是它的内部实现并不是用的队列， 实际上是通过一个<strong>单链表</strong>的数据结构来维护消息列表， 因为单链表在插入和删除上比较有优势。 主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next)；</li><li>Handler： 消息辅助类， 主要功能向消息池发送各种消息事件(Handler.sendMessage)和处理相应消息事件(Handler.handleMessage)；</li><li>Looper： 不断循环执行(Looper.loop)， 从MessageQueue中读取消息， 按分发机制将消息分发给目标处理者。<br><img src="/images/img_handler.jpg" alt="img_handler"><h4 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h4>（1）应用程序启动的时候，在主线程中会默认调用了 Looper.preper()方法，初始化Looper对象并绑定到当前线程中，并在Looper内部维护一个MessageQueue。<br>（2）接着调用handler.sendMessage()发送消息（handler.postRunnable()实际上底层也是调用了handler.sendMessage()，只不过进行了封装），会通过MessageQueue.enqueueMessage()向MessageQueue中添加一条消息。<br>（3）主线程调用Looper.looper()开启循环，不断轮询消息队列，通过MessageQueue.next()取出消息。<br>（4）取出的message不为空则调用msg.target.dispatchMessage()传递分发消息，目标handler收到消息后会执行handler.handlerMessage()方法处理消息。</li></ul><p><strong>MessageQueue、Handler 和 Looper 三者之间的关系：</strong></p><ul><li><strong>一个线程中只能存在一个Looper</strong>， Looper是保存在ThreadLocal中的。 主线程（UI线程）已经创建了一个Looper， 所以在主线程中不需要再创建Looper， 但是在其他线程中需要创建Looper。</li><li>每个线程中可以有多个Handler， 即<strong>一个Looper可以处理来自多个Handler的消息</strong>。</li><li><strong>一个Looper中维护一个MessageQueue</strong>， 来维护消息队列， 消息队列中的Message可以来自不同的Handler。</li></ul><h2 id="三、深入理解消息机制"><a href="#三、深入理解消息机制" class="headerlink" title="三、深入理解消息机制"></a>三、深入理解消息机制</h2><h4 id="1-为什么一个线程只有一个Looper？"><a href="#1-为什么一个线程只有一个Looper？" class="headerlink" title="1. 为什么一个线程只有一个Looper？"></a>1. 为什么一个线程只有一个Looper？</h4><p>　　因为线程对应的Looper是在<strong>ThreadLocal</strong>里面存储，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其它线程来说无法获取到数据。另外，在Looper的创建方法Looper.prepare()中，会进行判断，如果当前线程已经存在Looper对象，就会报RunTimeException异常。<br><strong>补充：为什么ThreadLocal可以在多个线程中互不干扰的存储和修改数据？</strong> ThreadLocal所做的读写操作仅限于各自线程的内部</p><h4 id="2-为什么主线程中可以直接使用Handler，而不用创建Looper？"><a href="#2-为什么主线程中可以直接使用Handler，而不用创建Looper？" class="headerlink" title="2. 为什么主线程中可以直接使用Handler，而不用创建Looper？"></a>2. 为什么主线程中可以直接使用Handler，而不用创建Looper？</h4><p>　　<strong>UI线程(ActivityThread)被创建时默认初始化了Looper</strong>。因此在主线程中可以直接使用Handler。</p><h4 id="3-可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？"><a href="#3-可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？" class="headerlink" title="3. 可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？"></a>3. 可以在子线程中直接使用Handler吗？如何在子线程中使用Handler？</h4><p>　　子线程中不可以直接使用Handler，子线程中默认是没有Looper的，同时MessageQueue又是Looper来维护的。因此如果在子线程中直接发送消息，是没有关联MessageQueue可以存储消息。因此会抛出异常。<br>　　如果想在子线程中使用Handler，必须通过Looper.prepare()去初始化一个Looper，并且再通过Looper.loop()开启循环。</p><h4 id="4-Looper-loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？"><a href="#4-Looper-loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？" class="headerlink" title="4. Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？"></a>4. Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？</h4><p>　　在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。（因此，looper.looper()阻塞不会消耗大量的CPU资源。）<br>　　epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。<br>　　所谓ANR便是Looper.loop没有得到及时处理，一旦没有消息，Linux的epoll机制则会通过管道写文件描述符的方式来对主线程进行唤醒与睡眠，Android里调用了linux层的代码实现在适当时会睡眠主线程。</p><p><strong>消息循环（死循环）的必要性：</strong><br>　　线程既然是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出。例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。<br>　　ActivityThread的main方法主要就是做消息循环，一旦退出消息循环，那么你的应用也就退出了。如果main方法中没有Looper进行循环，那么主线程一运行完毕就会退出。</p><h2 id="四、Handler引起的内存泄漏"><a href="#四、Handler引起的内存泄漏" class="headerlink" title="四、Handler引起的内存泄漏"></a>四、Handler引起的内存泄漏</h2><h3 id="1-原因："><a href="#1-原因：" class="headerlink" title="1. 原因："></a>1. 原因：</h3><p>　　<strong>非静态、匿名内部类会隐式持有外部类的引用，导致外部Activity无法回收。</strong></p><h3 id="2-解决方法："><a href="#2-解决方法：" class="headerlink" title="2. 解决方法："></a>2. 解决方法：</h3><p>（1）将Handler修改为静态内部类<br>（2）Handler内部持有外部Activity的弱引用<br>（3）在onDestory()中调用handler.removeCallbackAndMessages(null)</p><h2 id="五、AsyncTask"><a href="#五、AsyncTask" class="headerlink" title="五、AsyncTask"></a>五、AsyncTask</h2><h4 id="1-核心方法"><a href="#1-核心方法" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h4><ul><li>onPreExecute()</li><li>doInBackground(Params…params)</li><li>onProgressUpdate(Params…params)</li><li>onPostExecute(Result result)</li></ul><p><strong>注意：</strong><br>（1）只有onProgressUpdate在线程池中执行，可以执行耗时任务；其他方法都是在主线程中。<br>（2）AsyncTask的类必须在主线程中加载；对象必须在主线程中创建；execute方法必须在UI线程中调用。<br>（3）不要在程序中直接调用4个核心方法<br>（4）一个AsyncTask对象只能执行一次，只能调用一次execute方法。<br>（5）Android 1.6之前，AsyncTask是串行执行的。之后的版本加入了并行执行。可以通过executeOnExecutor并行执行任务，但不建议。</p><h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h4><p>　　AsyncTask内部封装了一个静态线程池，通过内部的InternalHandler在UI线程和子线程之间传递消息。</p><h4 id="3-使用不当的后果"><a href="#3-使用不当的后果" class="headerlink" title="3. 使用不当的后果"></a>3. 使用不当的后果</h4><p>1）生命周期<br>　　AsyncTask不与任何组件绑定生命周期， 所以在Activity/或者Fragment中创建执行AsyncTask时， 最好在Activity/Fragment的onDestory()调用cancel(boolean)。<br>2）内存泄漏<br>　　如果AsyncTask被声明为Activity的非静态的内部类， 那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用。 如果Activity已经被销毁， AsyncTask的后台线程还在执行， 它将继续在内存里保留这个引用， 导致Activity无法被回收， 引起内存泄露。<br>3）结果丢失<br>　　屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建， 之前运行的AsyncTask（非静态的内部类）会持有一个之前Activity的引用， 这个引用已经无效， 这时再去更新界面将不再生效。</p><h2 id="六、HandlerThread"><a href="#六、HandlerThread" class="headerlink" title="六、HandlerThread"></a>六、HandlerThread</h2><p>　　HandlerThread继承了Thread，同时它的内部创建了MessageQueue，可以进行Looper循环，是一个具有消息循环的线程。我们通过它可以直接使用Handler。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Android的&lt;strong&gt;消息机制&lt;/strong&gt;也就是Handler机制。主要的作用是用来在不同线程之间的通信，通常使用在子线程执行完成一些耗时操作，需要回到主线程更新界面UI时，通过Handler将有关UI的操作切换到主线程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>详解Binder机制</title>
    <link href="https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3Binder%E6%9C%BA%E5%88%B6/"/>
    <id>https://lvmdu.gitee.io/2020/02/27/%E8%AF%A6%E8%A7%A3Binder%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-27T09:04:00.000Z</published>
    <updated>2020-02-27T14:31:20.452Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong>Binder机制</strong> 是Android中的一种跨进程的通信机制。</p><a id="more"></a><h2 id="一、IPC原理"><a href="#一、IPC原理" class="headerlink" title="一、IPC原理"></a>一、IPC原理</h2><p>　　从进程角度来看IPC（Interprocess Communication）机制：<br>    <img src="/images/img_ipc.jpg" alt="img_ipc"><br>　　每个Android的进程， 只能运行在自己进程所拥有的虚拟地址空间（<strong>进程隔离</strong>）。 <strong>对于用户空间， 不同进程之间是不能共享的， 而内核空间却是可共享的。</strong> Client进程向Server进程通信， 恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的。 Client端与Server端进程往往采用ioctl（设备控制接口）等方法完成用户空间与内核空间的驱动进行交互。</p><h2 id="二、为什么要使用Binder？"><a href="#二、为什么要使用Binder？" class="headerlink" title="二、为什么要使用Binder？"></a>二、为什么要使用Binder？</h2><h3 id="1-性能方面"><a href="#1-性能方面" class="headerlink" title="1. 性能方面"></a>1. 性能方面</h3><p>　　在Android设备上（性能受限制，比如要省电）， 广泛地使用跨进程通信对通信机制的性能有严格的要求， Binder相对于传统的Socket方式， 更加高效。 Binder数据拷贝只需要一次， 而管道、 消息队列、 Socket都需要两次， 而共享内存方式虽然一次内存拷贝都不需要， 但实现方式又比较复杂。</p><h3 id="2-安全方面"><a href="#2-安全方面" class="headerlink" title="2. 安全方面"></a>2. 安全方面</h3><p>　　传统的进程通信方式对于通信双方的身份并没有做出严格的验证， 比如Socket通信的IP地址是客户端手动填入， 很容易进行伪造。 然而， Binder机制从协议本身就支持对通信双方做身份校检， 从而大大提升了安全性。</p><h2 id="三、Binder原理"><a href="#三、Binder原理" class="headerlink" title="三、Binder原理"></a>三、Binder原理</h2><p>　　Binder通信采用<strong>C/S架构</strong>， 从组件视角来说， 包含<strong>Client、 Server、 ServiceManager以及Binder驱动</strong>， 其中ServiceManager用于管理系统中的各种服务。<br>架构图如下所示：<br><img src="/images/img_binder.jpg" alt="img_binder"></p><h4 id="Binder通信的四个角色："><a href="#Binder通信的四个角色：" class="headerlink" title="Binder通信的四个角色："></a>Binder通信的四个角色：</h4><ul><li>Client进程： 使用服务的进程。</li><li>Server进程： 提供服务的进程。</li><li>ServiceManager进程： ServiceManager的作用是将字符形式的<strong>Binder名字转化成Client中对该Binder的引用</strong>， 使得Client能够通过Binder名字获得对Server中Binder实体的引用(代理对象)。</li><li>Binder驱动： 驱动负责进程之间Binder通信的建立。</li></ul><p><strong>注意：</strong><br>对于Service进程来说，Binder指的是Binder本地对象；<br>对于Client进程来说，Binder指的是Binder代理对象。</p><h4 id="Binder运行机制："><a href="#Binder运行机制：" class="headerlink" title="Binder运行机制："></a>Binder运行机制：</h4><p>（1）<strong>注册服务</strong>： Server进程要先注册Service到ServiceManager。 该过程： Server是客户端， ServiceManager是服务端。<br>（2）<strong>获取服务</strong>： Client进程使用某个Service前， 须先向ServiceManager中获取相应的Service。 该过程： Client是客户端， ServiceManager是服务端。<br>（3）<strong>使用服务</strong>： Client根据得到的Service信息建立与Service所在的Server进程通信的通路， 然后就可以直接与Service交互。 该过程： Client是客户端， Server是服务端。</p><h2 id="四、AIDL"><a href="#四、AIDL" class="headerlink" title="四、AIDL"></a>四、AIDL</h2><p>　　<strong>AIDL</strong> (Android Interface Definition Language) 是一种接口定义语言， 用于生成可以在Android设备上两个进程之间进行进程间通信(Interprocess Communication, IPC)的代码。 如果在一个进程中（ 例如Activity） 要调用另一个进程中（ 例如Service）对象的操作， 就可以使用AIDL生成可序列化的参数， 来完成进程间通信。<br>　　AIDL之所以能够实现进程间通信， 其内部是通过<strong>Binder机制</strong>来实现的。</p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h4><p>服务端：</p><ul><li>创建JavaBean，并实现进行序列化</li><li>新建同名的AIDL文件，并在文件中声明JavaBean对象</li><li>新建AIDL接口文件，并且在其中定义方法</li><li>创建继承Service的自定义服务并重写onBind方法</li><li>声明Stub类型变量（Binder类型），并实现接口方法</li></ul><p>客户端：</p><ul><li>将服务端中AIDL文件夹移植到客户端</li><li>声明接口类型变量</li><li>声明ServiceConnection类型变量，并完成bindService</li><li>在serviceConnected方法中通过IBookManager.Stub.asInterface(service)获取接口对象</li></ul><p>　　这样就可以通过接口对象调用服务端接口中的定义的方法了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt;Binder机制&lt;/strong&gt; 是Android中的一种跨进程的通信机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件之ContentProvider</title>
    <link href="https://lvmdu.gitee.io/2020/02/27/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BContentProvider/"/>
    <id>https://lvmdu.gitee.io/2020/02/27/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BContentProvider/</id>
    <published>2020-02-27T08:10:00.000Z</published>
    <updated>2020-02-28T01:55:24.572Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong>内容提供者（ContentProvider）</strong> 是用于在不同的应用程序之间实现数据共享的一种组件。它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。</p><a id="more"></a><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>　　进程间进行数据的交互和共享，即跨进程通信（IPC）。<br><img src="/images/img_content_provider.jpg" alt="img_content_provider"></p><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p>　　ContentProvider的底层通信是采用Android中的<strong>Binder机制</strong>。<br><img src="/images/img_content_provider_new.jpg" alt="img_content_provider_new"></p><h4 id="ContentProvider类"><a href="#ContentProvider类" class="headerlink" title="ContentProvider类"></a>ContentProvider类</h4><p>　　ContentProvider主要以表格的形式组织数据，同时也支持文件数据，只是表格形式用得比较多。每个表格中包含多张表， 每张表包含行 &amp; 列，分别对应记录 &amp; 字段。</p><h4 id="ContentResolver类"><a href="#ContentResolver类" class="headerlink" title="ContentResolver类"></a>ContentResolver类</h4><p>　　统一管理不同ContentProvider间的操作。外部进程通过ContentResolver类，从而与ContentProvider类进行交互。<br>　　一般来说，一款应用要使用多个ContentProvider，若需要了解每个ContentProvider的不同实现从而再完成数据交互，操作成本高 &amp; 难度大。所以在ContentProvider类上加多了一个ContentResolver类对所有的ContentProvider进行统一管理。</p><p>　　Android 提供了3个用于辅助 ContentProvide 的工具类：</p><ul><li><strong>ContentUris</strong>：操作 URI</li><li><strong>UriMatcher</strong>：<br>1）在 ContentProvider 中注册 URI<br>2）根据 URI 匹配 ContentProvider 中对应的数据表</li><li><strong>ContentObserver</strong>：观察 URI 引起 ContentProvider 中的数据变化并通知数据访问者</li></ul><h2 id="三、用法"><a href="#三、用法" class="headerlink" title="三、用法"></a>三、用法</h2><h3 id="1-主要用法："><a href="#1-主要用法：" class="headerlink" title="1. 主要用法："></a>1. 主要用法：</h3><p>（1）使用现有的内容提供者来读取和操作现有的程序中的数据。<br>（2）创建自己的内容提供者给我们的程序提供外部访问接口。</p><h3 id="2-创建ContentProvider基本流程"><a href="#2-创建ContentProvider基本流程" class="headerlink" title="2. 创建ContentProvider基本流程"></a>2. 创建ContentProvider基本流程</h3><p>1）创建数据库类DBHelper继承自SQLiteOpenHelper<br>2）定义一个类DataProvider继承自ContentProvider<br>3）实现其onCreate、getType、insert、delete、update、query方法<br>4）在清单文件中注册ContentProvider<br>5）将访问途径Uri提供出去</p><h3 id="3-使用ContentProvider基本流程"><a href="#3-使用ContentProvider基本流程" class="headerlink" title="3. 使用ContentProvider基本流程"></a>3. 使用ContentProvider基本流程</h3><p>1）通过getContentResolver获取ContentResolver对象resolver<br>2）通过Uri对ContentProvider中的数据进行增删改查操作</p><h3 id="4-统一资源标识符（URI）"><a href="#4-统一资源标识符（URI）" class="headerlink" title="4. 统一资源标识符（URI）"></a>4. 统一资源标识符（URI）</h3><p>定义： Uniform Resource Identifier ， 即统一资源标识符<br>作用： 唯一标识 ContentProvider &amp; 其中的数据<br>　　外界进程通过 URI 找到对应的ContentProvider &amp; 其中的数据， 再进行数据操作。<br>具体使用：<br>　　URI分为 系统预置（如通讯录、 日程表等） &amp; 自定义<br><img src="/images/img_uri.jpg" alt="img_uri"></p><h2 id="四、优点"><a href="#四、优点" class="headerlink" title="四、优点"></a>四、优点</h2><h3 id="1-安全"><a href="#1-安全" class="headerlink" title="1. 安全"></a>1. 安全</h3><p>　　ContentProvider为应用间的数据交互提供了一个安全的环境：允许把自己的应用数据<strong>根据需求</strong>开放给其他应用进行增、删、改、 查，而不用担心因为直接开放数据库权限而带来的安全问题。</p><h3 id="2-访问简单-amp-高效"><a href="#2-访问简单-amp-高效" class="headerlink" title="2. 访问简单 &amp; 高效"></a>2. 访问简单 &amp; 高效</h3><p>　　对比于其他对外共享数据的方式，数据访问方式会因数据存储的方式而不同：</p><ul><li>采用 文件方式 对外共享数据， 需要进行文件操作读写数据；</li><li>采用 Sharedpreferences 共享数据， 需要使用sharedpreferences API读写数据<br>这使得访问数据变得复杂 &amp; 难度大。<br>　　而采用ContentProvider方式，其解耦了底层数据的存储方式， 使得无论底层数据存储采用何种方式，外界对数据的访问方式都是统一的， 这使得访问简单 &amp;　高效。</li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><img src="/images/img_content_provider_all.jpg" alt="img_content_provider_all"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt;内容提供者（ContentProvider）&lt;/strong&gt; 是用于在不同的应用程序之间实现数据共享的一种组件。它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件之BroadcastReceiver</title>
    <link href="https://lvmdu.gitee.io/2020/02/27/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BBroadcastReceiver/"/>
    <id>https://lvmdu.gitee.io/2020/02/27/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BBroadcastReceiver/</id>
    <published>2020-02-27T03:16:00.000Z</published>
    <updated>2020-02-28T01:02:42.005Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong>广播接收者（BroadcastReceiver）</strong> 是Android中用于接收广播的一种组件。广播是一种广泛运用的在应用程序之间传递信息的机制。广播类似于Java中的观察者模式，广播的内容是一个携带信息的Intent。</p><a id="more"></a><h2 id="一、广播的分类"><a href="#一、广播的分类" class="headerlink" title="一、广播的分类"></a>一、广播的分类</h2><h3 id="1-按形式分："><a href="#1-按形式分：" class="headerlink" title="1. 按形式分："></a>1. 按形式分：</h3><ul><li>标准广播：异步执行、没有先后顺序、效率高、无法被截断</li><li>有序广播：同步执行、有先后顺序、效率低、可以被截断（前面的广播可以截断后面正在传递的广播）<h3 id="2-按级别分："><a href="#2-按级别分：" class="headerlink" title="2. 按级别分："></a>2. 按级别分：</h3></li><li>普通广播：正常定义的广播（注意：广播是可以跨App直接通信的）</li><li>系统广播：系统定义的广播</li><li>本地广播：可理解为一种局部广播， 广播的发送者和接收者都同属于一个App。<br>相比于全局广播（普通广播），本地广播优势体现在：安全性高、效率高</li><li>粘性广播：Intent会一直保留到广播事件结束，并且没有10秒限制。（10秒限制是指普通的广播如果onReceive方法执行时间太长，超过10秒的时候系统会将这个广播置为可以干掉的candidate，一旦系统资源不够的时候，就会干掉这个广播而让它不执行。）</li></ul><p><strong>注意：</strong><br>粘性广播在Android 5.0(API 21)中已弃用。</p><h2 id="二、注册方式"><a href="#二、注册方式" class="headerlink" title="二、注册方式"></a>二、注册方式</h2><h3 id="1-动态注册"><a href="#1-动态注册" class="headerlink" title="1. 动态注册"></a>1. 动态注册</h3><p>（1）创建一个自定义的广播接收者，继承于BroadcastReceiver，并重写onReceive方法。<br>（2）在Activity中，通过registerReceiver方法注册广播接收者。</p><ul><li>非常驻型广播：跟随组件的生命周期，如果应用程序关闭，动态注册的广播就无法接收</li><li>优先级较高</li></ul><p><strong>注意：</strong><br>1）在Activity生命周期结束前，记得注销广播接收者，否则会导致内存泄漏。<br>2）动态注册广播最好应该在onResume中注册、在onPause()中注销。</p><h3 id="2-静态注册"><a href="#2-静态注册" class="headerlink" title="2. 静态注册"></a>2. 静态注册</h3><p>（1）创建一个自定义的广播接收者，继承于BroadcastReceiver，并重写onReceive方法。<br>（2）在AndroidManifest文件中，通过&lt;receiver&gt;标签注册广播接收者。</p><ul><li>常驻型广播：不受组件生命周期的影响，即使应用程序关闭，静态注册的广播仍能够接收</li><li>优先级较低<br>缺点：耗电、占内存</li></ul><p><strong>注意：</strong></p><ol><li><strong>Android 8.0以上版本，绝大部分的广播不能进行静态注册。</strong> 由于静态注册的方式非常的耗电，Google专门进行了优化。</li><li><strong>不要在onReceive()方法中进行任何耗时操作。</strong> 由于，onReceive()方法运行在主线程中，耗时操作会导致ANR（通常是10秒）。</li><li><strong>广播接收者不允许开启子线程</strong>，原因：</li></ol><ul><li>对于静态注册的广播接收者来说，广播接收者对象的生命周期较短，执行完onReceive()方法就会变为垃圾对象而被回收。在子线程执行完之前，若对应的Activity退出，他们所在进程就变成了空进程(没有任何活动组件的进程)，系统需要内存时可能会优先终止该进程，进程被终止，其内的子线程也会被终止，导致子线程无法执行完。</li><li>对于动态注册的广播接收者来说，Activity退出时会调用unregisteReceiver()方法执行解注册，此时广播接收者对象也会变成垃圾对象而被回收。在子线程执行完之前，对应的Activity退出，同样它们所在进程就变成了空进程，其内的子线程也无法执行完。</li></ul><ol start="4"><li><strong>如果必须执行耗时任务可以考虑，在onReceive中开启服务来执行。</strong> 系统就会认为这个进程里还有其他活动组件在运行，就不会任意时刻回收此进程。</li></ol><h2 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h2><p><img src="/images/img_broadcast_receiver.jpg" alt="img_broadcast_receiver"></p><ol><li>广播接收者通过<strong>Binder机制</strong>向AMS(Activity Manager Service)进行注册；</li><li>广播发送者通过<strong>Binder机制</strong>向AMS发送广播；</li><li>AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，AMS将广播发送到上述符合条件的BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；</li><li>BroadcastReceiver通过消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。</li></ol><p><strong>注意：</strong><br>　　广播发送者和广播接收者的执行是<strong>异步</strong>的，发出去的广播不会关心有无接收者接收，也不确定接收者到底是何时才能接收到。</p><h2 id="四、LocalBroadcastManager"><a href="#四、LocalBroadcastManager" class="headerlink" title="四、LocalBroadcastManager"></a>四、LocalBroadcastManager</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h3><p>（1）使用它发送的广播只能在自身App内传播，因此不必担心泄漏隐私数据；<br>（2）其它App无法对你的App发送广播，具有更高的安全性；<br>（3）比系统的全局广播更加高效。</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>　　内部是通过<strong>Handler</strong>实现的。它的sendBroadcast方法其实是通过Handler发送了一个Message。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt;广播接收者（BroadcastReceiver）&lt;/strong&gt; 是Android中用于接收广播的一种组件。广播是一种广泛运用的在应用程序之间传递信息的机制。广播类似于Java中的观察者模式，广播的内容是一个携带信息的Intent。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android基础" scheme="https://lvmdu.gitee.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://lvmdu.gitee.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(六) 数学问题</title>
    <link href="https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-6-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
    <id>https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-6-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-26T13:04:00.000Z</published>
    <updated>2020-02-26T13:24:30.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h3><p><strong><em>题目描述：</em></strong><br>输入一个整数，输出概述二进制表示中1的个数，其中负数用补码表示<br>时间限制：1秒 空间限制：32768K</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：每一位和 1 相与：1 -&gt; 1  0 -&gt; 0</span></span><br><span class="line"><span class="comment">     *       然后将1每次左移一位，1 -&gt; 10 -&gt; 100 ...</span></span><br><span class="line"><span class="comment">     *       统计需要做多少次运算变成0</span></span><br><span class="line"><span class="comment">     *       （该方法无法通过全部的测试用例）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = ~n + <span class="number">1</span>;  <span class="comment">//求补码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getNumberOf1(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：一个整数减去1和原整数想与，</span></span><br><span class="line"><span class="comment">     *       会将该整数最右边的一个1变成0，</span></span><br><span class="line"><span class="comment">     *       统计需要做多少次运算将变成0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf11</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h3><p><strong><em>题目描述</em></strong><br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：传统公式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//        int exp = Math.abs(exponent);</span></span><br><span class="line">        <span class="keyword">int</span> exp = exponent;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exp = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exp; i++) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：数学函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power1</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result;</span><br><span class="line">        <span class="keyword">if</span> (exponent &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            result = Math.pow(base, exponent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = Math.pow(base, -exponent);</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法3：按位运算</span></span><br><span class="line"><span class="comment">     * 举例: 10^1101 = 10^0001*10^0100*10^1000。</span></span><br><span class="line"><span class="comment">     *      通过&amp;1和&gt;&gt;1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power2</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> exp = exponent;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exp = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (exp != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((exp &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                result *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            base *= base;</span><br><span class="line">            exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &lt; <span class="number">0</span> ? <span class="number">1</span> / result : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31-从1到n整数中1出现的次数"><a href="#31-从1到n整数中1出现的次数" class="headerlink" title="31. 从1到n整数中1出现的次数"></a>31. 从1到n整数中1出现的次数</h3><p><strong><em>题目描述</em></strong><br>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？<br>为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。<br>ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp % <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="46-圆圈中最后剩下的数"><a href="#46-圆圈中最后剩下的数" class="headerlink" title="46. 圆圈中最后剩下的数"></a>46. 圆圈中最后剩下的数</h3><p><strong><em>题目描述</em></strong><br>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。<br>HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。<br>然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,<br>然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….<br>直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。<br>请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)<br>时间限制：1秒 空间限制：32768K<br>本题知识点： 模拟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//约瑟夫环问题</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            s = (s + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48. 不用加减乘除做加法"></a>48. 不用加减乘除做加法</h3><p><strong><em>题目描述</em></strong><br>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num1 ^ num2;</span><br><span class="line">            num2 =  (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;11-二进制中1的个数&quot;&gt;&lt;a href=&quot;#11-二进制中1的个数&quot; class=&quot;headerlink&quot; title=&quot;11. 二进制中1的个数&quot;&gt;&lt;/a&gt;11. 二进制中1的个数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;题目描述：&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;输入一个整数，输出概述二进制表示中1的个数，其中负数用补码表示&lt;br&gt;时间限制：1秒 空间限制：32768K&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://lvmdu.gitee.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lvmdu.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(五) 动态规划</title>
    <link href="https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://lvmdu.gitee.io/2020/02/26/%E5%89%91%E6%8C%87Offer-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-02-26T12:54:00.000Z</published>
    <updated>2020-02-26T13:27:39.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h3><p><strong><em>题目描述</em></strong><br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39<br>斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……</p><a id="more"></a><p>在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           result = num1 + num2;</span><br><span class="line">           num1 = num2;</span><br><span class="line">           num2 = result;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划（递归）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> f[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      f[n] = Fibonacci2(n - <span class="number">1</span>) + Fibonacci2(n - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划（非递归）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> f[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(k &lt;= n) &#123;</span><br><span class="line">        f[k] = f[k-<span class="number">1</span>] + f[k-<span class="number">2</span>];</span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递推公式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">       <span class="keyword">double</span> root1 = (<span class="number">1</span> + sqrt5) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">double</span> root2 = (<span class="number">1</span> - sqrt5) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">new</span> Double((Math.pow(root1, n) - Math.pow(root2, n)) / sqrt5)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h3><p><strong><em>题目描述</em></strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于本题,前提只有 一次 1阶或者2阶的跳法。</span></span><br><span class="line"><span class="comment">a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);</span></span><br><span class="line"><span class="comment">b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)</span></span><br><span class="line"><span class="comment">c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"><span class="comment">d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</span></span><br><span class="line"><span class="comment">e.可以发现最终得出的是一个斐波那契数列：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           | 1, (n=1)</span></span><br><span class="line"><span class="comment">f(n) =     | 2, (n=2)</span></span><br><span class="line"><span class="comment">           | f(n-1)+f(n-2) ,(n&gt;2,n为整数)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>) + JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h3><p><strong><em>题目描述</em></strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1:1 2:2 3:4 4:8</span></span><br><span class="line"><span class="comment">可得规律</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-矩阵覆盖"><a href="#10-矩阵覆盖" class="headerlink" title="10. 矩阵覆盖"></a>10. 矩阵覆盖</h3><p><strong><em>题目描述</em></strong><br>我们可以用2<em>1的小矩阵横着或者竖着区覆盖更大的矩阵。<br>请问用n个2\</em>1的小矩阵无重叠地覆盖一个2*n的大矩阵，总共多少种方法？<br>时间限制：1秒 空间限制：32768K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">斐波那契数列变形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target-<span class="number">1</span>) + RectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;7-斐波那契数列&quot;&gt;&lt;a href=&quot;#7-斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;7. 斐波那契数列&quot;&gt;&lt;/a&gt;7. 斐波那契数列&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;题目描述&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。&lt;br&gt;n&amp;lt;=39&lt;br&gt;斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://lvmdu.gitee.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="算法" scheme="https://lvmdu.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
